
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Partner
 * 
 */
export type Partner = $Result.DefaultSelection<Prisma.$PartnerPayload>
/**
 * Model AccountBatch
 * 
 */
export type AccountBatch = $Result.DefaultSelection<Prisma.$AccountBatchPayload>
/**
 * Model InvoiceMCC
 * 
 */
export type InvoiceMCC = $Result.DefaultSelection<Prisma.$InvoiceMCCPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model AccountMIHistory
 * 
 */
export type AccountMIHistory = $Result.DefaultSelection<Prisma.$AccountMIHistoryPayload>
/**
 * Model AccountMCHistory
 * 
 */
export type AccountMCHistory = $Result.DefaultSelection<Prisma.$AccountMCHistoryPayload>
/**
 * Model SpendingSnapshot
 * 
 */
export type SpendingSnapshot = $Result.DefaultSelection<Prisma.$SpendingSnapshotPayload>
/**
 * Model SpendingRecord
 * 
 */
export type SpendingRecord = $Result.DefaultSelection<Prisma.$SpendingRecordPayload>
/**
 * Model ActivityLog
 * 
 */
export type ActivityLog = $Result.DefaultSelection<Prisma.$ActivityLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  BUYER: 'BUYER',
  LINKER: 'LINKER',
  ASSIGNER: 'ASSIGNER',
  UPDATER: 'UPDATER',
  VIEWER: 'VIEWER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PartnerType: {
  ACCOUNT_SUPPLIER: 'ACCOUNT_SUPPLIER',
  INVOICE_PROVIDER: 'INVOICE_PROVIDER',
  BOTH: 'BOTH'
};

export type PartnerType = (typeof PartnerType)[keyof typeof PartnerType]


export const BatchStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type BatchStatus = (typeof BatchStatus)[keyof typeof BatchStatus]


export const InvoiceMCCStatus: {
  ACTIVE: 'ACTIVE',
  PENDING: 'PENDING',
  EXHAUSTED: 'EXHAUSTED',
  INACTIVE: 'INACTIVE'
};

export type InvoiceMCCStatus = (typeof InvoiceMCCStatus)[keyof typeof InvoiceMCCStatus]


export const CreditStatus: {
  PENDING: 'PENDING',
  CONNECTED: 'CONNECTED',
  FAILED: 'FAILED'
};

export type CreditStatus = (typeof CreditStatus)[keyof typeof CreditStatus]


export const CustomerStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

export type CustomerStatus = (typeof CustomerStatus)[keyof typeof CustomerStatus]


export const AccountStatus: {
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type AccountStatus = (typeof AccountStatus)[keyof typeof AccountStatus]


export const HistoryReason: {
  INITIAL: 'INITIAL',
  MIGRATION: 'MIGRATION',
  CREDIT_EXHAUSTED: 'CREDIT_EXHAUSTED',
  REASSIGN: 'REASSIGN',
  CUSTOMER_INACTIVE: 'CUSTOMER_INACTIVE'
};

export type HistoryReason = (typeof HistoryReason)[keyof typeof HistoryReason]


export const SnapshotType: {
  MI_CHANGE: 'MI_CHANGE',
  MC_CHANGE: 'MC_CHANGE',
  DAILY_FINAL: 'DAILY_FINAL'
};

export type SnapshotType = (typeof SnapshotType)[keyof typeof SnapshotType]


export const ActivityAction: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LINK_MI: 'LINK_MI',
  UNLINK_MI: 'UNLINK_MI',
  ASSIGN_MC: 'ASSIGN_MC',
  UNASSIGN_MC: 'UNASSIGN_MC',
  SNAPSHOT: 'SNAPSHOT',
  IMPORT_SPENDING: 'IMPORT_SPENDING',
  IMPORT: 'IMPORT',
  SYNC: 'SYNC'
};

export type ActivityAction = (typeof ActivityAction)[keyof typeof ActivityAction]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type PartnerType = $Enums.PartnerType

export const PartnerType: typeof $Enums.PartnerType

export type BatchStatus = $Enums.BatchStatus

export const BatchStatus: typeof $Enums.BatchStatus

export type InvoiceMCCStatus = $Enums.InvoiceMCCStatus

export const InvoiceMCCStatus: typeof $Enums.InvoiceMCCStatus

export type CreditStatus = $Enums.CreditStatus

export const CreditStatus: typeof $Enums.CreditStatus

export type CustomerStatus = $Enums.CustomerStatus

export const CustomerStatus: typeof $Enums.CustomerStatus

export type AccountStatus = $Enums.AccountStatus

export const AccountStatus: typeof $Enums.AccountStatus

export type HistoryReason = $Enums.HistoryReason

export const HistoryReason: typeof $Enums.HistoryReason

export type SnapshotType = $Enums.SnapshotType

export const SnapshotType: typeof $Enums.SnapshotType

export type ActivityAction = $Enums.ActivityAction

export const ActivityAction: typeof $Enums.ActivityAction

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.partner`: Exposes CRUD operations for the **Partner** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Partners
    * const partners = await prisma.partner.findMany()
    * ```
    */
  get partner(): Prisma.PartnerDelegate<ExtArgs>;

  /**
   * `prisma.accountBatch`: Exposes CRUD operations for the **AccountBatch** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountBatches
    * const accountBatches = await prisma.accountBatch.findMany()
    * ```
    */
  get accountBatch(): Prisma.AccountBatchDelegate<ExtArgs>;

  /**
   * `prisma.invoiceMCC`: Exposes CRUD operations for the **InvoiceMCC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InvoiceMCCS
    * const invoiceMCCS = await prisma.invoiceMCC.findMany()
    * ```
    */
  get invoiceMCC(): Prisma.InvoiceMCCDelegate<ExtArgs>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs>;

  /**
   * `prisma.accountMIHistory`: Exposes CRUD operations for the **AccountMIHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountMIHistories
    * const accountMIHistories = await prisma.accountMIHistory.findMany()
    * ```
    */
  get accountMIHistory(): Prisma.AccountMIHistoryDelegate<ExtArgs>;

  /**
   * `prisma.accountMCHistory`: Exposes CRUD operations for the **AccountMCHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountMCHistories
    * const accountMCHistories = await prisma.accountMCHistory.findMany()
    * ```
    */
  get accountMCHistory(): Prisma.AccountMCHistoryDelegate<ExtArgs>;

  /**
   * `prisma.spendingSnapshot`: Exposes CRUD operations for the **SpendingSnapshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpendingSnapshots
    * const spendingSnapshots = await prisma.spendingSnapshot.findMany()
    * ```
    */
  get spendingSnapshot(): Prisma.SpendingSnapshotDelegate<ExtArgs>;

  /**
   * `prisma.spendingRecord`: Exposes CRUD operations for the **SpendingRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SpendingRecords
    * const spendingRecords = await prisma.spendingRecord.findMany()
    * ```
    */
  get spendingRecord(): Prisma.SpendingRecordDelegate<ExtArgs>;

  /**
   * `prisma.activityLog`: Exposes CRUD operations for the **ActivityLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ActivityLogs
    * const activityLogs = await prisma.activityLog.findMany()
    * ```
    */
  get activityLog(): Prisma.ActivityLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Partner: 'Partner',
    AccountBatch: 'AccountBatch',
    InvoiceMCC: 'InvoiceMCC',
    Customer: 'Customer',
    Account: 'Account',
    AccountMIHistory: 'AccountMIHistory',
    AccountMCHistory: 'AccountMCHistory',
    SpendingSnapshot: 'SpendingSnapshot',
    SpendingRecord: 'SpendingRecord',
    ActivityLog: 'ActivityLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "partner" | "accountBatch" | "invoiceMCC" | "customer" | "account" | "accountMIHistory" | "accountMCHistory" | "spendingSnapshot" | "spendingRecord" | "activityLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Partner: {
        payload: Prisma.$PartnerPayload<ExtArgs>
        fields: Prisma.PartnerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PartnerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PartnerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findFirst: {
            args: Prisma.PartnerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PartnerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          findMany: {
            args: Prisma.PartnerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          create: {
            args: Prisma.PartnerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          createMany: {
            args: Prisma.PartnerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PartnerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>[]
          }
          delete: {
            args: Prisma.PartnerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          update: {
            args: Prisma.PartnerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          deleteMany: {
            args: Prisma.PartnerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PartnerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PartnerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PartnerPayload>
          }
          aggregate: {
            args: Prisma.PartnerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePartner>
          }
          groupBy: {
            args: Prisma.PartnerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PartnerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PartnerCountArgs<ExtArgs>
            result: $Utils.Optional<PartnerCountAggregateOutputType> | number
          }
        }
      }
      AccountBatch: {
        payload: Prisma.$AccountBatchPayload<ExtArgs>
        fields: Prisma.AccountBatchFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountBatchFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountBatchFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload>
          }
          findFirst: {
            args: Prisma.AccountBatchFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountBatchFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload>
          }
          findMany: {
            args: Prisma.AccountBatchFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload>[]
          }
          create: {
            args: Prisma.AccountBatchCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload>
          }
          createMany: {
            args: Prisma.AccountBatchCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountBatchCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload>[]
          }
          delete: {
            args: Prisma.AccountBatchDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload>
          }
          update: {
            args: Prisma.AccountBatchUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload>
          }
          deleteMany: {
            args: Prisma.AccountBatchDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountBatchUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountBatchUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountBatchPayload>
          }
          aggregate: {
            args: Prisma.AccountBatchAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountBatch>
          }
          groupBy: {
            args: Prisma.AccountBatchGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountBatchGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountBatchCountArgs<ExtArgs>
            result: $Utils.Optional<AccountBatchCountAggregateOutputType> | number
          }
        }
      }
      InvoiceMCC: {
        payload: Prisma.$InvoiceMCCPayload<ExtArgs>
        fields: Prisma.InvoiceMCCFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceMCCFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceMCCFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload>
          }
          findFirst: {
            args: Prisma.InvoiceMCCFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceMCCFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload>
          }
          findMany: {
            args: Prisma.InvoiceMCCFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload>[]
          }
          create: {
            args: Prisma.InvoiceMCCCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload>
          }
          createMany: {
            args: Prisma.InvoiceMCCCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceMCCCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload>[]
          }
          delete: {
            args: Prisma.InvoiceMCCDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload>
          }
          update: {
            args: Prisma.InvoiceMCCUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload>
          }
          deleteMany: {
            args: Prisma.InvoiceMCCDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceMCCUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InvoiceMCCUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoiceMCCPayload>
          }
          aggregate: {
            args: Prisma.InvoiceMCCAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoiceMCC>
          }
          groupBy: {
            args: Prisma.InvoiceMCCGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceMCCGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceMCCCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceMCCCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      AccountMIHistory: {
        payload: Prisma.$AccountMIHistoryPayload<ExtArgs>
        fields: Prisma.AccountMIHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountMIHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountMIHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload>
          }
          findFirst: {
            args: Prisma.AccountMIHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountMIHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload>
          }
          findMany: {
            args: Prisma.AccountMIHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload>[]
          }
          create: {
            args: Prisma.AccountMIHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload>
          }
          createMany: {
            args: Prisma.AccountMIHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountMIHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload>[]
          }
          delete: {
            args: Prisma.AccountMIHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload>
          }
          update: {
            args: Prisma.AccountMIHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AccountMIHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountMIHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountMIHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMIHistoryPayload>
          }
          aggregate: {
            args: Prisma.AccountMIHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountMIHistory>
          }
          groupBy: {
            args: Prisma.AccountMIHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountMIHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountMIHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AccountMIHistoryCountAggregateOutputType> | number
          }
        }
      }
      AccountMCHistory: {
        payload: Prisma.$AccountMCHistoryPayload<ExtArgs>
        fields: Prisma.AccountMCHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountMCHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountMCHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload>
          }
          findFirst: {
            args: Prisma.AccountMCHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountMCHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload>
          }
          findMany: {
            args: Prisma.AccountMCHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload>[]
          }
          create: {
            args: Prisma.AccountMCHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload>
          }
          createMany: {
            args: Prisma.AccountMCHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountMCHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload>[]
          }
          delete: {
            args: Prisma.AccountMCHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload>
          }
          update: {
            args: Prisma.AccountMCHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload>
          }
          deleteMany: {
            args: Prisma.AccountMCHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountMCHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AccountMCHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountMCHistoryPayload>
          }
          aggregate: {
            args: Prisma.AccountMCHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountMCHistory>
          }
          groupBy: {
            args: Prisma.AccountMCHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountMCHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountMCHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<AccountMCHistoryCountAggregateOutputType> | number
          }
        }
      }
      SpendingSnapshot: {
        payload: Prisma.$SpendingSnapshotPayload<ExtArgs>
        fields: Prisma.SpendingSnapshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpendingSnapshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpendingSnapshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload>
          }
          findFirst: {
            args: Prisma.SpendingSnapshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpendingSnapshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload>
          }
          findMany: {
            args: Prisma.SpendingSnapshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload>[]
          }
          create: {
            args: Prisma.SpendingSnapshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload>
          }
          createMany: {
            args: Prisma.SpendingSnapshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpendingSnapshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload>[]
          }
          delete: {
            args: Prisma.SpendingSnapshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload>
          }
          update: {
            args: Prisma.SpendingSnapshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload>
          }
          deleteMany: {
            args: Prisma.SpendingSnapshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpendingSnapshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpendingSnapshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingSnapshotPayload>
          }
          aggregate: {
            args: Prisma.SpendingSnapshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpendingSnapshot>
          }
          groupBy: {
            args: Prisma.SpendingSnapshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpendingSnapshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpendingSnapshotCountArgs<ExtArgs>
            result: $Utils.Optional<SpendingSnapshotCountAggregateOutputType> | number
          }
        }
      }
      SpendingRecord: {
        payload: Prisma.$SpendingRecordPayload<ExtArgs>
        fields: Prisma.SpendingRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SpendingRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SpendingRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload>
          }
          findFirst: {
            args: Prisma.SpendingRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SpendingRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload>
          }
          findMany: {
            args: Prisma.SpendingRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload>[]
          }
          create: {
            args: Prisma.SpendingRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload>
          }
          createMany: {
            args: Prisma.SpendingRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SpendingRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload>[]
          }
          delete: {
            args: Prisma.SpendingRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload>
          }
          update: {
            args: Prisma.SpendingRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload>
          }
          deleteMany: {
            args: Prisma.SpendingRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SpendingRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SpendingRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SpendingRecordPayload>
          }
          aggregate: {
            args: Prisma.SpendingRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSpendingRecord>
          }
          groupBy: {
            args: Prisma.SpendingRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<SpendingRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.SpendingRecordCountArgs<ExtArgs>
            result: $Utils.Optional<SpendingRecordCountAggregateOutputType> | number
          }
        }
      }
      ActivityLog: {
        payload: Prisma.$ActivityLogPayload<ExtArgs>
        fields: Prisma.ActivityLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ActivityLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ActivityLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findFirst: {
            args: Prisma.ActivityLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ActivityLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          findMany: {
            args: Prisma.ActivityLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          create: {
            args: Prisma.ActivityLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          createMany: {
            args: Prisma.ActivityLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ActivityLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>[]
          }
          delete: {
            args: Prisma.ActivityLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          update: {
            args: Prisma.ActivityLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          deleteMany: {
            args: Prisma.ActivityLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ActivityLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ActivityLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ActivityLogPayload>
          }
          aggregate: {
            args: Prisma.ActivityLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateActivityLog>
          }
          groupBy: {
            args: Prisma.ActivityLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.ActivityLogCountArgs<ExtArgs>
            result: $Utils.Optional<ActivityLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    customersAssigned: number
    batchesCreated: number
    invoiceMCCsCreated: number
    miHistoriesLinked: number
    miHistoriesUnlinked: number
    mcHistoriesAssigned: number
    mcHistoriesUnassigned: number
    snapshots: number
    activityLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customersAssigned?: boolean | UserCountOutputTypeCountCustomersAssignedArgs
    batchesCreated?: boolean | UserCountOutputTypeCountBatchesCreatedArgs
    invoiceMCCsCreated?: boolean | UserCountOutputTypeCountInvoiceMCCsCreatedArgs
    miHistoriesLinked?: boolean | UserCountOutputTypeCountMiHistoriesLinkedArgs
    miHistoriesUnlinked?: boolean | UserCountOutputTypeCountMiHistoriesUnlinkedArgs
    mcHistoriesAssigned?: boolean | UserCountOutputTypeCountMcHistoriesAssignedArgs
    mcHistoriesUnassigned?: boolean | UserCountOutputTypeCountMcHistoriesUnassignedArgs
    snapshots?: boolean | UserCountOutputTypeCountSnapshotsArgs
    activityLogs?: boolean | UserCountOutputTypeCountActivityLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCustomersAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBatchesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBatchWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoiceMCCsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceMCCWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMiHistoriesLinkedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMIHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMiHistoriesUnlinkedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMIHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMcHistoriesAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMCHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMcHistoriesUnassignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMCHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingSnapshotWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountActivityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
  }


  /**
   * Count Type PartnerCountOutputType
   */

  export type PartnerCountOutputType = {
    batches: number
    invoiceMCCs: number
  }

  export type PartnerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | PartnerCountOutputTypeCountBatchesArgs
    invoiceMCCs?: boolean | PartnerCountOutputTypeCountInvoiceMCCsArgs
  }

  // Custom InputTypes
  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PartnerCountOutputType
     */
    select?: PartnerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountBatchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBatchWhereInput
  }

  /**
   * PartnerCountOutputType without action
   */
  export type PartnerCountOutputTypeCountInvoiceMCCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceMCCWhereInput
  }


  /**
   * Count Type AccountBatchCountOutputType
   */

  export type AccountBatchCountOutputType = {
    accounts: number
  }

  export type AccountBatchCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | AccountBatchCountOutputTypeCountAccountsArgs
  }

  // Custom InputTypes
  /**
   * AccountBatchCountOutputType without action
   */
  export type AccountBatchCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatchCountOutputType
     */
    select?: AccountBatchCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountBatchCountOutputType without action
   */
  export type AccountBatchCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }


  /**
   * Count Type InvoiceMCCCountOutputType
   */

  export type InvoiceMCCCountOutputType = {
    accounts: number
    miHistories: number
    snapshots: number
    spendingRecords: number
  }

  export type InvoiceMCCCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | InvoiceMCCCountOutputTypeCountAccountsArgs
    miHistories?: boolean | InvoiceMCCCountOutputTypeCountMiHistoriesArgs
    snapshots?: boolean | InvoiceMCCCountOutputTypeCountSnapshotsArgs
    spendingRecords?: boolean | InvoiceMCCCountOutputTypeCountSpendingRecordsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceMCCCountOutputType without action
   */
  export type InvoiceMCCCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCCCountOutputType
     */
    select?: InvoiceMCCCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceMCCCountOutputType without action
   */
  export type InvoiceMCCCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * InvoiceMCCCountOutputType without action
   */
  export type InvoiceMCCCountOutputTypeCountMiHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMIHistoryWhereInput
  }

  /**
   * InvoiceMCCCountOutputType without action
   */
  export type InvoiceMCCCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingSnapshotWhereInput
  }

  /**
   * InvoiceMCCCountOutputType without action
   */
  export type InvoiceMCCCountOutputTypeCountSpendingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingRecordWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    accounts: number
    mcHistories: number
    snapshots: number
    spendingRecords: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | CustomerCountOutputTypeCountAccountsArgs
    mcHistories?: boolean | CustomerCountOutputTypeCountMcHistoriesArgs
    snapshots?: boolean | CustomerCountOutputTypeCountSnapshotsArgs
    spendingRecords?: boolean | CustomerCountOutputTypeCountSpendingRecordsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountMcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMCHistoryWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingSnapshotWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountSpendingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingRecordWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    miHistories: number
    mcHistories: number
    snapshots: number
    spendingRecords: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    miHistories?: boolean | AccountCountOutputTypeCountMiHistoriesArgs
    mcHistories?: boolean | AccountCountOutputTypeCountMcHistoriesArgs
    snapshots?: boolean | AccountCountOutputTypeCountSnapshotsArgs
    spendingRecords?: boolean | AccountCountOutputTypeCountSpendingRecordsArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountMiHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMIHistoryWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountMcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMCHistoryWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSnapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingSnapshotWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSpendingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingRecordWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullName: number
    role: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    fullName: string
    role: $Enums.UserRole
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    customersAssigned?: boolean | User$customersAssignedArgs<ExtArgs>
    batchesCreated?: boolean | User$batchesCreatedArgs<ExtArgs>
    invoiceMCCsCreated?: boolean | User$invoiceMCCsCreatedArgs<ExtArgs>
    miHistoriesLinked?: boolean | User$miHistoriesLinkedArgs<ExtArgs>
    miHistoriesUnlinked?: boolean | User$miHistoriesUnlinkedArgs<ExtArgs>
    mcHistoriesAssigned?: boolean | User$mcHistoriesAssignedArgs<ExtArgs>
    mcHistoriesUnassigned?: boolean | User$mcHistoriesUnassignedArgs<ExtArgs>
    snapshots?: boolean | User$snapshotsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customersAssigned?: boolean | User$customersAssignedArgs<ExtArgs>
    batchesCreated?: boolean | User$batchesCreatedArgs<ExtArgs>
    invoiceMCCsCreated?: boolean | User$invoiceMCCsCreatedArgs<ExtArgs>
    miHistoriesLinked?: boolean | User$miHistoriesLinkedArgs<ExtArgs>
    miHistoriesUnlinked?: boolean | User$miHistoriesUnlinkedArgs<ExtArgs>
    mcHistoriesAssigned?: boolean | User$mcHistoriesAssignedArgs<ExtArgs>
    mcHistoriesUnassigned?: boolean | User$mcHistoriesUnassignedArgs<ExtArgs>
    snapshots?: boolean | User$snapshotsArgs<ExtArgs>
    activityLogs?: boolean | User$activityLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      customersAssigned: Prisma.$CustomerPayload<ExtArgs>[]
      batchesCreated: Prisma.$AccountBatchPayload<ExtArgs>[]
      invoiceMCCsCreated: Prisma.$InvoiceMCCPayload<ExtArgs>[]
      miHistoriesLinked: Prisma.$AccountMIHistoryPayload<ExtArgs>[]
      miHistoriesUnlinked: Prisma.$AccountMIHistoryPayload<ExtArgs>[]
      mcHistoriesAssigned: Prisma.$AccountMCHistoryPayload<ExtArgs>[]
      mcHistoriesUnassigned: Prisma.$AccountMCHistoryPayload<ExtArgs>[]
      snapshots: Prisma.$SpendingSnapshotPayload<ExtArgs>[]
      activityLogs: Prisma.$ActivityLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      fullName: string
      role: $Enums.UserRole
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customersAssigned<T extends User$customersAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$customersAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany"> | Null>
    batchesCreated<T extends User$batchesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$batchesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "findMany"> | Null>
    invoiceMCCsCreated<T extends User$invoiceMCCsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$invoiceMCCsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findMany"> | Null>
    miHistoriesLinked<T extends User$miHistoriesLinkedArgs<ExtArgs> = {}>(args?: Subset<T, User$miHistoriesLinkedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    miHistoriesUnlinked<T extends User$miHistoriesUnlinkedArgs<ExtArgs> = {}>(args?: Subset<T, User$miHistoriesUnlinkedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    mcHistoriesAssigned<T extends User$mcHistoriesAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$mcHistoriesAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    mcHistoriesUnassigned<T extends User$mcHistoriesUnassignedArgs<ExtArgs> = {}>(args?: Subset<T, User$mcHistoriesUnassignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    snapshots<T extends User$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, User$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findMany"> | Null>
    activityLogs<T extends User$activityLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$activityLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.customersAssigned
   */
  export type User$customersAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    cursor?: CustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * User.batchesCreated
   */
  export type User$batchesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    where?: AccountBatchWhereInput
    orderBy?: AccountBatchOrderByWithRelationInput | AccountBatchOrderByWithRelationInput[]
    cursor?: AccountBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBatchScalarFieldEnum | AccountBatchScalarFieldEnum[]
  }

  /**
   * User.invoiceMCCsCreated
   */
  export type User$invoiceMCCsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    where?: InvoiceMCCWhereInput
    orderBy?: InvoiceMCCOrderByWithRelationInput | InvoiceMCCOrderByWithRelationInput[]
    cursor?: InvoiceMCCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceMCCScalarFieldEnum | InvoiceMCCScalarFieldEnum[]
  }

  /**
   * User.miHistoriesLinked
   */
  export type User$miHistoriesLinkedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    where?: AccountMIHistoryWhereInput
    orderBy?: AccountMIHistoryOrderByWithRelationInput | AccountMIHistoryOrderByWithRelationInput[]
    cursor?: AccountMIHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountMIHistoryScalarFieldEnum | AccountMIHistoryScalarFieldEnum[]
  }

  /**
   * User.miHistoriesUnlinked
   */
  export type User$miHistoriesUnlinkedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    where?: AccountMIHistoryWhereInput
    orderBy?: AccountMIHistoryOrderByWithRelationInput | AccountMIHistoryOrderByWithRelationInput[]
    cursor?: AccountMIHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountMIHistoryScalarFieldEnum | AccountMIHistoryScalarFieldEnum[]
  }

  /**
   * User.mcHistoriesAssigned
   */
  export type User$mcHistoriesAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    where?: AccountMCHistoryWhereInput
    orderBy?: AccountMCHistoryOrderByWithRelationInput | AccountMCHistoryOrderByWithRelationInput[]
    cursor?: AccountMCHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountMCHistoryScalarFieldEnum | AccountMCHistoryScalarFieldEnum[]
  }

  /**
   * User.mcHistoriesUnassigned
   */
  export type User$mcHistoriesUnassignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    where?: AccountMCHistoryWhereInput
    orderBy?: AccountMCHistoryOrderByWithRelationInput | AccountMCHistoryOrderByWithRelationInput[]
    cursor?: AccountMCHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountMCHistoryScalarFieldEnum | AccountMCHistoryScalarFieldEnum[]
  }

  /**
   * User.snapshots
   */
  export type User$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    where?: SpendingSnapshotWhereInput
    orderBy?: SpendingSnapshotOrderByWithRelationInput | SpendingSnapshotOrderByWithRelationInput[]
    cursor?: SpendingSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendingSnapshotScalarFieldEnum | SpendingSnapshotScalarFieldEnum[]
  }

  /**
   * User.activityLogs
   */
  export type User$activityLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    cursor?: ActivityLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Partner
   */

  export type AggregatePartner = {
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  export type PartnerMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactInfo: string | null
    type: $Enums.PartnerType | null
    notes: string | null
    createdAt: Date | null
  }

  export type PartnerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactInfo: string | null
    type: $Enums.PartnerType | null
    notes: string | null
    createdAt: Date | null
  }

  export type PartnerCountAggregateOutputType = {
    id: number
    name: number
    contactInfo: number
    type: number
    notes: number
    createdAt: number
    _all: number
  }


  export type PartnerMinAggregateInputType = {
    id?: true
    name?: true
    contactInfo?: true
    type?: true
    notes?: true
    createdAt?: true
  }

  export type PartnerMaxAggregateInputType = {
    id?: true
    name?: true
    contactInfo?: true
    type?: true
    notes?: true
    createdAt?: true
  }

  export type PartnerCountAggregateInputType = {
    id?: true
    name?: true
    contactInfo?: true
    type?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type PartnerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partner to aggregate.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Partners
    **/
    _count?: true | PartnerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PartnerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PartnerMaxAggregateInputType
  }

  export type GetPartnerAggregateType<T extends PartnerAggregateArgs> = {
        [P in keyof T & keyof AggregatePartner]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePartner[P]>
      : GetScalarType<T[P], AggregatePartner[P]>
  }




  export type PartnerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PartnerWhereInput
    orderBy?: PartnerOrderByWithAggregationInput | PartnerOrderByWithAggregationInput[]
    by: PartnerScalarFieldEnum[] | PartnerScalarFieldEnum
    having?: PartnerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PartnerCountAggregateInputType | true
    _min?: PartnerMinAggregateInputType
    _max?: PartnerMaxAggregateInputType
  }

  export type PartnerGroupByOutputType = {
    id: string
    name: string
    contactInfo: string | null
    type: $Enums.PartnerType
    notes: string | null
    createdAt: Date
    _count: PartnerCountAggregateOutputType | null
    _min: PartnerMinAggregateOutputType | null
    _max: PartnerMaxAggregateOutputType | null
  }

  type GetPartnerGroupByPayload<T extends PartnerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PartnerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PartnerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PartnerGroupByOutputType[P]>
            : GetScalarType<T[P], PartnerGroupByOutputType[P]>
        }
      >
    >


  export type PartnerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactInfo?: boolean
    type?: boolean
    notes?: boolean
    createdAt?: boolean
    batches?: boolean | Partner$batchesArgs<ExtArgs>
    invoiceMCCs?: boolean | Partner$invoiceMCCsArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactInfo?: boolean
    type?: boolean
    notes?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["partner"]>

  export type PartnerSelectScalar = {
    id?: boolean
    name?: boolean
    contactInfo?: boolean
    type?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type PartnerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batches?: boolean | Partner$batchesArgs<ExtArgs>
    invoiceMCCs?: boolean | Partner$invoiceMCCsArgs<ExtArgs>
    _count?: boolean | PartnerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PartnerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PartnerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Partner"
    objects: {
      batches: Prisma.$AccountBatchPayload<ExtArgs>[]
      invoiceMCCs: Prisma.$InvoiceMCCPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactInfo: string | null
      type: $Enums.PartnerType
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["partner"]>
    composites: {}
  }

  type PartnerGetPayload<S extends boolean | null | undefined | PartnerDefaultArgs> = $Result.GetResult<Prisma.$PartnerPayload, S>

  type PartnerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PartnerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PartnerCountAggregateInputType | true
    }

  export interface PartnerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Partner'], meta: { name: 'Partner' } }
    /**
     * Find zero or one Partner that matches the filter.
     * @param {PartnerFindUniqueArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PartnerFindUniqueArgs>(args: SelectSubset<T, PartnerFindUniqueArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Partner that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PartnerFindUniqueOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PartnerFindUniqueOrThrowArgs>(args: SelectSubset<T, PartnerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Partner that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PartnerFindFirstArgs>(args?: SelectSubset<T, PartnerFindFirstArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Partner that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindFirstOrThrowArgs} args - Arguments to find a Partner
     * @example
     * // Get one Partner
     * const partner = await prisma.partner.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PartnerFindFirstOrThrowArgs>(args?: SelectSubset<T, PartnerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Partners that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Partners
     * const partners = await prisma.partner.findMany()
     * 
     * // Get first 10 Partners
     * const partners = await prisma.partner.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const partnerWithIdOnly = await prisma.partner.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PartnerFindManyArgs>(args?: SelectSubset<T, PartnerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Partner.
     * @param {PartnerCreateArgs} args - Arguments to create a Partner.
     * @example
     * // Create one Partner
     * const Partner = await prisma.partner.create({
     *   data: {
     *     // ... data to create a Partner
     *   }
     * })
     * 
     */
    create<T extends PartnerCreateArgs>(args: SelectSubset<T, PartnerCreateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Partners.
     * @param {PartnerCreateManyArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PartnerCreateManyArgs>(args?: SelectSubset<T, PartnerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Partners and returns the data saved in the database.
     * @param {PartnerCreateManyAndReturnArgs} args - Arguments to create many Partners.
     * @example
     * // Create many Partners
     * const partner = await prisma.partner.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Partners and only return the `id`
     * const partnerWithIdOnly = await prisma.partner.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PartnerCreateManyAndReturnArgs>(args?: SelectSubset<T, PartnerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Partner.
     * @param {PartnerDeleteArgs} args - Arguments to delete one Partner.
     * @example
     * // Delete one Partner
     * const Partner = await prisma.partner.delete({
     *   where: {
     *     // ... filter to delete one Partner
     *   }
     * })
     * 
     */
    delete<T extends PartnerDeleteArgs>(args: SelectSubset<T, PartnerDeleteArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Partner.
     * @param {PartnerUpdateArgs} args - Arguments to update one Partner.
     * @example
     * // Update one Partner
     * const partner = await prisma.partner.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PartnerUpdateArgs>(args: SelectSubset<T, PartnerUpdateArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Partners.
     * @param {PartnerDeleteManyArgs} args - Arguments to filter Partners to delete.
     * @example
     * // Delete a few Partners
     * const { count } = await prisma.partner.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PartnerDeleteManyArgs>(args?: SelectSubset<T, PartnerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Partners
     * const partner = await prisma.partner.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PartnerUpdateManyArgs>(args: SelectSubset<T, PartnerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Partner.
     * @param {PartnerUpsertArgs} args - Arguments to update or create a Partner.
     * @example
     * // Update or create a Partner
     * const partner = await prisma.partner.upsert({
     *   create: {
     *     // ... data to create a Partner
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Partner we want to update
     *   }
     * })
     */
    upsert<T extends PartnerUpsertArgs>(args: SelectSubset<T, PartnerUpsertArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Partners.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerCountArgs} args - Arguments to filter Partners to count.
     * @example
     * // Count the number of Partners
     * const count = await prisma.partner.count({
     *   where: {
     *     // ... the filter for the Partners we want to count
     *   }
     * })
    **/
    count<T extends PartnerCountArgs>(
      args?: Subset<T, PartnerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PartnerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PartnerAggregateArgs>(args: Subset<T, PartnerAggregateArgs>): Prisma.PrismaPromise<GetPartnerAggregateType<T>>

    /**
     * Group by Partner.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PartnerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PartnerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PartnerGroupByArgs['orderBy'] }
        : { orderBy?: PartnerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PartnerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPartnerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Partner model
   */
  readonly fields: PartnerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Partner.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PartnerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batches<T extends Partner$batchesArgs<ExtArgs> = {}>(args?: Subset<T, Partner$batchesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "findMany"> | Null>
    invoiceMCCs<T extends Partner$invoiceMCCsArgs<ExtArgs> = {}>(args?: Subset<T, Partner$invoiceMCCsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Partner model
   */ 
  interface PartnerFieldRefs {
    readonly id: FieldRef<"Partner", 'String'>
    readonly name: FieldRef<"Partner", 'String'>
    readonly contactInfo: FieldRef<"Partner", 'String'>
    readonly type: FieldRef<"Partner", 'PartnerType'>
    readonly notes: FieldRef<"Partner", 'String'>
    readonly createdAt: FieldRef<"Partner", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Partner findUnique
   */
  export type PartnerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findUniqueOrThrow
   */
  export type PartnerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner findFirst
   */
  export type PartnerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findFirstOrThrow
   */
  export type PartnerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partner to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Partners.
     */
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner findMany
   */
  export type PartnerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter, which Partners to fetch.
     */
    where?: PartnerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Partners to fetch.
     */
    orderBy?: PartnerOrderByWithRelationInput | PartnerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Partners.
     */
    cursor?: PartnerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Partners from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Partners.
     */
    skip?: number
    distinct?: PartnerScalarFieldEnum | PartnerScalarFieldEnum[]
  }

  /**
   * Partner create
   */
  export type PartnerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to create a Partner.
     */
    data: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
  }

  /**
   * Partner createMany
   */
  export type PartnerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner createManyAndReturn
   */
  export type PartnerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Partners.
     */
    data: PartnerCreateManyInput | PartnerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Partner update
   */
  export type PartnerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The data needed to update a Partner.
     */
    data: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
    /**
     * Choose, which Partner to update.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner updateMany
   */
  export type PartnerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Partners.
     */
    data: XOR<PartnerUpdateManyMutationInput, PartnerUncheckedUpdateManyInput>
    /**
     * Filter which Partners to update
     */
    where?: PartnerWhereInput
  }

  /**
   * Partner upsert
   */
  export type PartnerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * The filter to search for the Partner to update in case it exists.
     */
    where: PartnerWhereUniqueInput
    /**
     * In case the Partner found by the `where` argument doesn't exist, create a new Partner with this data.
     */
    create: XOR<PartnerCreateInput, PartnerUncheckedCreateInput>
    /**
     * In case the Partner was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PartnerUpdateInput, PartnerUncheckedUpdateInput>
  }

  /**
   * Partner delete
   */
  export type PartnerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    /**
     * Filter which Partner to delete.
     */
    where: PartnerWhereUniqueInput
  }

  /**
   * Partner deleteMany
   */
  export type PartnerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Partners to delete
     */
    where?: PartnerWhereInput
  }

  /**
   * Partner.batches
   */
  export type Partner$batchesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    where?: AccountBatchWhereInput
    orderBy?: AccountBatchOrderByWithRelationInput | AccountBatchOrderByWithRelationInput[]
    cursor?: AccountBatchWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountBatchScalarFieldEnum | AccountBatchScalarFieldEnum[]
  }

  /**
   * Partner.invoiceMCCs
   */
  export type Partner$invoiceMCCsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    where?: InvoiceMCCWhereInput
    orderBy?: InvoiceMCCOrderByWithRelationInput | InvoiceMCCOrderByWithRelationInput[]
    cursor?: InvoiceMCCWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceMCCScalarFieldEnum | InvoiceMCCScalarFieldEnum[]
  }

  /**
   * Partner without action
   */
  export type PartnerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
  }


  /**
   * Model AccountBatch
   */

  export type AggregateAccountBatch = {
    _count: AccountBatchCountAggregateOutputType | null
    _avg: AccountBatchAvgAggregateOutputType | null
    _sum: AccountBatchSumAggregateOutputType | null
    _min: AccountBatchMinAggregateOutputType | null
    _max: AccountBatchMaxAggregateOutputType | null
  }

  export type AccountBatchAvgAggregateOutputType = {
    totalAccounts: number | null
    liveAccounts: number | null
    year: number | null
    readiness: number | null
  }

  export type AccountBatchSumAggregateOutputType = {
    totalAccounts: number | null
    liveAccounts: number | null
    year: number | null
    readiness: number | null
  }

  export type AccountBatchMinAggregateOutputType = {
    id: string | null
    mccAccountName: string | null
    mccAccountId: string | null
    isPrelinked: boolean | null
    status: $Enums.BatchStatus | null
    totalAccounts: number | null
    liveAccounts: number | null
    timezone: string | null
    year: number | null
    readiness: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    partnerId: string | null
    createdById: string | null
  }

  export type AccountBatchMaxAggregateOutputType = {
    id: string | null
    mccAccountName: string | null
    mccAccountId: string | null
    isPrelinked: boolean | null
    status: $Enums.BatchStatus | null
    totalAccounts: number | null
    liveAccounts: number | null
    timezone: string | null
    year: number | null
    readiness: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    partnerId: string | null
    createdById: string | null
  }

  export type AccountBatchCountAggregateOutputType = {
    id: number
    mccAccountName: number
    mccAccountId: number
    isPrelinked: number
    status: number
    totalAccounts: number
    liveAccounts: number
    timezone: number
    year: number
    readiness: number
    notes: number
    createdAt: number
    updatedAt: number
    partnerId: number
    createdById: number
    _all: number
  }


  export type AccountBatchAvgAggregateInputType = {
    totalAccounts?: true
    liveAccounts?: true
    year?: true
    readiness?: true
  }

  export type AccountBatchSumAggregateInputType = {
    totalAccounts?: true
    liveAccounts?: true
    year?: true
    readiness?: true
  }

  export type AccountBatchMinAggregateInputType = {
    id?: true
    mccAccountName?: true
    mccAccountId?: true
    isPrelinked?: true
    status?: true
    totalAccounts?: true
    liveAccounts?: true
    timezone?: true
    year?: true
    readiness?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    partnerId?: true
    createdById?: true
  }

  export type AccountBatchMaxAggregateInputType = {
    id?: true
    mccAccountName?: true
    mccAccountId?: true
    isPrelinked?: true
    status?: true
    totalAccounts?: true
    liveAccounts?: true
    timezone?: true
    year?: true
    readiness?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    partnerId?: true
    createdById?: true
  }

  export type AccountBatchCountAggregateInputType = {
    id?: true
    mccAccountName?: true
    mccAccountId?: true
    isPrelinked?: true
    status?: true
    totalAccounts?: true
    liveAccounts?: true
    timezone?: true
    year?: true
    readiness?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    partnerId?: true
    createdById?: true
    _all?: true
  }

  export type AccountBatchAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountBatch to aggregate.
     */
    where?: AccountBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBatches to fetch.
     */
    orderBy?: AccountBatchOrderByWithRelationInput | AccountBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountBatches
    **/
    _count?: true | AccountBatchCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountBatchAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountBatchSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountBatchMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountBatchMaxAggregateInputType
  }

  export type GetAccountBatchAggregateType<T extends AccountBatchAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountBatch]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountBatch[P]>
      : GetScalarType<T[P], AggregateAccountBatch[P]>
  }




  export type AccountBatchGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountBatchWhereInput
    orderBy?: AccountBatchOrderByWithAggregationInput | AccountBatchOrderByWithAggregationInput[]
    by: AccountBatchScalarFieldEnum[] | AccountBatchScalarFieldEnum
    having?: AccountBatchScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountBatchCountAggregateInputType | true
    _avg?: AccountBatchAvgAggregateInputType
    _sum?: AccountBatchSumAggregateInputType
    _min?: AccountBatchMinAggregateInputType
    _max?: AccountBatchMaxAggregateInputType
  }

  export type AccountBatchGroupByOutputType = {
    id: string
    mccAccountName: string | null
    mccAccountId: string | null
    isPrelinked: boolean
    status: $Enums.BatchStatus
    totalAccounts: number
    liveAccounts: number
    timezone: string | null
    year: number | null
    readiness: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    partnerId: string | null
    createdById: string
    _count: AccountBatchCountAggregateOutputType | null
    _avg: AccountBatchAvgAggregateOutputType | null
    _sum: AccountBatchSumAggregateOutputType | null
    _min: AccountBatchMinAggregateOutputType | null
    _max: AccountBatchMaxAggregateOutputType | null
  }

  type GetAccountBatchGroupByPayload<T extends AccountBatchGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountBatchGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountBatchGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountBatchGroupByOutputType[P]>
            : GetScalarType<T[P], AccountBatchGroupByOutputType[P]>
        }
      >
    >


  export type AccountBatchSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mccAccountName?: boolean
    mccAccountId?: boolean
    isPrelinked?: boolean
    status?: boolean
    totalAccounts?: boolean
    liveAccounts?: boolean
    timezone?: boolean
    year?: boolean
    readiness?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partnerId?: boolean
    createdById?: boolean
    partner?: boolean | AccountBatch$partnerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    accounts?: boolean | AccountBatch$accountsArgs<ExtArgs>
    _count?: boolean | AccountBatchCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountBatch"]>

  export type AccountBatchSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    mccAccountName?: boolean
    mccAccountId?: boolean
    isPrelinked?: boolean
    status?: boolean
    totalAccounts?: boolean
    liveAccounts?: boolean
    timezone?: boolean
    year?: boolean
    readiness?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partnerId?: boolean
    createdById?: boolean
    partner?: boolean | AccountBatch$partnerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountBatch"]>

  export type AccountBatchSelectScalar = {
    id?: boolean
    mccAccountName?: boolean
    mccAccountId?: boolean
    isPrelinked?: boolean
    status?: boolean
    totalAccounts?: boolean
    liveAccounts?: boolean
    timezone?: boolean
    year?: boolean
    readiness?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partnerId?: boolean
    createdById?: boolean
  }

  export type AccountBatchInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | AccountBatch$partnerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    accounts?: boolean | AccountBatch$accountsArgs<ExtArgs>
    _count?: boolean | AccountBatchCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountBatchIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | AccountBatch$partnerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountBatchPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountBatch"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      accounts: Prisma.$AccountPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      mccAccountName: string | null
      mccAccountId: string | null
      isPrelinked: boolean
      status: $Enums.BatchStatus
      totalAccounts: number
      liveAccounts: number
      timezone: string | null
      year: number | null
      readiness: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
      partnerId: string | null
      createdById: string
    }, ExtArgs["result"]["accountBatch"]>
    composites: {}
  }

  type AccountBatchGetPayload<S extends boolean | null | undefined | AccountBatchDefaultArgs> = $Result.GetResult<Prisma.$AccountBatchPayload, S>

  type AccountBatchCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountBatchFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountBatchCountAggregateInputType | true
    }

  export interface AccountBatchDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountBatch'], meta: { name: 'AccountBatch' } }
    /**
     * Find zero or one AccountBatch that matches the filter.
     * @param {AccountBatchFindUniqueArgs} args - Arguments to find a AccountBatch
     * @example
     * // Get one AccountBatch
     * const accountBatch = await prisma.accountBatch.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountBatchFindUniqueArgs>(args: SelectSubset<T, AccountBatchFindUniqueArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccountBatch that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountBatchFindUniqueOrThrowArgs} args - Arguments to find a AccountBatch
     * @example
     * // Get one AccountBatch
     * const accountBatch = await prisma.accountBatch.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountBatchFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountBatchFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccountBatch that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBatchFindFirstArgs} args - Arguments to find a AccountBatch
     * @example
     * // Get one AccountBatch
     * const accountBatch = await prisma.accountBatch.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountBatchFindFirstArgs>(args?: SelectSubset<T, AccountBatchFindFirstArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccountBatch that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBatchFindFirstOrThrowArgs} args - Arguments to find a AccountBatch
     * @example
     * // Get one AccountBatch
     * const accountBatch = await prisma.accountBatch.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountBatchFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountBatchFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccountBatches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBatchFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountBatches
     * const accountBatches = await prisma.accountBatch.findMany()
     * 
     * // Get first 10 AccountBatches
     * const accountBatches = await prisma.accountBatch.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountBatchWithIdOnly = await prisma.accountBatch.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountBatchFindManyArgs>(args?: SelectSubset<T, AccountBatchFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccountBatch.
     * @param {AccountBatchCreateArgs} args - Arguments to create a AccountBatch.
     * @example
     * // Create one AccountBatch
     * const AccountBatch = await prisma.accountBatch.create({
     *   data: {
     *     // ... data to create a AccountBatch
     *   }
     * })
     * 
     */
    create<T extends AccountBatchCreateArgs>(args: SelectSubset<T, AccountBatchCreateArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccountBatches.
     * @param {AccountBatchCreateManyArgs} args - Arguments to create many AccountBatches.
     * @example
     * // Create many AccountBatches
     * const accountBatch = await prisma.accountBatch.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountBatchCreateManyArgs>(args?: SelectSubset<T, AccountBatchCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountBatches and returns the data saved in the database.
     * @param {AccountBatchCreateManyAndReturnArgs} args - Arguments to create many AccountBatches.
     * @example
     * // Create many AccountBatches
     * const accountBatch = await prisma.accountBatch.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountBatches and only return the `id`
     * const accountBatchWithIdOnly = await prisma.accountBatch.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountBatchCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountBatchCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccountBatch.
     * @param {AccountBatchDeleteArgs} args - Arguments to delete one AccountBatch.
     * @example
     * // Delete one AccountBatch
     * const AccountBatch = await prisma.accountBatch.delete({
     *   where: {
     *     // ... filter to delete one AccountBatch
     *   }
     * })
     * 
     */
    delete<T extends AccountBatchDeleteArgs>(args: SelectSubset<T, AccountBatchDeleteArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccountBatch.
     * @param {AccountBatchUpdateArgs} args - Arguments to update one AccountBatch.
     * @example
     * // Update one AccountBatch
     * const accountBatch = await prisma.accountBatch.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountBatchUpdateArgs>(args: SelectSubset<T, AccountBatchUpdateArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccountBatches.
     * @param {AccountBatchDeleteManyArgs} args - Arguments to filter AccountBatches to delete.
     * @example
     * // Delete a few AccountBatches
     * const { count } = await prisma.accountBatch.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountBatchDeleteManyArgs>(args?: SelectSubset<T, AccountBatchDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBatchUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountBatches
     * const accountBatch = await prisma.accountBatch.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountBatchUpdateManyArgs>(args: SelectSubset<T, AccountBatchUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountBatch.
     * @param {AccountBatchUpsertArgs} args - Arguments to update or create a AccountBatch.
     * @example
     * // Update or create a AccountBatch
     * const accountBatch = await prisma.accountBatch.upsert({
     *   create: {
     *     // ... data to create a AccountBatch
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountBatch we want to update
     *   }
     * })
     */
    upsert<T extends AccountBatchUpsertArgs>(args: SelectSubset<T, AccountBatchUpsertArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccountBatches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBatchCountArgs} args - Arguments to filter AccountBatches to count.
     * @example
     * // Count the number of AccountBatches
     * const count = await prisma.accountBatch.count({
     *   where: {
     *     // ... the filter for the AccountBatches we want to count
     *   }
     * })
    **/
    count<T extends AccountBatchCountArgs>(
      args?: Subset<T, AccountBatchCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountBatchCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBatchAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountBatchAggregateArgs>(args: Subset<T, AccountBatchAggregateArgs>): Prisma.PrismaPromise<GetAccountBatchAggregateType<T>>

    /**
     * Group by AccountBatch.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountBatchGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountBatchGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountBatchGroupByArgs['orderBy'] }
        : { orderBy?: AccountBatchGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountBatchGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountBatchGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountBatch model
   */
  readonly fields: AccountBatchFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountBatch.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountBatchClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends AccountBatch$partnerArgs<ExtArgs> = {}>(args?: Subset<T, AccountBatch$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    accounts<T extends AccountBatch$accountsArgs<ExtArgs> = {}>(args?: Subset<T, AccountBatch$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountBatch model
   */ 
  interface AccountBatchFieldRefs {
    readonly id: FieldRef<"AccountBatch", 'String'>
    readonly mccAccountName: FieldRef<"AccountBatch", 'String'>
    readonly mccAccountId: FieldRef<"AccountBatch", 'String'>
    readonly isPrelinked: FieldRef<"AccountBatch", 'Boolean'>
    readonly status: FieldRef<"AccountBatch", 'BatchStatus'>
    readonly totalAccounts: FieldRef<"AccountBatch", 'Int'>
    readonly liveAccounts: FieldRef<"AccountBatch", 'Int'>
    readonly timezone: FieldRef<"AccountBatch", 'String'>
    readonly year: FieldRef<"AccountBatch", 'Int'>
    readonly readiness: FieldRef<"AccountBatch", 'Int'>
    readonly notes: FieldRef<"AccountBatch", 'String'>
    readonly createdAt: FieldRef<"AccountBatch", 'DateTime'>
    readonly updatedAt: FieldRef<"AccountBatch", 'DateTime'>
    readonly partnerId: FieldRef<"AccountBatch", 'String'>
    readonly createdById: FieldRef<"AccountBatch", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccountBatch findUnique
   */
  export type AccountBatchFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * Filter, which AccountBatch to fetch.
     */
    where: AccountBatchWhereUniqueInput
  }

  /**
   * AccountBatch findUniqueOrThrow
   */
  export type AccountBatchFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * Filter, which AccountBatch to fetch.
     */
    where: AccountBatchWhereUniqueInput
  }

  /**
   * AccountBatch findFirst
   */
  export type AccountBatchFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * Filter, which AccountBatch to fetch.
     */
    where?: AccountBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBatches to fetch.
     */
    orderBy?: AccountBatchOrderByWithRelationInput | AccountBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountBatches.
     */
    cursor?: AccountBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountBatches.
     */
    distinct?: AccountBatchScalarFieldEnum | AccountBatchScalarFieldEnum[]
  }

  /**
   * AccountBatch findFirstOrThrow
   */
  export type AccountBatchFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * Filter, which AccountBatch to fetch.
     */
    where?: AccountBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBatches to fetch.
     */
    orderBy?: AccountBatchOrderByWithRelationInput | AccountBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountBatches.
     */
    cursor?: AccountBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBatches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountBatches.
     */
    distinct?: AccountBatchScalarFieldEnum | AccountBatchScalarFieldEnum[]
  }

  /**
   * AccountBatch findMany
   */
  export type AccountBatchFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * Filter, which AccountBatches to fetch.
     */
    where?: AccountBatchWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountBatches to fetch.
     */
    orderBy?: AccountBatchOrderByWithRelationInput | AccountBatchOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountBatches.
     */
    cursor?: AccountBatchWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountBatches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountBatches.
     */
    skip?: number
    distinct?: AccountBatchScalarFieldEnum | AccountBatchScalarFieldEnum[]
  }

  /**
   * AccountBatch create
   */
  export type AccountBatchCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountBatch.
     */
    data: XOR<AccountBatchCreateInput, AccountBatchUncheckedCreateInput>
  }

  /**
   * AccountBatch createMany
   */
  export type AccountBatchCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountBatches.
     */
    data: AccountBatchCreateManyInput | AccountBatchCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountBatch createManyAndReturn
   */
  export type AccountBatchCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccountBatches.
     */
    data: AccountBatchCreateManyInput | AccountBatchCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountBatch update
   */
  export type AccountBatchUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountBatch.
     */
    data: XOR<AccountBatchUpdateInput, AccountBatchUncheckedUpdateInput>
    /**
     * Choose, which AccountBatch to update.
     */
    where: AccountBatchWhereUniqueInput
  }

  /**
   * AccountBatch updateMany
   */
  export type AccountBatchUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountBatches.
     */
    data: XOR<AccountBatchUpdateManyMutationInput, AccountBatchUncheckedUpdateManyInput>
    /**
     * Filter which AccountBatches to update
     */
    where?: AccountBatchWhereInput
  }

  /**
   * AccountBatch upsert
   */
  export type AccountBatchUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountBatch to update in case it exists.
     */
    where: AccountBatchWhereUniqueInput
    /**
     * In case the AccountBatch found by the `where` argument doesn't exist, create a new AccountBatch with this data.
     */
    create: XOR<AccountBatchCreateInput, AccountBatchUncheckedCreateInput>
    /**
     * In case the AccountBatch was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountBatchUpdateInput, AccountBatchUncheckedUpdateInput>
  }

  /**
   * AccountBatch delete
   */
  export type AccountBatchDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
    /**
     * Filter which AccountBatch to delete.
     */
    where: AccountBatchWhereUniqueInput
  }

  /**
   * AccountBatch deleteMany
   */
  export type AccountBatchDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountBatches to delete
     */
    where?: AccountBatchWhereInput
  }

  /**
   * AccountBatch.partner
   */
  export type AccountBatch$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * AccountBatch.accounts
   */
  export type AccountBatch$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * AccountBatch without action
   */
  export type AccountBatchDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountBatch
     */
    select?: AccountBatchSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountBatchInclude<ExtArgs> | null
  }


  /**
   * Model InvoiceMCC
   */

  export type AggregateInvoiceMCC = {
    _count: InvoiceMCCCountAggregateOutputType | null
    _avg: InvoiceMCCAvgAggregateOutputType | null
    _sum: InvoiceMCCSumAggregateOutputType | null
    _min: InvoiceMCCMinAggregateOutputType | null
    _max: InvoiceMCCMaxAggregateOutputType | null
  }

  export type InvoiceMCCAvgAggregateOutputType = {
    linkedAccountsCount: number | null
    activeAccountsCount: number | null
  }

  export type InvoiceMCCSumAggregateOutputType = {
    linkedAccountsCount: number | null
    activeAccountsCount: number | null
  }

  export type InvoiceMCCMinAggregateOutputType = {
    id: string | null
    name: string | null
    mccInvoiceId: string | null
    status: $Enums.InvoiceMCCStatus | null
    creditStatus: $Enums.CreditStatus | null
    linkedAccountsCount: number | null
    activeAccountsCount: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    partnerId: string | null
    createdById: string | null
  }

  export type InvoiceMCCMaxAggregateOutputType = {
    id: string | null
    name: string | null
    mccInvoiceId: string | null
    status: $Enums.InvoiceMCCStatus | null
    creditStatus: $Enums.CreditStatus | null
    linkedAccountsCount: number | null
    activeAccountsCount: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    partnerId: string | null
    createdById: string | null
  }

  export type InvoiceMCCCountAggregateOutputType = {
    id: number
    name: number
    mccInvoiceId: number
    status: number
    creditStatus: number
    linkedAccountsCount: number
    activeAccountsCount: number
    notes: number
    createdAt: number
    updatedAt: number
    partnerId: number
    createdById: number
    _all: number
  }


  export type InvoiceMCCAvgAggregateInputType = {
    linkedAccountsCount?: true
    activeAccountsCount?: true
  }

  export type InvoiceMCCSumAggregateInputType = {
    linkedAccountsCount?: true
    activeAccountsCount?: true
  }

  export type InvoiceMCCMinAggregateInputType = {
    id?: true
    name?: true
    mccInvoiceId?: true
    status?: true
    creditStatus?: true
    linkedAccountsCount?: true
    activeAccountsCount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    partnerId?: true
    createdById?: true
  }

  export type InvoiceMCCMaxAggregateInputType = {
    id?: true
    name?: true
    mccInvoiceId?: true
    status?: true
    creditStatus?: true
    linkedAccountsCount?: true
    activeAccountsCount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    partnerId?: true
    createdById?: true
  }

  export type InvoiceMCCCountAggregateInputType = {
    id?: true
    name?: true
    mccInvoiceId?: true
    status?: true
    creditStatus?: true
    linkedAccountsCount?: true
    activeAccountsCount?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    partnerId?: true
    createdById?: true
    _all?: true
  }

  export type InvoiceMCCAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceMCC to aggregate.
     */
    where?: InvoiceMCCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceMCCS to fetch.
     */
    orderBy?: InvoiceMCCOrderByWithRelationInput | InvoiceMCCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceMCCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceMCCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceMCCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InvoiceMCCS
    **/
    _count?: true | InvoiceMCCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceMCCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceMCCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMCCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMCCMaxAggregateInputType
  }

  export type GetInvoiceMCCAggregateType<T extends InvoiceMCCAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoiceMCC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoiceMCC[P]>
      : GetScalarType<T[P], AggregateInvoiceMCC[P]>
  }




  export type InvoiceMCCGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceMCCWhereInput
    orderBy?: InvoiceMCCOrderByWithAggregationInput | InvoiceMCCOrderByWithAggregationInput[]
    by: InvoiceMCCScalarFieldEnum[] | InvoiceMCCScalarFieldEnum
    having?: InvoiceMCCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceMCCCountAggregateInputType | true
    _avg?: InvoiceMCCAvgAggregateInputType
    _sum?: InvoiceMCCSumAggregateInputType
    _min?: InvoiceMCCMinAggregateInputType
    _max?: InvoiceMCCMaxAggregateInputType
  }

  export type InvoiceMCCGroupByOutputType = {
    id: string
    name: string
    mccInvoiceId: string
    status: $Enums.InvoiceMCCStatus
    creditStatus: $Enums.CreditStatus
    linkedAccountsCount: number
    activeAccountsCount: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    partnerId: string | null
    createdById: string
    _count: InvoiceMCCCountAggregateOutputType | null
    _avg: InvoiceMCCAvgAggregateOutputType | null
    _sum: InvoiceMCCSumAggregateOutputType | null
    _min: InvoiceMCCMinAggregateOutputType | null
    _max: InvoiceMCCMaxAggregateOutputType | null
  }

  type GetInvoiceMCCGroupByPayload<T extends InvoiceMCCGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceMCCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceMCCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceMCCGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceMCCGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceMCCSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mccInvoiceId?: boolean
    status?: boolean
    creditStatus?: boolean
    linkedAccountsCount?: boolean
    activeAccountsCount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partnerId?: boolean
    createdById?: boolean
    partner?: boolean | InvoiceMCC$partnerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    accounts?: boolean | InvoiceMCC$accountsArgs<ExtArgs>
    miHistories?: boolean | InvoiceMCC$miHistoriesArgs<ExtArgs>
    snapshots?: boolean | InvoiceMCC$snapshotsArgs<ExtArgs>
    spendingRecords?: boolean | InvoiceMCC$spendingRecordsArgs<ExtArgs>
    _count?: boolean | InvoiceMCCCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceMCC"]>

  export type InvoiceMCCSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    mccInvoiceId?: boolean
    status?: boolean
    creditStatus?: boolean
    linkedAccountsCount?: boolean
    activeAccountsCount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partnerId?: boolean
    createdById?: boolean
    partner?: boolean | InvoiceMCC$partnerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoiceMCC"]>

  export type InvoiceMCCSelectScalar = {
    id?: boolean
    name?: boolean
    mccInvoiceId?: boolean
    status?: boolean
    creditStatus?: boolean
    linkedAccountsCount?: boolean
    activeAccountsCount?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    partnerId?: boolean
    createdById?: boolean
  }

  export type InvoiceMCCInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | InvoiceMCC$partnerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
    accounts?: boolean | InvoiceMCC$accountsArgs<ExtArgs>
    miHistories?: boolean | InvoiceMCC$miHistoriesArgs<ExtArgs>
    snapshots?: boolean | InvoiceMCC$snapshotsArgs<ExtArgs>
    spendingRecords?: boolean | InvoiceMCC$spendingRecordsArgs<ExtArgs>
    _count?: boolean | InvoiceMCCCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceMCCIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    partner?: boolean | InvoiceMCC$partnerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoiceMCCPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InvoiceMCC"
    objects: {
      partner: Prisma.$PartnerPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      miHistories: Prisma.$AccountMIHistoryPayload<ExtArgs>[]
      snapshots: Prisma.$SpendingSnapshotPayload<ExtArgs>[]
      spendingRecords: Prisma.$SpendingRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      mccInvoiceId: string
      status: $Enums.InvoiceMCCStatus
      creditStatus: $Enums.CreditStatus
      linkedAccountsCount: number
      activeAccountsCount: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
      partnerId: string | null
      createdById: string
    }, ExtArgs["result"]["invoiceMCC"]>
    composites: {}
  }

  type InvoiceMCCGetPayload<S extends boolean | null | undefined | InvoiceMCCDefaultArgs> = $Result.GetResult<Prisma.$InvoiceMCCPayload, S>

  type InvoiceMCCCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InvoiceMCCFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InvoiceMCCCountAggregateInputType | true
    }

  export interface InvoiceMCCDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InvoiceMCC'], meta: { name: 'InvoiceMCC' } }
    /**
     * Find zero or one InvoiceMCC that matches the filter.
     * @param {InvoiceMCCFindUniqueArgs} args - Arguments to find a InvoiceMCC
     * @example
     * // Get one InvoiceMCC
     * const invoiceMCC = await prisma.invoiceMCC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceMCCFindUniqueArgs>(args: SelectSubset<T, InvoiceMCCFindUniqueArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InvoiceMCC that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InvoiceMCCFindUniqueOrThrowArgs} args - Arguments to find a InvoiceMCC
     * @example
     * // Get one InvoiceMCC
     * const invoiceMCC = await prisma.invoiceMCC.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceMCCFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceMCCFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InvoiceMCC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMCCFindFirstArgs} args - Arguments to find a InvoiceMCC
     * @example
     * // Get one InvoiceMCC
     * const invoiceMCC = await prisma.invoiceMCC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceMCCFindFirstArgs>(args?: SelectSubset<T, InvoiceMCCFindFirstArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InvoiceMCC that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMCCFindFirstOrThrowArgs} args - Arguments to find a InvoiceMCC
     * @example
     * // Get one InvoiceMCC
     * const invoiceMCC = await prisma.invoiceMCC.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceMCCFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceMCCFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InvoiceMCCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMCCFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InvoiceMCCS
     * const invoiceMCCS = await prisma.invoiceMCC.findMany()
     * 
     * // Get first 10 InvoiceMCCS
     * const invoiceMCCS = await prisma.invoiceMCC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceMCCWithIdOnly = await prisma.invoiceMCC.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceMCCFindManyArgs>(args?: SelectSubset<T, InvoiceMCCFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InvoiceMCC.
     * @param {InvoiceMCCCreateArgs} args - Arguments to create a InvoiceMCC.
     * @example
     * // Create one InvoiceMCC
     * const InvoiceMCC = await prisma.invoiceMCC.create({
     *   data: {
     *     // ... data to create a InvoiceMCC
     *   }
     * })
     * 
     */
    create<T extends InvoiceMCCCreateArgs>(args: SelectSubset<T, InvoiceMCCCreateArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InvoiceMCCS.
     * @param {InvoiceMCCCreateManyArgs} args - Arguments to create many InvoiceMCCS.
     * @example
     * // Create many InvoiceMCCS
     * const invoiceMCC = await prisma.invoiceMCC.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceMCCCreateManyArgs>(args?: SelectSubset<T, InvoiceMCCCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InvoiceMCCS and returns the data saved in the database.
     * @param {InvoiceMCCCreateManyAndReturnArgs} args - Arguments to create many InvoiceMCCS.
     * @example
     * // Create many InvoiceMCCS
     * const invoiceMCC = await prisma.invoiceMCC.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InvoiceMCCS and only return the `id`
     * const invoiceMCCWithIdOnly = await prisma.invoiceMCC.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceMCCCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceMCCCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InvoiceMCC.
     * @param {InvoiceMCCDeleteArgs} args - Arguments to delete one InvoiceMCC.
     * @example
     * // Delete one InvoiceMCC
     * const InvoiceMCC = await prisma.invoiceMCC.delete({
     *   where: {
     *     // ... filter to delete one InvoiceMCC
     *   }
     * })
     * 
     */
    delete<T extends InvoiceMCCDeleteArgs>(args: SelectSubset<T, InvoiceMCCDeleteArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InvoiceMCC.
     * @param {InvoiceMCCUpdateArgs} args - Arguments to update one InvoiceMCC.
     * @example
     * // Update one InvoiceMCC
     * const invoiceMCC = await prisma.invoiceMCC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceMCCUpdateArgs>(args: SelectSubset<T, InvoiceMCCUpdateArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InvoiceMCCS.
     * @param {InvoiceMCCDeleteManyArgs} args - Arguments to filter InvoiceMCCS to delete.
     * @example
     * // Delete a few InvoiceMCCS
     * const { count } = await prisma.invoiceMCC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceMCCDeleteManyArgs>(args?: SelectSubset<T, InvoiceMCCDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InvoiceMCCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMCCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InvoiceMCCS
     * const invoiceMCC = await prisma.invoiceMCC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceMCCUpdateManyArgs>(args: SelectSubset<T, InvoiceMCCUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InvoiceMCC.
     * @param {InvoiceMCCUpsertArgs} args - Arguments to update or create a InvoiceMCC.
     * @example
     * // Update or create a InvoiceMCC
     * const invoiceMCC = await prisma.invoiceMCC.upsert({
     *   create: {
     *     // ... data to create a InvoiceMCC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InvoiceMCC we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceMCCUpsertArgs>(args: SelectSubset<T, InvoiceMCCUpsertArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InvoiceMCCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMCCCountArgs} args - Arguments to filter InvoiceMCCS to count.
     * @example
     * // Count the number of InvoiceMCCS
     * const count = await prisma.invoiceMCC.count({
     *   where: {
     *     // ... the filter for the InvoiceMCCS we want to count
     *   }
     * })
    **/
    count<T extends InvoiceMCCCountArgs>(
      args?: Subset<T, InvoiceMCCCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceMCCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InvoiceMCC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMCCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceMCCAggregateArgs>(args: Subset<T, InvoiceMCCAggregateArgs>): Prisma.PrismaPromise<GetInvoiceMCCAggregateType<T>>

    /**
     * Group by InvoiceMCC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceMCCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceMCCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceMCCGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceMCCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceMCCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceMCCGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InvoiceMCC model
   */
  readonly fields: InvoiceMCCFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InvoiceMCC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceMCCClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    partner<T extends InvoiceMCC$partnerArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceMCC$partnerArgs<ExtArgs>>): Prisma__PartnerClient<$Result.GetResult<Prisma.$PartnerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    accounts<T extends InvoiceMCC$accountsArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceMCC$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    miHistories<T extends InvoiceMCC$miHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceMCC$miHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    snapshots<T extends InvoiceMCC$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceMCC$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findMany"> | Null>
    spendingRecords<T extends InvoiceMCC$spendingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceMCC$spendingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InvoiceMCC model
   */ 
  interface InvoiceMCCFieldRefs {
    readonly id: FieldRef<"InvoiceMCC", 'String'>
    readonly name: FieldRef<"InvoiceMCC", 'String'>
    readonly mccInvoiceId: FieldRef<"InvoiceMCC", 'String'>
    readonly status: FieldRef<"InvoiceMCC", 'InvoiceMCCStatus'>
    readonly creditStatus: FieldRef<"InvoiceMCC", 'CreditStatus'>
    readonly linkedAccountsCount: FieldRef<"InvoiceMCC", 'Int'>
    readonly activeAccountsCount: FieldRef<"InvoiceMCC", 'Int'>
    readonly notes: FieldRef<"InvoiceMCC", 'String'>
    readonly createdAt: FieldRef<"InvoiceMCC", 'DateTime'>
    readonly updatedAt: FieldRef<"InvoiceMCC", 'DateTime'>
    readonly partnerId: FieldRef<"InvoiceMCC", 'String'>
    readonly createdById: FieldRef<"InvoiceMCC", 'String'>
  }
    

  // Custom InputTypes
  /**
   * InvoiceMCC findUnique
   */
  export type InvoiceMCCFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceMCC to fetch.
     */
    where: InvoiceMCCWhereUniqueInput
  }

  /**
   * InvoiceMCC findUniqueOrThrow
   */
  export type InvoiceMCCFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceMCC to fetch.
     */
    where: InvoiceMCCWhereUniqueInput
  }

  /**
   * InvoiceMCC findFirst
   */
  export type InvoiceMCCFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceMCC to fetch.
     */
    where?: InvoiceMCCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceMCCS to fetch.
     */
    orderBy?: InvoiceMCCOrderByWithRelationInput | InvoiceMCCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceMCCS.
     */
    cursor?: InvoiceMCCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceMCCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceMCCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceMCCS.
     */
    distinct?: InvoiceMCCScalarFieldEnum | InvoiceMCCScalarFieldEnum[]
  }

  /**
   * InvoiceMCC findFirstOrThrow
   */
  export type InvoiceMCCFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceMCC to fetch.
     */
    where?: InvoiceMCCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceMCCS to fetch.
     */
    orderBy?: InvoiceMCCOrderByWithRelationInput | InvoiceMCCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InvoiceMCCS.
     */
    cursor?: InvoiceMCCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceMCCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceMCCS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InvoiceMCCS.
     */
    distinct?: InvoiceMCCScalarFieldEnum | InvoiceMCCScalarFieldEnum[]
  }

  /**
   * InvoiceMCC findMany
   */
  export type InvoiceMCCFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * Filter, which InvoiceMCCS to fetch.
     */
    where?: InvoiceMCCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InvoiceMCCS to fetch.
     */
    orderBy?: InvoiceMCCOrderByWithRelationInput | InvoiceMCCOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InvoiceMCCS.
     */
    cursor?: InvoiceMCCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InvoiceMCCS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InvoiceMCCS.
     */
    skip?: number
    distinct?: InvoiceMCCScalarFieldEnum | InvoiceMCCScalarFieldEnum[]
  }

  /**
   * InvoiceMCC create
   */
  export type InvoiceMCCCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * The data needed to create a InvoiceMCC.
     */
    data: XOR<InvoiceMCCCreateInput, InvoiceMCCUncheckedCreateInput>
  }

  /**
   * InvoiceMCC createMany
   */
  export type InvoiceMCCCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InvoiceMCCS.
     */
    data: InvoiceMCCCreateManyInput | InvoiceMCCCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InvoiceMCC createManyAndReturn
   */
  export type InvoiceMCCCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InvoiceMCCS.
     */
    data: InvoiceMCCCreateManyInput | InvoiceMCCCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InvoiceMCC update
   */
  export type InvoiceMCCUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * The data needed to update a InvoiceMCC.
     */
    data: XOR<InvoiceMCCUpdateInput, InvoiceMCCUncheckedUpdateInput>
    /**
     * Choose, which InvoiceMCC to update.
     */
    where: InvoiceMCCWhereUniqueInput
  }

  /**
   * InvoiceMCC updateMany
   */
  export type InvoiceMCCUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InvoiceMCCS.
     */
    data: XOR<InvoiceMCCUpdateManyMutationInput, InvoiceMCCUncheckedUpdateManyInput>
    /**
     * Filter which InvoiceMCCS to update
     */
    where?: InvoiceMCCWhereInput
  }

  /**
   * InvoiceMCC upsert
   */
  export type InvoiceMCCUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * The filter to search for the InvoiceMCC to update in case it exists.
     */
    where: InvoiceMCCWhereUniqueInput
    /**
     * In case the InvoiceMCC found by the `where` argument doesn't exist, create a new InvoiceMCC with this data.
     */
    create: XOR<InvoiceMCCCreateInput, InvoiceMCCUncheckedCreateInput>
    /**
     * In case the InvoiceMCC was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceMCCUpdateInput, InvoiceMCCUncheckedUpdateInput>
  }

  /**
   * InvoiceMCC delete
   */
  export type InvoiceMCCDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    /**
     * Filter which InvoiceMCC to delete.
     */
    where: InvoiceMCCWhereUniqueInput
  }

  /**
   * InvoiceMCC deleteMany
   */
  export type InvoiceMCCDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InvoiceMCCS to delete
     */
    where?: InvoiceMCCWhereInput
  }

  /**
   * InvoiceMCC.partner
   */
  export type InvoiceMCC$partnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Partner
     */
    select?: PartnerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PartnerInclude<ExtArgs> | null
    where?: PartnerWhereInput
  }

  /**
   * InvoiceMCC.accounts
   */
  export type InvoiceMCC$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * InvoiceMCC.miHistories
   */
  export type InvoiceMCC$miHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    where?: AccountMIHistoryWhereInput
    orderBy?: AccountMIHistoryOrderByWithRelationInput | AccountMIHistoryOrderByWithRelationInput[]
    cursor?: AccountMIHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountMIHistoryScalarFieldEnum | AccountMIHistoryScalarFieldEnum[]
  }

  /**
   * InvoiceMCC.snapshots
   */
  export type InvoiceMCC$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    where?: SpendingSnapshotWhereInput
    orderBy?: SpendingSnapshotOrderByWithRelationInput | SpendingSnapshotOrderByWithRelationInput[]
    cursor?: SpendingSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendingSnapshotScalarFieldEnum | SpendingSnapshotScalarFieldEnum[]
  }

  /**
   * InvoiceMCC.spendingRecords
   */
  export type InvoiceMCC$spendingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    where?: SpendingRecordWhereInput
    orderBy?: SpendingRecordOrderByWithRelationInput | SpendingRecordOrderByWithRelationInput[]
    cursor?: SpendingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendingRecordScalarFieldEnum | SpendingRecordScalarFieldEnum[]
  }

  /**
   * InvoiceMCC without action
   */
  export type InvoiceMCCDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    totalSpending: Decimal | null
    totalAccounts: number | null
    activeAccounts: number | null
  }

  export type CustomerSumAggregateOutputType = {
    totalSpending: Decimal | null
    totalAccounts: number | null
    activeAccounts: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    contactInfo: string | null
    status: $Enums.CustomerStatus | null
    totalSpending: Decimal | null
    totalAccounts: number | null
    activeAccounts: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedStaffId: string | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contactInfo: string | null
    status: $Enums.CustomerStatus | null
    totalSpending: Decimal | null
    totalAccounts: number | null
    activeAccounts: number | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedStaffId: string | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    contactInfo: number
    status: number
    totalSpending: number
    totalAccounts: number
    activeAccounts: number
    notes: number
    createdAt: number
    updatedAt: number
    assignedStaffId: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    totalSpending?: true
    totalAccounts?: true
    activeAccounts?: true
  }

  export type CustomerSumAggregateInputType = {
    totalSpending?: true
    totalAccounts?: true
    activeAccounts?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    contactInfo?: true
    status?: true
    totalSpending?: true
    totalAccounts?: true
    activeAccounts?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    assignedStaffId?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    contactInfo?: true
    status?: true
    totalSpending?: true
    totalAccounts?: true
    activeAccounts?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    assignedStaffId?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    contactInfo?: true
    status?: true
    totalSpending?: true
    totalAccounts?: true
    activeAccounts?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    assignedStaffId?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    contactInfo: string | null
    status: $Enums.CustomerStatus
    totalSpending: Decimal
    totalAccounts: number
    activeAccounts: number
    notes: string | null
    createdAt: Date
    updatedAt: Date
    assignedStaffId: string | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactInfo?: boolean
    status?: boolean
    totalSpending?: boolean
    totalAccounts?: boolean
    activeAccounts?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedStaffId?: boolean
    assignedStaff?: boolean | Customer$assignedStaffArgs<ExtArgs>
    accounts?: boolean | Customer$accountsArgs<ExtArgs>
    mcHistories?: boolean | Customer$mcHistoriesArgs<ExtArgs>
    snapshots?: boolean | Customer$snapshotsArgs<ExtArgs>
    spendingRecords?: boolean | Customer$spendingRecordsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contactInfo?: boolean
    status?: boolean
    totalSpending?: boolean
    totalAccounts?: boolean
    activeAccounts?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedStaffId?: boolean
    assignedStaff?: boolean | Customer$assignedStaffArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    contactInfo?: boolean
    status?: boolean
    totalSpending?: boolean
    totalAccounts?: boolean
    activeAccounts?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedStaffId?: boolean
  }

  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedStaff?: boolean | Customer$assignedStaffArgs<ExtArgs>
    accounts?: boolean | Customer$accountsArgs<ExtArgs>
    mcHistories?: boolean | Customer$mcHistoriesArgs<ExtArgs>
    snapshots?: boolean | Customer$snapshotsArgs<ExtArgs>
    spendingRecords?: boolean | Customer$spendingRecordsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    assignedStaff?: boolean | Customer$assignedStaffArgs<ExtArgs>
  }

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      assignedStaff: Prisma.$UserPayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      mcHistories: Prisma.$AccountMCHistoryPayload<ExtArgs>[]
      snapshots: Prisma.$SpendingSnapshotPayload<ExtArgs>[]
      spendingRecords: Prisma.$SpendingRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contactInfo: string | null
      status: $Enums.CustomerStatus
      totalSpending: Prisma.Decimal
      totalAccounts: number
      activeAccounts: number
      notes: string | null
      createdAt: Date
      updatedAt: Date
      assignedStaffId: string | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    assignedStaff<T extends Customer$assignedStaffArgs<ExtArgs> = {}>(args?: Subset<T, Customer$assignedStaffArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    accounts<T extends Customer$accountsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany"> | Null>
    mcHistories<T extends Customer$mcHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Customer$mcHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    snapshots<T extends Customer$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findMany"> | Null>
    spendingRecords<T extends Customer$spendingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Customer$spendingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */ 
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly contactInfo: FieldRef<"Customer", 'String'>
    readonly status: FieldRef<"Customer", 'CustomerStatus'>
    readonly totalSpending: FieldRef<"Customer", 'Decimal'>
    readonly totalAccounts: FieldRef<"Customer", 'Int'>
    readonly activeAccounts: FieldRef<"Customer", 'Int'>
    readonly notes: FieldRef<"Customer", 'String'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
    readonly assignedStaffId: FieldRef<"Customer", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
  }

  /**
   * Customer.assignedStaff
   */
  export type Customer$assignedStaffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Customer.accounts
   */
  export type Customer$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Customer.mcHistories
   */
  export type Customer$mcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    where?: AccountMCHistoryWhereInput
    orderBy?: AccountMCHistoryOrderByWithRelationInput | AccountMCHistoryOrderByWithRelationInput[]
    cursor?: AccountMCHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountMCHistoryScalarFieldEnum | AccountMCHistoryScalarFieldEnum[]
  }

  /**
   * Customer.snapshots
   */
  export type Customer$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    where?: SpendingSnapshotWhereInput
    orderBy?: SpendingSnapshotOrderByWithRelationInput | SpendingSnapshotOrderByWithRelationInput[]
    cursor?: SpendingSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendingSnapshotScalarFieldEnum | SpendingSnapshotScalarFieldEnum[]
  }

  /**
   * Customer.spendingRecords
   */
  export type Customer$spendingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    where?: SpendingRecordWhereInput
    orderBy?: SpendingRecordOrderByWithRelationInput | SpendingRecordOrderByWithRelationInput[]
    cursor?: SpendingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendingRecordScalarFieldEnum | SpendingRecordScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    totalSpending: Decimal | null
  }

  export type AccountSumAggregateOutputType = {
    totalSpending: Decimal | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    googleAccountId: string | null
    accountName: string | null
    status: $Enums.AccountStatus | null
    currency: string | null
    timezone: string | null
    mccAccountName: string | null
    mccAccountId: string | null
    totalSpending: Decimal | null
    lastSynced: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    batchId: string | null
    currentMiId: string | null
    currentMcId: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    googleAccountId: string | null
    accountName: string | null
    status: $Enums.AccountStatus | null
    currency: string | null
    timezone: string | null
    mccAccountName: string | null
    mccAccountId: string | null
    totalSpending: Decimal | null
    lastSynced: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    batchId: string | null
    currentMiId: string | null
    currentMcId: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    googleAccountId: number
    accountName: number
    status: number
    currency: number
    timezone: number
    mccAccountName: number
    mccAccountId: number
    totalSpending: number
    lastSynced: number
    createdAt: number
    updatedAt: number
    batchId: number
    currentMiId: number
    currentMcId: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    totalSpending?: true
  }

  export type AccountSumAggregateInputType = {
    totalSpending?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    googleAccountId?: true
    accountName?: true
    status?: true
    currency?: true
    timezone?: true
    mccAccountName?: true
    mccAccountId?: true
    totalSpending?: true
    lastSynced?: true
    createdAt?: true
    updatedAt?: true
    batchId?: true
    currentMiId?: true
    currentMcId?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    googleAccountId?: true
    accountName?: true
    status?: true
    currency?: true
    timezone?: true
    mccAccountName?: true
    mccAccountId?: true
    totalSpending?: true
    lastSynced?: true
    createdAt?: true
    updatedAt?: true
    batchId?: true
    currentMiId?: true
    currentMcId?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    googleAccountId?: true
    accountName?: true
    status?: true
    currency?: true
    timezone?: true
    mccAccountName?: true
    mccAccountId?: true
    totalSpending?: true
    lastSynced?: true
    createdAt?: true
    updatedAt?: true
    batchId?: true
    currentMiId?: true
    currentMcId?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    googleAccountId: string
    accountName: string
    status: $Enums.AccountStatus
    currency: string
    timezone: string | null
    mccAccountName: string | null
    mccAccountId: string | null
    totalSpending: Decimal
    lastSynced: Date | null
    createdAt: Date
    updatedAt: Date
    batchId: string
    currentMiId: string | null
    currentMcId: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    googleAccountId?: boolean
    accountName?: boolean
    status?: boolean
    currency?: boolean
    timezone?: boolean
    mccAccountName?: boolean
    mccAccountId?: boolean
    totalSpending?: boolean
    lastSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batchId?: boolean
    currentMiId?: boolean
    currentMcId?: boolean
    batch?: boolean | AccountBatchDefaultArgs<ExtArgs>
    currentMi?: boolean | Account$currentMiArgs<ExtArgs>
    currentMc?: boolean | Account$currentMcArgs<ExtArgs>
    miHistories?: boolean | Account$miHistoriesArgs<ExtArgs>
    mcHistories?: boolean | Account$mcHistoriesArgs<ExtArgs>
    snapshots?: boolean | Account$snapshotsArgs<ExtArgs>
    spendingRecords?: boolean | Account$spendingRecordsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    googleAccountId?: boolean
    accountName?: boolean
    status?: boolean
    currency?: boolean
    timezone?: boolean
    mccAccountName?: boolean
    mccAccountId?: boolean
    totalSpending?: boolean
    lastSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batchId?: boolean
    currentMiId?: boolean
    currentMcId?: boolean
    batch?: boolean | AccountBatchDefaultArgs<ExtArgs>
    currentMi?: boolean | Account$currentMiArgs<ExtArgs>
    currentMc?: boolean | Account$currentMcArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    googleAccountId?: boolean
    accountName?: boolean
    status?: boolean
    currency?: boolean
    timezone?: boolean
    mccAccountName?: boolean
    mccAccountId?: boolean
    totalSpending?: boolean
    lastSynced?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    batchId?: boolean
    currentMiId?: boolean
    currentMcId?: boolean
  }

  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | AccountBatchDefaultArgs<ExtArgs>
    currentMi?: boolean | Account$currentMiArgs<ExtArgs>
    currentMc?: boolean | Account$currentMcArgs<ExtArgs>
    miHistories?: boolean | Account$miHistoriesArgs<ExtArgs>
    mcHistories?: boolean | Account$mcHistoriesArgs<ExtArgs>
    snapshots?: boolean | Account$snapshotsArgs<ExtArgs>
    spendingRecords?: boolean | Account$spendingRecordsArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    batch?: boolean | AccountBatchDefaultArgs<ExtArgs>
    currentMi?: boolean | Account$currentMiArgs<ExtArgs>
    currentMc?: boolean | Account$currentMcArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      batch: Prisma.$AccountBatchPayload<ExtArgs>
      currentMi: Prisma.$InvoiceMCCPayload<ExtArgs> | null
      currentMc: Prisma.$CustomerPayload<ExtArgs> | null
      miHistories: Prisma.$AccountMIHistoryPayload<ExtArgs>[]
      mcHistories: Prisma.$AccountMCHistoryPayload<ExtArgs>[]
      snapshots: Prisma.$SpendingSnapshotPayload<ExtArgs>[]
      spendingRecords: Prisma.$SpendingRecordPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      googleAccountId: string
      accountName: string
      status: $Enums.AccountStatus
      currency: string
      timezone: string | null
      mccAccountName: string | null
      mccAccountId: string | null
      totalSpending: Prisma.Decimal
      lastSynced: Date | null
      createdAt: Date
      updatedAt: Date
      batchId: string
      currentMiId: string | null
      currentMcId: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    batch<T extends AccountBatchDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountBatchDefaultArgs<ExtArgs>>): Prisma__AccountBatchClient<$Result.GetResult<Prisma.$AccountBatchPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    currentMi<T extends Account$currentMiArgs<ExtArgs> = {}>(args?: Subset<T, Account$currentMiArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    currentMc<T extends Account$currentMcArgs<ExtArgs> = {}>(args?: Subset<T, Account$currentMcArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    miHistories<T extends Account$miHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Account$miHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    mcHistories<T extends Account$mcHistoriesArgs<ExtArgs> = {}>(args?: Subset<T, Account$mcHistoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    snapshots<T extends Account$snapshotsArgs<ExtArgs> = {}>(args?: Subset<T, Account$snapshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findMany"> | Null>
    spendingRecords<T extends Account$spendingRecordsArgs<ExtArgs> = {}>(args?: Subset<T, Account$spendingRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */ 
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly googleAccountId: FieldRef<"Account", 'String'>
    readonly accountName: FieldRef<"Account", 'String'>
    readonly status: FieldRef<"Account", 'AccountStatus'>
    readonly currency: FieldRef<"Account", 'String'>
    readonly timezone: FieldRef<"Account", 'String'>
    readonly mccAccountName: FieldRef<"Account", 'String'>
    readonly mccAccountId: FieldRef<"Account", 'String'>
    readonly totalSpending: FieldRef<"Account", 'Decimal'>
    readonly lastSynced: FieldRef<"Account", 'DateTime'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly batchId: FieldRef<"Account", 'String'>
    readonly currentMiId: FieldRef<"Account", 'String'>
    readonly currentMcId: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
  }

  /**
   * Account.currentMi
   */
  export type Account$currentMiArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    where?: InvoiceMCCWhereInput
  }

  /**
   * Account.currentMc
   */
  export type Account$currentMcArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Account.miHistories
   */
  export type Account$miHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    where?: AccountMIHistoryWhereInput
    orderBy?: AccountMIHistoryOrderByWithRelationInput | AccountMIHistoryOrderByWithRelationInput[]
    cursor?: AccountMIHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountMIHistoryScalarFieldEnum | AccountMIHistoryScalarFieldEnum[]
  }

  /**
   * Account.mcHistories
   */
  export type Account$mcHistoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    where?: AccountMCHistoryWhereInput
    orderBy?: AccountMCHistoryOrderByWithRelationInput | AccountMCHistoryOrderByWithRelationInput[]
    cursor?: AccountMCHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountMCHistoryScalarFieldEnum | AccountMCHistoryScalarFieldEnum[]
  }

  /**
   * Account.snapshots
   */
  export type Account$snapshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    where?: SpendingSnapshotWhereInput
    orderBy?: SpendingSnapshotOrderByWithRelationInput | SpendingSnapshotOrderByWithRelationInput[]
    cursor?: SpendingSnapshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendingSnapshotScalarFieldEnum | SpendingSnapshotScalarFieldEnum[]
  }

  /**
   * Account.spendingRecords
   */
  export type Account$spendingRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    where?: SpendingRecordWhereInput
    orderBy?: SpendingRecordOrderByWithRelationInput | SpendingRecordOrderByWithRelationInput[]
    cursor?: SpendingRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SpendingRecordScalarFieldEnum | SpendingRecordScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model AccountMIHistory
   */

  export type AggregateAccountMIHistory = {
    _count: AccountMIHistoryCountAggregateOutputType | null
    _min: AccountMIHistoryMinAggregateOutputType | null
    _max: AccountMIHistoryMaxAggregateOutputType | null
  }

  export type AccountMIHistoryMinAggregateOutputType = {
    id: string | null
    linkedAt: Date | null
    unlinkedAt: Date | null
    reason: $Enums.HistoryReason | null
    notes: string | null
    createdAt: Date | null
    accountId: string | null
    invoiceMccId: string | null
    linkedById: string | null
    unlinkedById: string | null
  }

  export type AccountMIHistoryMaxAggregateOutputType = {
    id: string | null
    linkedAt: Date | null
    unlinkedAt: Date | null
    reason: $Enums.HistoryReason | null
    notes: string | null
    createdAt: Date | null
    accountId: string | null
    invoiceMccId: string | null
    linkedById: string | null
    unlinkedById: string | null
  }

  export type AccountMIHistoryCountAggregateOutputType = {
    id: number
    linkedAt: number
    unlinkedAt: number
    reason: number
    notes: number
    createdAt: number
    accountId: number
    invoiceMccId: number
    linkedById: number
    unlinkedById: number
    _all: number
  }


  export type AccountMIHistoryMinAggregateInputType = {
    id?: true
    linkedAt?: true
    unlinkedAt?: true
    reason?: true
    notes?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    linkedById?: true
    unlinkedById?: true
  }

  export type AccountMIHistoryMaxAggregateInputType = {
    id?: true
    linkedAt?: true
    unlinkedAt?: true
    reason?: true
    notes?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    linkedById?: true
    unlinkedById?: true
  }

  export type AccountMIHistoryCountAggregateInputType = {
    id?: true
    linkedAt?: true
    unlinkedAt?: true
    reason?: true
    notes?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    linkedById?: true
    unlinkedById?: true
    _all?: true
  }

  export type AccountMIHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountMIHistory to aggregate.
     */
    where?: AccountMIHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountMIHistories to fetch.
     */
    orderBy?: AccountMIHistoryOrderByWithRelationInput | AccountMIHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountMIHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountMIHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountMIHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountMIHistories
    **/
    _count?: true | AccountMIHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMIHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMIHistoryMaxAggregateInputType
  }

  export type GetAccountMIHistoryAggregateType<T extends AccountMIHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountMIHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountMIHistory[P]>
      : GetScalarType<T[P], AggregateAccountMIHistory[P]>
  }




  export type AccountMIHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMIHistoryWhereInput
    orderBy?: AccountMIHistoryOrderByWithAggregationInput | AccountMIHistoryOrderByWithAggregationInput[]
    by: AccountMIHistoryScalarFieldEnum[] | AccountMIHistoryScalarFieldEnum
    having?: AccountMIHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountMIHistoryCountAggregateInputType | true
    _min?: AccountMIHistoryMinAggregateInputType
    _max?: AccountMIHistoryMaxAggregateInputType
  }

  export type AccountMIHistoryGroupByOutputType = {
    id: string
    linkedAt: Date
    unlinkedAt: Date | null
    reason: $Enums.HistoryReason
    notes: string | null
    createdAt: Date
    accountId: string
    invoiceMccId: string
    linkedById: string
    unlinkedById: string | null
    _count: AccountMIHistoryCountAggregateOutputType | null
    _min: AccountMIHistoryMinAggregateOutputType | null
    _max: AccountMIHistoryMaxAggregateOutputType | null
  }

  type GetAccountMIHistoryGroupByPayload<T extends AccountMIHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountMIHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountMIHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountMIHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AccountMIHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AccountMIHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkedAt?: boolean
    unlinkedAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    linkedById?: boolean
    unlinkedById?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | InvoiceMCCDefaultArgs<ExtArgs>
    linkedBy?: boolean | UserDefaultArgs<ExtArgs>
    unlinkedBy?: boolean | AccountMIHistory$unlinkedByArgs<ExtArgs>
  }, ExtArgs["result"]["accountMIHistory"]>

  export type AccountMIHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    linkedAt?: boolean
    unlinkedAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    linkedById?: boolean
    unlinkedById?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | InvoiceMCCDefaultArgs<ExtArgs>
    linkedBy?: boolean | UserDefaultArgs<ExtArgs>
    unlinkedBy?: boolean | AccountMIHistory$unlinkedByArgs<ExtArgs>
  }, ExtArgs["result"]["accountMIHistory"]>

  export type AccountMIHistorySelectScalar = {
    id?: boolean
    linkedAt?: boolean
    unlinkedAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    linkedById?: boolean
    unlinkedById?: boolean
  }

  export type AccountMIHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | InvoiceMCCDefaultArgs<ExtArgs>
    linkedBy?: boolean | UserDefaultArgs<ExtArgs>
    unlinkedBy?: boolean | AccountMIHistory$unlinkedByArgs<ExtArgs>
  }
  export type AccountMIHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | InvoiceMCCDefaultArgs<ExtArgs>
    linkedBy?: boolean | UserDefaultArgs<ExtArgs>
    unlinkedBy?: boolean | AccountMIHistory$unlinkedByArgs<ExtArgs>
  }

  export type $AccountMIHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountMIHistory"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      invoiceMcc: Prisma.$InvoiceMCCPayload<ExtArgs>
      linkedBy: Prisma.$UserPayload<ExtArgs>
      unlinkedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      linkedAt: Date
      unlinkedAt: Date | null
      reason: $Enums.HistoryReason
      notes: string | null
      createdAt: Date
      accountId: string
      invoiceMccId: string
      linkedById: string
      unlinkedById: string | null
    }, ExtArgs["result"]["accountMIHistory"]>
    composites: {}
  }

  type AccountMIHistoryGetPayload<S extends boolean | null | undefined | AccountMIHistoryDefaultArgs> = $Result.GetResult<Prisma.$AccountMIHistoryPayload, S>

  type AccountMIHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountMIHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountMIHistoryCountAggregateInputType | true
    }

  export interface AccountMIHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountMIHistory'], meta: { name: 'AccountMIHistory' } }
    /**
     * Find zero or one AccountMIHistory that matches the filter.
     * @param {AccountMIHistoryFindUniqueArgs} args - Arguments to find a AccountMIHistory
     * @example
     * // Get one AccountMIHistory
     * const accountMIHistory = await prisma.accountMIHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountMIHistoryFindUniqueArgs>(args: SelectSubset<T, AccountMIHistoryFindUniqueArgs<ExtArgs>>): Prisma__AccountMIHistoryClient<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccountMIHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountMIHistoryFindUniqueOrThrowArgs} args - Arguments to find a AccountMIHistory
     * @example
     * // Get one AccountMIHistory
     * const accountMIHistory = await prisma.accountMIHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountMIHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountMIHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountMIHistoryClient<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccountMIHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMIHistoryFindFirstArgs} args - Arguments to find a AccountMIHistory
     * @example
     * // Get one AccountMIHistory
     * const accountMIHistory = await prisma.accountMIHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountMIHistoryFindFirstArgs>(args?: SelectSubset<T, AccountMIHistoryFindFirstArgs<ExtArgs>>): Prisma__AccountMIHistoryClient<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccountMIHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMIHistoryFindFirstOrThrowArgs} args - Arguments to find a AccountMIHistory
     * @example
     * // Get one AccountMIHistory
     * const accountMIHistory = await prisma.accountMIHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountMIHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountMIHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountMIHistoryClient<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccountMIHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMIHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountMIHistories
     * const accountMIHistories = await prisma.accountMIHistory.findMany()
     * 
     * // Get first 10 AccountMIHistories
     * const accountMIHistories = await prisma.accountMIHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountMIHistoryWithIdOnly = await prisma.accountMIHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountMIHistoryFindManyArgs>(args?: SelectSubset<T, AccountMIHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccountMIHistory.
     * @param {AccountMIHistoryCreateArgs} args - Arguments to create a AccountMIHistory.
     * @example
     * // Create one AccountMIHistory
     * const AccountMIHistory = await prisma.accountMIHistory.create({
     *   data: {
     *     // ... data to create a AccountMIHistory
     *   }
     * })
     * 
     */
    create<T extends AccountMIHistoryCreateArgs>(args: SelectSubset<T, AccountMIHistoryCreateArgs<ExtArgs>>): Prisma__AccountMIHistoryClient<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccountMIHistories.
     * @param {AccountMIHistoryCreateManyArgs} args - Arguments to create many AccountMIHistories.
     * @example
     * // Create many AccountMIHistories
     * const accountMIHistory = await prisma.accountMIHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountMIHistoryCreateManyArgs>(args?: SelectSubset<T, AccountMIHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountMIHistories and returns the data saved in the database.
     * @param {AccountMIHistoryCreateManyAndReturnArgs} args - Arguments to create many AccountMIHistories.
     * @example
     * // Create many AccountMIHistories
     * const accountMIHistory = await prisma.accountMIHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountMIHistories and only return the `id`
     * const accountMIHistoryWithIdOnly = await prisma.accountMIHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountMIHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountMIHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccountMIHistory.
     * @param {AccountMIHistoryDeleteArgs} args - Arguments to delete one AccountMIHistory.
     * @example
     * // Delete one AccountMIHistory
     * const AccountMIHistory = await prisma.accountMIHistory.delete({
     *   where: {
     *     // ... filter to delete one AccountMIHistory
     *   }
     * })
     * 
     */
    delete<T extends AccountMIHistoryDeleteArgs>(args: SelectSubset<T, AccountMIHistoryDeleteArgs<ExtArgs>>): Prisma__AccountMIHistoryClient<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccountMIHistory.
     * @param {AccountMIHistoryUpdateArgs} args - Arguments to update one AccountMIHistory.
     * @example
     * // Update one AccountMIHistory
     * const accountMIHistory = await prisma.accountMIHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountMIHistoryUpdateArgs>(args: SelectSubset<T, AccountMIHistoryUpdateArgs<ExtArgs>>): Prisma__AccountMIHistoryClient<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccountMIHistories.
     * @param {AccountMIHistoryDeleteManyArgs} args - Arguments to filter AccountMIHistories to delete.
     * @example
     * // Delete a few AccountMIHistories
     * const { count } = await prisma.accountMIHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountMIHistoryDeleteManyArgs>(args?: SelectSubset<T, AccountMIHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountMIHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMIHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountMIHistories
     * const accountMIHistory = await prisma.accountMIHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountMIHistoryUpdateManyArgs>(args: SelectSubset<T, AccountMIHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountMIHistory.
     * @param {AccountMIHistoryUpsertArgs} args - Arguments to update or create a AccountMIHistory.
     * @example
     * // Update or create a AccountMIHistory
     * const accountMIHistory = await prisma.accountMIHistory.upsert({
     *   create: {
     *     // ... data to create a AccountMIHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountMIHistory we want to update
     *   }
     * })
     */
    upsert<T extends AccountMIHistoryUpsertArgs>(args: SelectSubset<T, AccountMIHistoryUpsertArgs<ExtArgs>>): Prisma__AccountMIHistoryClient<$Result.GetResult<Prisma.$AccountMIHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccountMIHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMIHistoryCountArgs} args - Arguments to filter AccountMIHistories to count.
     * @example
     * // Count the number of AccountMIHistories
     * const count = await prisma.accountMIHistory.count({
     *   where: {
     *     // ... the filter for the AccountMIHistories we want to count
     *   }
     * })
    **/
    count<T extends AccountMIHistoryCountArgs>(
      args?: Subset<T, AccountMIHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountMIHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountMIHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMIHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountMIHistoryAggregateArgs>(args: Subset<T, AccountMIHistoryAggregateArgs>): Prisma.PrismaPromise<GetAccountMIHistoryAggregateType<T>>

    /**
     * Group by AccountMIHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMIHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountMIHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountMIHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AccountMIHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountMIHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountMIHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountMIHistory model
   */
  readonly fields: AccountMIHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountMIHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountMIHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoiceMcc<T extends InvoiceMCCDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceMCCDefaultArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    linkedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    unlinkedBy<T extends AccountMIHistory$unlinkedByArgs<ExtArgs> = {}>(args?: Subset<T, AccountMIHistory$unlinkedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountMIHistory model
   */ 
  interface AccountMIHistoryFieldRefs {
    readonly id: FieldRef<"AccountMIHistory", 'String'>
    readonly linkedAt: FieldRef<"AccountMIHistory", 'DateTime'>
    readonly unlinkedAt: FieldRef<"AccountMIHistory", 'DateTime'>
    readonly reason: FieldRef<"AccountMIHistory", 'HistoryReason'>
    readonly notes: FieldRef<"AccountMIHistory", 'String'>
    readonly createdAt: FieldRef<"AccountMIHistory", 'DateTime'>
    readonly accountId: FieldRef<"AccountMIHistory", 'String'>
    readonly invoiceMccId: FieldRef<"AccountMIHistory", 'String'>
    readonly linkedById: FieldRef<"AccountMIHistory", 'String'>
    readonly unlinkedById: FieldRef<"AccountMIHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccountMIHistory findUnique
   */
  export type AccountMIHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMIHistory to fetch.
     */
    where: AccountMIHistoryWhereUniqueInput
  }

  /**
   * AccountMIHistory findUniqueOrThrow
   */
  export type AccountMIHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMIHistory to fetch.
     */
    where: AccountMIHistoryWhereUniqueInput
  }

  /**
   * AccountMIHistory findFirst
   */
  export type AccountMIHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMIHistory to fetch.
     */
    where?: AccountMIHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountMIHistories to fetch.
     */
    orderBy?: AccountMIHistoryOrderByWithRelationInput | AccountMIHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountMIHistories.
     */
    cursor?: AccountMIHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountMIHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountMIHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountMIHistories.
     */
    distinct?: AccountMIHistoryScalarFieldEnum | AccountMIHistoryScalarFieldEnum[]
  }

  /**
   * AccountMIHistory findFirstOrThrow
   */
  export type AccountMIHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMIHistory to fetch.
     */
    where?: AccountMIHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountMIHistories to fetch.
     */
    orderBy?: AccountMIHistoryOrderByWithRelationInput | AccountMIHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountMIHistories.
     */
    cursor?: AccountMIHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountMIHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountMIHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountMIHistories.
     */
    distinct?: AccountMIHistoryScalarFieldEnum | AccountMIHistoryScalarFieldEnum[]
  }

  /**
   * AccountMIHistory findMany
   */
  export type AccountMIHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMIHistories to fetch.
     */
    where?: AccountMIHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountMIHistories to fetch.
     */
    orderBy?: AccountMIHistoryOrderByWithRelationInput | AccountMIHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountMIHistories.
     */
    cursor?: AccountMIHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountMIHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountMIHistories.
     */
    skip?: number
    distinct?: AccountMIHistoryScalarFieldEnum | AccountMIHistoryScalarFieldEnum[]
  }

  /**
   * AccountMIHistory create
   */
  export type AccountMIHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountMIHistory.
     */
    data: XOR<AccountMIHistoryCreateInput, AccountMIHistoryUncheckedCreateInput>
  }

  /**
   * AccountMIHistory createMany
   */
  export type AccountMIHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountMIHistories.
     */
    data: AccountMIHistoryCreateManyInput | AccountMIHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountMIHistory createManyAndReturn
   */
  export type AccountMIHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccountMIHistories.
     */
    data: AccountMIHistoryCreateManyInput | AccountMIHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountMIHistory update
   */
  export type AccountMIHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountMIHistory.
     */
    data: XOR<AccountMIHistoryUpdateInput, AccountMIHistoryUncheckedUpdateInput>
    /**
     * Choose, which AccountMIHistory to update.
     */
    where: AccountMIHistoryWhereUniqueInput
  }

  /**
   * AccountMIHistory updateMany
   */
  export type AccountMIHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountMIHistories.
     */
    data: XOR<AccountMIHistoryUpdateManyMutationInput, AccountMIHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AccountMIHistories to update
     */
    where?: AccountMIHistoryWhereInput
  }

  /**
   * AccountMIHistory upsert
   */
  export type AccountMIHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountMIHistory to update in case it exists.
     */
    where: AccountMIHistoryWhereUniqueInput
    /**
     * In case the AccountMIHistory found by the `where` argument doesn't exist, create a new AccountMIHistory with this data.
     */
    create: XOR<AccountMIHistoryCreateInput, AccountMIHistoryUncheckedCreateInput>
    /**
     * In case the AccountMIHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountMIHistoryUpdateInput, AccountMIHistoryUncheckedUpdateInput>
  }

  /**
   * AccountMIHistory delete
   */
  export type AccountMIHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
    /**
     * Filter which AccountMIHistory to delete.
     */
    where: AccountMIHistoryWhereUniqueInput
  }

  /**
   * AccountMIHistory deleteMany
   */
  export type AccountMIHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountMIHistories to delete
     */
    where?: AccountMIHistoryWhereInput
  }

  /**
   * AccountMIHistory.unlinkedBy
   */
  export type AccountMIHistory$unlinkedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AccountMIHistory without action
   */
  export type AccountMIHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMIHistory
     */
    select?: AccountMIHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMIHistoryInclude<ExtArgs> | null
  }


  /**
   * Model AccountMCHistory
   */

  export type AggregateAccountMCHistory = {
    _count: AccountMCHistoryCountAggregateOutputType | null
    _min: AccountMCHistoryMinAggregateOutputType | null
    _max: AccountMCHistoryMaxAggregateOutputType | null
  }

  export type AccountMCHistoryMinAggregateOutputType = {
    id: string | null
    assignedAt: Date | null
    unassignedAt: Date | null
    reason: $Enums.HistoryReason | null
    notes: string | null
    createdAt: Date | null
    accountId: string | null
    customerId: string | null
    assignedById: string | null
    unassignedById: string | null
  }

  export type AccountMCHistoryMaxAggregateOutputType = {
    id: string | null
    assignedAt: Date | null
    unassignedAt: Date | null
    reason: $Enums.HistoryReason | null
    notes: string | null
    createdAt: Date | null
    accountId: string | null
    customerId: string | null
    assignedById: string | null
    unassignedById: string | null
  }

  export type AccountMCHistoryCountAggregateOutputType = {
    id: number
    assignedAt: number
    unassignedAt: number
    reason: number
    notes: number
    createdAt: number
    accountId: number
    customerId: number
    assignedById: number
    unassignedById: number
    _all: number
  }


  export type AccountMCHistoryMinAggregateInputType = {
    id?: true
    assignedAt?: true
    unassignedAt?: true
    reason?: true
    notes?: true
    createdAt?: true
    accountId?: true
    customerId?: true
    assignedById?: true
    unassignedById?: true
  }

  export type AccountMCHistoryMaxAggregateInputType = {
    id?: true
    assignedAt?: true
    unassignedAt?: true
    reason?: true
    notes?: true
    createdAt?: true
    accountId?: true
    customerId?: true
    assignedById?: true
    unassignedById?: true
  }

  export type AccountMCHistoryCountAggregateInputType = {
    id?: true
    assignedAt?: true
    unassignedAt?: true
    reason?: true
    notes?: true
    createdAt?: true
    accountId?: true
    customerId?: true
    assignedById?: true
    unassignedById?: true
    _all?: true
  }

  export type AccountMCHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountMCHistory to aggregate.
     */
    where?: AccountMCHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountMCHistories to fetch.
     */
    orderBy?: AccountMCHistoryOrderByWithRelationInput | AccountMCHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountMCHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountMCHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountMCHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountMCHistories
    **/
    _count?: true | AccountMCHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMCHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMCHistoryMaxAggregateInputType
  }

  export type GetAccountMCHistoryAggregateType<T extends AccountMCHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountMCHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountMCHistory[P]>
      : GetScalarType<T[P], AggregateAccountMCHistory[P]>
  }




  export type AccountMCHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountMCHistoryWhereInput
    orderBy?: AccountMCHistoryOrderByWithAggregationInput | AccountMCHistoryOrderByWithAggregationInput[]
    by: AccountMCHistoryScalarFieldEnum[] | AccountMCHistoryScalarFieldEnum
    having?: AccountMCHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountMCHistoryCountAggregateInputType | true
    _min?: AccountMCHistoryMinAggregateInputType
    _max?: AccountMCHistoryMaxAggregateInputType
  }

  export type AccountMCHistoryGroupByOutputType = {
    id: string
    assignedAt: Date
    unassignedAt: Date | null
    reason: $Enums.HistoryReason
    notes: string | null
    createdAt: Date
    accountId: string
    customerId: string
    assignedById: string
    unassignedById: string | null
    _count: AccountMCHistoryCountAggregateOutputType | null
    _min: AccountMCHistoryMinAggregateOutputType | null
    _max: AccountMCHistoryMaxAggregateOutputType | null
  }

  type GetAccountMCHistoryGroupByPayload<T extends AccountMCHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountMCHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountMCHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountMCHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], AccountMCHistoryGroupByOutputType[P]>
        }
      >
    >


  export type AccountMCHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignedAt?: boolean
    unassignedAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    accountId?: boolean
    customerId?: boolean
    assignedById?: boolean
    unassignedById?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    unassignedBy?: boolean | AccountMCHistory$unassignedByArgs<ExtArgs>
  }, ExtArgs["result"]["accountMCHistory"]>

  export type AccountMCHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    assignedAt?: boolean
    unassignedAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    accountId?: boolean
    customerId?: boolean
    assignedById?: boolean
    unassignedById?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    unassignedBy?: boolean | AccountMCHistory$unassignedByArgs<ExtArgs>
  }, ExtArgs["result"]["accountMCHistory"]>

  export type AccountMCHistorySelectScalar = {
    id?: boolean
    assignedAt?: boolean
    unassignedAt?: boolean
    reason?: boolean
    notes?: boolean
    createdAt?: boolean
    accountId?: boolean
    customerId?: boolean
    assignedById?: boolean
    unassignedById?: boolean
  }

  export type AccountMCHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    unassignedBy?: boolean | AccountMCHistory$unassignedByArgs<ExtArgs>
  }
  export type AccountMCHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    customer?: boolean | CustomerDefaultArgs<ExtArgs>
    assignedBy?: boolean | UserDefaultArgs<ExtArgs>
    unassignedBy?: boolean | AccountMCHistory$unassignedByArgs<ExtArgs>
  }

  export type $AccountMCHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountMCHistory"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs>
      assignedBy: Prisma.$UserPayload<ExtArgs>
      unassignedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      assignedAt: Date
      unassignedAt: Date | null
      reason: $Enums.HistoryReason
      notes: string | null
      createdAt: Date
      accountId: string
      customerId: string
      assignedById: string
      unassignedById: string | null
    }, ExtArgs["result"]["accountMCHistory"]>
    composites: {}
  }

  type AccountMCHistoryGetPayload<S extends boolean | null | undefined | AccountMCHistoryDefaultArgs> = $Result.GetResult<Prisma.$AccountMCHistoryPayload, S>

  type AccountMCHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccountMCHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccountMCHistoryCountAggregateInputType | true
    }

  export interface AccountMCHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountMCHistory'], meta: { name: 'AccountMCHistory' } }
    /**
     * Find zero or one AccountMCHistory that matches the filter.
     * @param {AccountMCHistoryFindUniqueArgs} args - Arguments to find a AccountMCHistory
     * @example
     * // Get one AccountMCHistory
     * const accountMCHistory = await prisma.accountMCHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountMCHistoryFindUniqueArgs>(args: SelectSubset<T, AccountMCHistoryFindUniqueArgs<ExtArgs>>): Prisma__AccountMCHistoryClient<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AccountMCHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccountMCHistoryFindUniqueOrThrowArgs} args - Arguments to find a AccountMCHistory
     * @example
     * // Get one AccountMCHistory
     * const accountMCHistory = await prisma.accountMCHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountMCHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountMCHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountMCHistoryClient<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AccountMCHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMCHistoryFindFirstArgs} args - Arguments to find a AccountMCHistory
     * @example
     * // Get one AccountMCHistory
     * const accountMCHistory = await prisma.accountMCHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountMCHistoryFindFirstArgs>(args?: SelectSubset<T, AccountMCHistoryFindFirstArgs<ExtArgs>>): Prisma__AccountMCHistoryClient<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AccountMCHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMCHistoryFindFirstOrThrowArgs} args - Arguments to find a AccountMCHistory
     * @example
     * // Get one AccountMCHistory
     * const accountMCHistory = await prisma.accountMCHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountMCHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountMCHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountMCHistoryClient<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AccountMCHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMCHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountMCHistories
     * const accountMCHistories = await prisma.accountMCHistory.findMany()
     * 
     * // Get first 10 AccountMCHistories
     * const accountMCHistories = await prisma.accountMCHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountMCHistoryWithIdOnly = await prisma.accountMCHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountMCHistoryFindManyArgs>(args?: SelectSubset<T, AccountMCHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AccountMCHistory.
     * @param {AccountMCHistoryCreateArgs} args - Arguments to create a AccountMCHistory.
     * @example
     * // Create one AccountMCHistory
     * const AccountMCHistory = await prisma.accountMCHistory.create({
     *   data: {
     *     // ... data to create a AccountMCHistory
     *   }
     * })
     * 
     */
    create<T extends AccountMCHistoryCreateArgs>(args: SelectSubset<T, AccountMCHistoryCreateArgs<ExtArgs>>): Prisma__AccountMCHistoryClient<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AccountMCHistories.
     * @param {AccountMCHistoryCreateManyArgs} args - Arguments to create many AccountMCHistories.
     * @example
     * // Create many AccountMCHistories
     * const accountMCHistory = await prisma.accountMCHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountMCHistoryCreateManyArgs>(args?: SelectSubset<T, AccountMCHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountMCHistories and returns the data saved in the database.
     * @param {AccountMCHistoryCreateManyAndReturnArgs} args - Arguments to create many AccountMCHistories.
     * @example
     * // Create many AccountMCHistories
     * const accountMCHistory = await prisma.accountMCHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountMCHistories and only return the `id`
     * const accountMCHistoryWithIdOnly = await prisma.accountMCHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountMCHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountMCHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AccountMCHistory.
     * @param {AccountMCHistoryDeleteArgs} args - Arguments to delete one AccountMCHistory.
     * @example
     * // Delete one AccountMCHistory
     * const AccountMCHistory = await prisma.accountMCHistory.delete({
     *   where: {
     *     // ... filter to delete one AccountMCHistory
     *   }
     * })
     * 
     */
    delete<T extends AccountMCHistoryDeleteArgs>(args: SelectSubset<T, AccountMCHistoryDeleteArgs<ExtArgs>>): Prisma__AccountMCHistoryClient<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AccountMCHistory.
     * @param {AccountMCHistoryUpdateArgs} args - Arguments to update one AccountMCHistory.
     * @example
     * // Update one AccountMCHistory
     * const accountMCHistory = await prisma.accountMCHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountMCHistoryUpdateArgs>(args: SelectSubset<T, AccountMCHistoryUpdateArgs<ExtArgs>>): Prisma__AccountMCHistoryClient<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AccountMCHistories.
     * @param {AccountMCHistoryDeleteManyArgs} args - Arguments to filter AccountMCHistories to delete.
     * @example
     * // Delete a few AccountMCHistories
     * const { count } = await prisma.accountMCHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountMCHistoryDeleteManyArgs>(args?: SelectSubset<T, AccountMCHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountMCHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMCHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountMCHistories
     * const accountMCHistory = await prisma.accountMCHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountMCHistoryUpdateManyArgs>(args: SelectSubset<T, AccountMCHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AccountMCHistory.
     * @param {AccountMCHistoryUpsertArgs} args - Arguments to update or create a AccountMCHistory.
     * @example
     * // Update or create a AccountMCHistory
     * const accountMCHistory = await prisma.accountMCHistory.upsert({
     *   create: {
     *     // ... data to create a AccountMCHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountMCHistory we want to update
     *   }
     * })
     */
    upsert<T extends AccountMCHistoryUpsertArgs>(args: SelectSubset<T, AccountMCHistoryUpsertArgs<ExtArgs>>): Prisma__AccountMCHistoryClient<$Result.GetResult<Prisma.$AccountMCHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AccountMCHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMCHistoryCountArgs} args - Arguments to filter AccountMCHistories to count.
     * @example
     * // Count the number of AccountMCHistories
     * const count = await prisma.accountMCHistory.count({
     *   where: {
     *     // ... the filter for the AccountMCHistories we want to count
     *   }
     * })
    **/
    count<T extends AccountMCHistoryCountArgs>(
      args?: Subset<T, AccountMCHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountMCHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountMCHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMCHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountMCHistoryAggregateArgs>(args: Subset<T, AccountMCHistoryAggregateArgs>): Prisma.PrismaPromise<GetAccountMCHistoryAggregateType<T>>

    /**
     * Group by AccountMCHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountMCHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountMCHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountMCHistoryGroupByArgs['orderBy'] }
        : { orderBy?: AccountMCHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountMCHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountMCHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountMCHistory model
   */
  readonly fields: AccountMCHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountMCHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountMCHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    customer<T extends CustomerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CustomerDefaultArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    assignedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    unassignedBy<T extends AccountMCHistory$unassignedByArgs<ExtArgs> = {}>(args?: Subset<T, AccountMCHistory$unassignedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountMCHistory model
   */ 
  interface AccountMCHistoryFieldRefs {
    readonly id: FieldRef<"AccountMCHistory", 'String'>
    readonly assignedAt: FieldRef<"AccountMCHistory", 'DateTime'>
    readonly unassignedAt: FieldRef<"AccountMCHistory", 'DateTime'>
    readonly reason: FieldRef<"AccountMCHistory", 'HistoryReason'>
    readonly notes: FieldRef<"AccountMCHistory", 'String'>
    readonly createdAt: FieldRef<"AccountMCHistory", 'DateTime'>
    readonly accountId: FieldRef<"AccountMCHistory", 'String'>
    readonly customerId: FieldRef<"AccountMCHistory", 'String'>
    readonly assignedById: FieldRef<"AccountMCHistory", 'String'>
    readonly unassignedById: FieldRef<"AccountMCHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AccountMCHistory findUnique
   */
  export type AccountMCHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMCHistory to fetch.
     */
    where: AccountMCHistoryWhereUniqueInput
  }

  /**
   * AccountMCHistory findUniqueOrThrow
   */
  export type AccountMCHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMCHistory to fetch.
     */
    where: AccountMCHistoryWhereUniqueInput
  }

  /**
   * AccountMCHistory findFirst
   */
  export type AccountMCHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMCHistory to fetch.
     */
    where?: AccountMCHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountMCHistories to fetch.
     */
    orderBy?: AccountMCHistoryOrderByWithRelationInput | AccountMCHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountMCHistories.
     */
    cursor?: AccountMCHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountMCHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountMCHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountMCHistories.
     */
    distinct?: AccountMCHistoryScalarFieldEnum | AccountMCHistoryScalarFieldEnum[]
  }

  /**
   * AccountMCHistory findFirstOrThrow
   */
  export type AccountMCHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMCHistory to fetch.
     */
    where?: AccountMCHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountMCHistories to fetch.
     */
    orderBy?: AccountMCHistoryOrderByWithRelationInput | AccountMCHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountMCHistories.
     */
    cursor?: AccountMCHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountMCHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountMCHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountMCHistories.
     */
    distinct?: AccountMCHistoryScalarFieldEnum | AccountMCHistoryScalarFieldEnum[]
  }

  /**
   * AccountMCHistory findMany
   */
  export type AccountMCHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * Filter, which AccountMCHistories to fetch.
     */
    where?: AccountMCHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountMCHistories to fetch.
     */
    orderBy?: AccountMCHistoryOrderByWithRelationInput | AccountMCHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountMCHistories.
     */
    cursor?: AccountMCHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountMCHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountMCHistories.
     */
    skip?: number
    distinct?: AccountMCHistoryScalarFieldEnum | AccountMCHistoryScalarFieldEnum[]
  }

  /**
   * AccountMCHistory create
   */
  export type AccountMCHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountMCHistory.
     */
    data: XOR<AccountMCHistoryCreateInput, AccountMCHistoryUncheckedCreateInput>
  }

  /**
   * AccountMCHistory createMany
   */
  export type AccountMCHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountMCHistories.
     */
    data: AccountMCHistoryCreateManyInput | AccountMCHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountMCHistory createManyAndReturn
   */
  export type AccountMCHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AccountMCHistories.
     */
    data: AccountMCHistoryCreateManyInput | AccountMCHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountMCHistory update
   */
  export type AccountMCHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountMCHistory.
     */
    data: XOR<AccountMCHistoryUpdateInput, AccountMCHistoryUncheckedUpdateInput>
    /**
     * Choose, which AccountMCHistory to update.
     */
    where: AccountMCHistoryWhereUniqueInput
  }

  /**
   * AccountMCHistory updateMany
   */
  export type AccountMCHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountMCHistories.
     */
    data: XOR<AccountMCHistoryUpdateManyMutationInput, AccountMCHistoryUncheckedUpdateManyInput>
    /**
     * Filter which AccountMCHistories to update
     */
    where?: AccountMCHistoryWhereInput
  }

  /**
   * AccountMCHistory upsert
   */
  export type AccountMCHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountMCHistory to update in case it exists.
     */
    where: AccountMCHistoryWhereUniqueInput
    /**
     * In case the AccountMCHistory found by the `where` argument doesn't exist, create a new AccountMCHistory with this data.
     */
    create: XOR<AccountMCHistoryCreateInput, AccountMCHistoryUncheckedCreateInput>
    /**
     * In case the AccountMCHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountMCHistoryUpdateInput, AccountMCHistoryUncheckedUpdateInput>
  }

  /**
   * AccountMCHistory delete
   */
  export type AccountMCHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
    /**
     * Filter which AccountMCHistory to delete.
     */
    where: AccountMCHistoryWhereUniqueInput
  }

  /**
   * AccountMCHistory deleteMany
   */
  export type AccountMCHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountMCHistories to delete
     */
    where?: AccountMCHistoryWhereInput
  }

  /**
   * AccountMCHistory.unassignedBy
   */
  export type AccountMCHistory$unassignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AccountMCHistory without action
   */
  export type AccountMCHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountMCHistory
     */
    select?: AccountMCHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountMCHistoryInclude<ExtArgs> | null
  }


  /**
   * Model SpendingSnapshot
   */

  export type AggregateSpendingSnapshot = {
    _count: SpendingSnapshotCountAggregateOutputType | null
    _avg: SpendingSnapshotAvgAggregateOutputType | null
    _sum: SpendingSnapshotSumAggregateOutputType | null
    _min: SpendingSnapshotMinAggregateOutputType | null
    _max: SpendingSnapshotMaxAggregateOutputType | null
  }

  export type SpendingSnapshotAvgAggregateOutputType = {
    cumulativeAmount: Decimal | null
  }

  export type SpendingSnapshotSumAggregateOutputType = {
    cumulativeAmount: Decimal | null
  }

  export type SpendingSnapshotMinAggregateOutputType = {
    id: string | null
    spendingDate: Date | null
    cumulativeAmount: Decimal | null
    snapshotAt: Date | null
    snapshotType: $Enums.SnapshotType | null
    createdAt: Date | null
    accountId: string | null
    invoiceMccId: string | null
    customerId: string | null
    createdById: string | null
  }

  export type SpendingSnapshotMaxAggregateOutputType = {
    id: string | null
    spendingDate: Date | null
    cumulativeAmount: Decimal | null
    snapshotAt: Date | null
    snapshotType: $Enums.SnapshotType | null
    createdAt: Date | null
    accountId: string | null
    invoiceMccId: string | null
    customerId: string | null
    createdById: string | null
  }

  export type SpendingSnapshotCountAggregateOutputType = {
    id: number
    spendingDate: number
    cumulativeAmount: number
    snapshotAt: number
    snapshotType: number
    createdAt: number
    accountId: number
    invoiceMccId: number
    customerId: number
    createdById: number
    _all: number
  }


  export type SpendingSnapshotAvgAggregateInputType = {
    cumulativeAmount?: true
  }

  export type SpendingSnapshotSumAggregateInputType = {
    cumulativeAmount?: true
  }

  export type SpendingSnapshotMinAggregateInputType = {
    id?: true
    spendingDate?: true
    cumulativeAmount?: true
    snapshotAt?: true
    snapshotType?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    customerId?: true
    createdById?: true
  }

  export type SpendingSnapshotMaxAggregateInputType = {
    id?: true
    spendingDate?: true
    cumulativeAmount?: true
    snapshotAt?: true
    snapshotType?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    customerId?: true
    createdById?: true
  }

  export type SpendingSnapshotCountAggregateInputType = {
    id?: true
    spendingDate?: true
    cumulativeAmount?: true
    snapshotAt?: true
    snapshotType?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    customerId?: true
    createdById?: true
    _all?: true
  }

  export type SpendingSnapshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpendingSnapshot to aggregate.
     */
    where?: SpendingSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingSnapshots to fetch.
     */
    orderBy?: SpendingSnapshotOrderByWithRelationInput | SpendingSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpendingSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpendingSnapshots
    **/
    _count?: true | SpendingSnapshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpendingSnapshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpendingSnapshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpendingSnapshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpendingSnapshotMaxAggregateInputType
  }

  export type GetSpendingSnapshotAggregateType<T extends SpendingSnapshotAggregateArgs> = {
        [P in keyof T & keyof AggregateSpendingSnapshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpendingSnapshot[P]>
      : GetScalarType<T[P], AggregateSpendingSnapshot[P]>
  }




  export type SpendingSnapshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingSnapshotWhereInput
    orderBy?: SpendingSnapshotOrderByWithAggregationInput | SpendingSnapshotOrderByWithAggregationInput[]
    by: SpendingSnapshotScalarFieldEnum[] | SpendingSnapshotScalarFieldEnum
    having?: SpendingSnapshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpendingSnapshotCountAggregateInputType | true
    _avg?: SpendingSnapshotAvgAggregateInputType
    _sum?: SpendingSnapshotSumAggregateInputType
    _min?: SpendingSnapshotMinAggregateInputType
    _max?: SpendingSnapshotMaxAggregateInputType
  }

  export type SpendingSnapshotGroupByOutputType = {
    id: string
    spendingDate: Date
    cumulativeAmount: Decimal
    snapshotAt: Date
    snapshotType: $Enums.SnapshotType
    createdAt: Date
    accountId: string
    invoiceMccId: string | null
    customerId: string | null
    createdById: string
    _count: SpendingSnapshotCountAggregateOutputType | null
    _avg: SpendingSnapshotAvgAggregateOutputType | null
    _sum: SpendingSnapshotSumAggregateOutputType | null
    _min: SpendingSnapshotMinAggregateOutputType | null
    _max: SpendingSnapshotMaxAggregateOutputType | null
  }

  type GetSpendingSnapshotGroupByPayload<T extends SpendingSnapshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpendingSnapshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpendingSnapshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpendingSnapshotGroupByOutputType[P]>
            : GetScalarType<T[P], SpendingSnapshotGroupByOutputType[P]>
        }
      >
    >


  export type SpendingSnapshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spendingDate?: boolean
    cumulativeAmount?: boolean
    snapshotAt?: boolean
    snapshotType?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    customerId?: boolean
    createdById?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | SpendingSnapshot$invoiceMccArgs<ExtArgs>
    customer?: boolean | SpendingSnapshot$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spendingSnapshot"]>

  export type SpendingSnapshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spendingDate?: boolean
    cumulativeAmount?: boolean
    snapshotAt?: boolean
    snapshotType?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    customerId?: boolean
    createdById?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | SpendingSnapshot$invoiceMccArgs<ExtArgs>
    customer?: boolean | SpendingSnapshot$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["spendingSnapshot"]>

  export type SpendingSnapshotSelectScalar = {
    id?: boolean
    spendingDate?: boolean
    cumulativeAmount?: boolean
    snapshotAt?: boolean
    snapshotType?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    customerId?: boolean
    createdById?: boolean
  }

  export type SpendingSnapshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | SpendingSnapshot$invoiceMccArgs<ExtArgs>
    customer?: boolean | SpendingSnapshot$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SpendingSnapshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | SpendingSnapshot$invoiceMccArgs<ExtArgs>
    customer?: boolean | SpendingSnapshot$customerArgs<ExtArgs>
    createdBy?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SpendingSnapshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpendingSnapshot"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      invoiceMcc: Prisma.$InvoiceMCCPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      createdBy: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spendingDate: Date
      cumulativeAmount: Prisma.Decimal
      snapshotAt: Date
      snapshotType: $Enums.SnapshotType
      createdAt: Date
      accountId: string
      invoiceMccId: string | null
      customerId: string | null
      createdById: string
    }, ExtArgs["result"]["spendingSnapshot"]>
    composites: {}
  }

  type SpendingSnapshotGetPayload<S extends boolean | null | undefined | SpendingSnapshotDefaultArgs> = $Result.GetResult<Prisma.$SpendingSnapshotPayload, S>

  type SpendingSnapshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpendingSnapshotFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpendingSnapshotCountAggregateInputType | true
    }

  export interface SpendingSnapshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpendingSnapshot'], meta: { name: 'SpendingSnapshot' } }
    /**
     * Find zero or one SpendingSnapshot that matches the filter.
     * @param {SpendingSnapshotFindUniqueArgs} args - Arguments to find a SpendingSnapshot
     * @example
     * // Get one SpendingSnapshot
     * const spendingSnapshot = await prisma.spendingSnapshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpendingSnapshotFindUniqueArgs>(args: SelectSubset<T, SpendingSnapshotFindUniqueArgs<ExtArgs>>): Prisma__SpendingSnapshotClient<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpendingSnapshot that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpendingSnapshotFindUniqueOrThrowArgs} args - Arguments to find a SpendingSnapshot
     * @example
     * // Get one SpendingSnapshot
     * const spendingSnapshot = await prisma.spendingSnapshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpendingSnapshotFindUniqueOrThrowArgs>(args: SelectSubset<T, SpendingSnapshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpendingSnapshotClient<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpendingSnapshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingSnapshotFindFirstArgs} args - Arguments to find a SpendingSnapshot
     * @example
     * // Get one SpendingSnapshot
     * const spendingSnapshot = await prisma.spendingSnapshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpendingSnapshotFindFirstArgs>(args?: SelectSubset<T, SpendingSnapshotFindFirstArgs<ExtArgs>>): Prisma__SpendingSnapshotClient<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpendingSnapshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingSnapshotFindFirstOrThrowArgs} args - Arguments to find a SpendingSnapshot
     * @example
     * // Get one SpendingSnapshot
     * const spendingSnapshot = await prisma.spendingSnapshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpendingSnapshotFindFirstOrThrowArgs>(args?: SelectSubset<T, SpendingSnapshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpendingSnapshotClient<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpendingSnapshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingSnapshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpendingSnapshots
     * const spendingSnapshots = await prisma.spendingSnapshot.findMany()
     * 
     * // Get first 10 SpendingSnapshots
     * const spendingSnapshots = await prisma.spendingSnapshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spendingSnapshotWithIdOnly = await prisma.spendingSnapshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpendingSnapshotFindManyArgs>(args?: SelectSubset<T, SpendingSnapshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpendingSnapshot.
     * @param {SpendingSnapshotCreateArgs} args - Arguments to create a SpendingSnapshot.
     * @example
     * // Create one SpendingSnapshot
     * const SpendingSnapshot = await prisma.spendingSnapshot.create({
     *   data: {
     *     // ... data to create a SpendingSnapshot
     *   }
     * })
     * 
     */
    create<T extends SpendingSnapshotCreateArgs>(args: SelectSubset<T, SpendingSnapshotCreateArgs<ExtArgs>>): Prisma__SpendingSnapshotClient<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpendingSnapshots.
     * @param {SpendingSnapshotCreateManyArgs} args - Arguments to create many SpendingSnapshots.
     * @example
     * // Create many SpendingSnapshots
     * const spendingSnapshot = await prisma.spendingSnapshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpendingSnapshotCreateManyArgs>(args?: SelectSubset<T, SpendingSnapshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpendingSnapshots and returns the data saved in the database.
     * @param {SpendingSnapshotCreateManyAndReturnArgs} args - Arguments to create many SpendingSnapshots.
     * @example
     * // Create many SpendingSnapshots
     * const spendingSnapshot = await prisma.spendingSnapshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpendingSnapshots and only return the `id`
     * const spendingSnapshotWithIdOnly = await prisma.spendingSnapshot.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpendingSnapshotCreateManyAndReturnArgs>(args?: SelectSubset<T, SpendingSnapshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpendingSnapshot.
     * @param {SpendingSnapshotDeleteArgs} args - Arguments to delete one SpendingSnapshot.
     * @example
     * // Delete one SpendingSnapshot
     * const SpendingSnapshot = await prisma.spendingSnapshot.delete({
     *   where: {
     *     // ... filter to delete one SpendingSnapshot
     *   }
     * })
     * 
     */
    delete<T extends SpendingSnapshotDeleteArgs>(args: SelectSubset<T, SpendingSnapshotDeleteArgs<ExtArgs>>): Prisma__SpendingSnapshotClient<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpendingSnapshot.
     * @param {SpendingSnapshotUpdateArgs} args - Arguments to update one SpendingSnapshot.
     * @example
     * // Update one SpendingSnapshot
     * const spendingSnapshot = await prisma.spendingSnapshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpendingSnapshotUpdateArgs>(args: SelectSubset<T, SpendingSnapshotUpdateArgs<ExtArgs>>): Prisma__SpendingSnapshotClient<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpendingSnapshots.
     * @param {SpendingSnapshotDeleteManyArgs} args - Arguments to filter SpendingSnapshots to delete.
     * @example
     * // Delete a few SpendingSnapshots
     * const { count } = await prisma.spendingSnapshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpendingSnapshotDeleteManyArgs>(args?: SelectSubset<T, SpendingSnapshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpendingSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingSnapshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpendingSnapshots
     * const spendingSnapshot = await prisma.spendingSnapshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpendingSnapshotUpdateManyArgs>(args: SelectSubset<T, SpendingSnapshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpendingSnapshot.
     * @param {SpendingSnapshotUpsertArgs} args - Arguments to update or create a SpendingSnapshot.
     * @example
     * // Update or create a SpendingSnapshot
     * const spendingSnapshot = await prisma.spendingSnapshot.upsert({
     *   create: {
     *     // ... data to create a SpendingSnapshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpendingSnapshot we want to update
     *   }
     * })
     */
    upsert<T extends SpendingSnapshotUpsertArgs>(args: SelectSubset<T, SpendingSnapshotUpsertArgs<ExtArgs>>): Prisma__SpendingSnapshotClient<$Result.GetResult<Prisma.$SpendingSnapshotPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpendingSnapshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingSnapshotCountArgs} args - Arguments to filter SpendingSnapshots to count.
     * @example
     * // Count the number of SpendingSnapshots
     * const count = await prisma.spendingSnapshot.count({
     *   where: {
     *     // ... the filter for the SpendingSnapshots we want to count
     *   }
     * })
    **/
    count<T extends SpendingSnapshotCountArgs>(
      args?: Subset<T, SpendingSnapshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpendingSnapshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpendingSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingSnapshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpendingSnapshotAggregateArgs>(args: Subset<T, SpendingSnapshotAggregateArgs>): Prisma.PrismaPromise<GetSpendingSnapshotAggregateType<T>>

    /**
     * Group by SpendingSnapshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingSnapshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpendingSnapshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpendingSnapshotGroupByArgs['orderBy'] }
        : { orderBy?: SpendingSnapshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpendingSnapshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpendingSnapshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpendingSnapshot model
   */
  readonly fields: SpendingSnapshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpendingSnapshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpendingSnapshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoiceMcc<T extends SpendingSnapshot$invoiceMccArgs<ExtArgs> = {}>(args?: Subset<T, SpendingSnapshot$invoiceMccArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    customer<T extends SpendingSnapshot$customerArgs<ExtArgs> = {}>(args?: Subset<T, SpendingSnapshot$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpendingSnapshot model
   */ 
  interface SpendingSnapshotFieldRefs {
    readonly id: FieldRef<"SpendingSnapshot", 'String'>
    readonly spendingDate: FieldRef<"SpendingSnapshot", 'DateTime'>
    readonly cumulativeAmount: FieldRef<"SpendingSnapshot", 'Decimal'>
    readonly snapshotAt: FieldRef<"SpendingSnapshot", 'DateTime'>
    readonly snapshotType: FieldRef<"SpendingSnapshot", 'SnapshotType'>
    readonly createdAt: FieldRef<"SpendingSnapshot", 'DateTime'>
    readonly accountId: FieldRef<"SpendingSnapshot", 'String'>
    readonly invoiceMccId: FieldRef<"SpendingSnapshot", 'String'>
    readonly customerId: FieldRef<"SpendingSnapshot", 'String'>
    readonly createdById: FieldRef<"SpendingSnapshot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpendingSnapshot findUnique
   */
  export type SpendingSnapshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendingSnapshot to fetch.
     */
    where: SpendingSnapshotWhereUniqueInput
  }

  /**
   * SpendingSnapshot findUniqueOrThrow
   */
  export type SpendingSnapshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendingSnapshot to fetch.
     */
    where: SpendingSnapshotWhereUniqueInput
  }

  /**
   * SpendingSnapshot findFirst
   */
  export type SpendingSnapshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendingSnapshot to fetch.
     */
    where?: SpendingSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingSnapshots to fetch.
     */
    orderBy?: SpendingSnapshotOrderByWithRelationInput | SpendingSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpendingSnapshots.
     */
    cursor?: SpendingSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpendingSnapshots.
     */
    distinct?: SpendingSnapshotScalarFieldEnum | SpendingSnapshotScalarFieldEnum[]
  }

  /**
   * SpendingSnapshot findFirstOrThrow
   */
  export type SpendingSnapshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendingSnapshot to fetch.
     */
    where?: SpendingSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingSnapshots to fetch.
     */
    orderBy?: SpendingSnapshotOrderByWithRelationInput | SpendingSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpendingSnapshots.
     */
    cursor?: SpendingSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingSnapshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpendingSnapshots.
     */
    distinct?: SpendingSnapshotScalarFieldEnum | SpendingSnapshotScalarFieldEnum[]
  }

  /**
   * SpendingSnapshot findMany
   */
  export type SpendingSnapshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * Filter, which SpendingSnapshots to fetch.
     */
    where?: SpendingSnapshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingSnapshots to fetch.
     */
    orderBy?: SpendingSnapshotOrderByWithRelationInput | SpendingSnapshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpendingSnapshots.
     */
    cursor?: SpendingSnapshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingSnapshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingSnapshots.
     */
    skip?: number
    distinct?: SpendingSnapshotScalarFieldEnum | SpendingSnapshotScalarFieldEnum[]
  }

  /**
   * SpendingSnapshot create
   */
  export type SpendingSnapshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to create a SpendingSnapshot.
     */
    data: XOR<SpendingSnapshotCreateInput, SpendingSnapshotUncheckedCreateInput>
  }

  /**
   * SpendingSnapshot createMany
   */
  export type SpendingSnapshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpendingSnapshots.
     */
    data: SpendingSnapshotCreateManyInput | SpendingSnapshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpendingSnapshot createManyAndReturn
   */
  export type SpendingSnapshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpendingSnapshots.
     */
    data: SpendingSnapshotCreateManyInput | SpendingSnapshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpendingSnapshot update
   */
  export type SpendingSnapshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * The data needed to update a SpendingSnapshot.
     */
    data: XOR<SpendingSnapshotUpdateInput, SpendingSnapshotUncheckedUpdateInput>
    /**
     * Choose, which SpendingSnapshot to update.
     */
    where: SpendingSnapshotWhereUniqueInput
  }

  /**
   * SpendingSnapshot updateMany
   */
  export type SpendingSnapshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpendingSnapshots.
     */
    data: XOR<SpendingSnapshotUpdateManyMutationInput, SpendingSnapshotUncheckedUpdateManyInput>
    /**
     * Filter which SpendingSnapshots to update
     */
    where?: SpendingSnapshotWhereInput
  }

  /**
   * SpendingSnapshot upsert
   */
  export type SpendingSnapshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * The filter to search for the SpendingSnapshot to update in case it exists.
     */
    where: SpendingSnapshotWhereUniqueInput
    /**
     * In case the SpendingSnapshot found by the `where` argument doesn't exist, create a new SpendingSnapshot with this data.
     */
    create: XOR<SpendingSnapshotCreateInput, SpendingSnapshotUncheckedCreateInput>
    /**
     * In case the SpendingSnapshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpendingSnapshotUpdateInput, SpendingSnapshotUncheckedUpdateInput>
  }

  /**
   * SpendingSnapshot delete
   */
  export type SpendingSnapshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
    /**
     * Filter which SpendingSnapshot to delete.
     */
    where: SpendingSnapshotWhereUniqueInput
  }

  /**
   * SpendingSnapshot deleteMany
   */
  export type SpendingSnapshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpendingSnapshots to delete
     */
    where?: SpendingSnapshotWhereInput
  }

  /**
   * SpendingSnapshot.invoiceMcc
   */
  export type SpendingSnapshot$invoiceMccArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    where?: InvoiceMCCWhereInput
  }

  /**
   * SpendingSnapshot.customer
   */
  export type SpendingSnapshot$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SpendingSnapshot without action
   */
  export type SpendingSnapshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingSnapshot
     */
    select?: SpendingSnapshotSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingSnapshotInclude<ExtArgs> | null
  }


  /**
   * Model SpendingRecord
   */

  export type AggregateSpendingRecord = {
    _count: SpendingRecordCountAggregateOutputType | null
    _avg: SpendingRecordAvgAggregateOutputType | null
    _sum: SpendingRecordSumAggregateOutputType | null
    _min: SpendingRecordMinAggregateOutputType | null
    _max: SpendingRecordMaxAggregateOutputType | null
  }

  export type SpendingRecordAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type SpendingRecordSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type SpendingRecordMinAggregateOutputType = {
    id: string | null
    spendingDate: Date | null
    amount: Decimal | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
    accountId: string | null
    invoiceMccId: string | null
    customerId: string | null
  }

  export type SpendingRecordMaxAggregateOutputType = {
    id: string | null
    spendingDate: Date | null
    amount: Decimal | null
    currency: string | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
    accountId: string | null
    invoiceMccId: string | null
    customerId: string | null
  }

  export type SpendingRecordCountAggregateOutputType = {
    id: number
    spendingDate: number
    amount: number
    currency: number
    periodStart: number
    periodEnd: number
    createdAt: number
    accountId: number
    invoiceMccId: number
    customerId: number
    _all: number
  }


  export type SpendingRecordAvgAggregateInputType = {
    amount?: true
  }

  export type SpendingRecordSumAggregateInputType = {
    amount?: true
  }

  export type SpendingRecordMinAggregateInputType = {
    id?: true
    spendingDate?: true
    amount?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    customerId?: true
  }

  export type SpendingRecordMaxAggregateInputType = {
    id?: true
    spendingDate?: true
    amount?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    customerId?: true
  }

  export type SpendingRecordCountAggregateInputType = {
    id?: true
    spendingDate?: true
    amount?: true
    currency?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    accountId?: true
    invoiceMccId?: true
    customerId?: true
    _all?: true
  }

  export type SpendingRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpendingRecord to aggregate.
     */
    where?: SpendingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingRecords to fetch.
     */
    orderBy?: SpendingRecordOrderByWithRelationInput | SpendingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SpendingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SpendingRecords
    **/
    _count?: true | SpendingRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SpendingRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SpendingRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SpendingRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SpendingRecordMaxAggregateInputType
  }

  export type GetSpendingRecordAggregateType<T extends SpendingRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateSpendingRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSpendingRecord[P]>
      : GetScalarType<T[P], AggregateSpendingRecord[P]>
  }




  export type SpendingRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SpendingRecordWhereInput
    orderBy?: SpendingRecordOrderByWithAggregationInput | SpendingRecordOrderByWithAggregationInput[]
    by: SpendingRecordScalarFieldEnum[] | SpendingRecordScalarFieldEnum
    having?: SpendingRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SpendingRecordCountAggregateInputType | true
    _avg?: SpendingRecordAvgAggregateInputType
    _sum?: SpendingRecordSumAggregateInputType
    _min?: SpendingRecordMinAggregateInputType
    _max?: SpendingRecordMaxAggregateInputType
  }

  export type SpendingRecordGroupByOutputType = {
    id: string
    spendingDate: Date
    amount: Decimal
    currency: string
    periodStart: Date
    periodEnd: Date
    createdAt: Date
    accountId: string
    invoiceMccId: string | null
    customerId: string | null
    _count: SpendingRecordCountAggregateOutputType | null
    _avg: SpendingRecordAvgAggregateOutputType | null
    _sum: SpendingRecordSumAggregateOutputType | null
    _min: SpendingRecordMinAggregateOutputType | null
    _max: SpendingRecordMaxAggregateOutputType | null
  }

  type GetSpendingRecordGroupByPayload<T extends SpendingRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SpendingRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SpendingRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SpendingRecordGroupByOutputType[P]>
            : GetScalarType<T[P], SpendingRecordGroupByOutputType[P]>
        }
      >
    >


  export type SpendingRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spendingDate?: boolean
    amount?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    customerId?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | SpendingRecord$invoiceMccArgs<ExtArgs>
    customer?: boolean | SpendingRecord$customerArgs<ExtArgs>
  }, ExtArgs["result"]["spendingRecord"]>

  export type SpendingRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    spendingDate?: boolean
    amount?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    customerId?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | SpendingRecord$invoiceMccArgs<ExtArgs>
    customer?: boolean | SpendingRecord$customerArgs<ExtArgs>
  }, ExtArgs["result"]["spendingRecord"]>

  export type SpendingRecordSelectScalar = {
    id?: boolean
    spendingDate?: boolean
    amount?: boolean
    currency?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    accountId?: boolean
    invoiceMccId?: boolean
    customerId?: boolean
  }

  export type SpendingRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | SpendingRecord$invoiceMccArgs<ExtArgs>
    customer?: boolean | SpendingRecord$customerArgs<ExtArgs>
  }
  export type SpendingRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    invoiceMcc?: boolean | SpendingRecord$invoiceMccArgs<ExtArgs>
    customer?: boolean | SpendingRecord$customerArgs<ExtArgs>
  }

  export type $SpendingRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SpendingRecord"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      invoiceMcc: Prisma.$InvoiceMCCPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      spendingDate: Date
      amount: Prisma.Decimal
      currency: string
      periodStart: Date
      periodEnd: Date
      createdAt: Date
      accountId: string
      invoiceMccId: string | null
      customerId: string | null
    }, ExtArgs["result"]["spendingRecord"]>
    composites: {}
  }

  type SpendingRecordGetPayload<S extends boolean | null | undefined | SpendingRecordDefaultArgs> = $Result.GetResult<Prisma.$SpendingRecordPayload, S>

  type SpendingRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SpendingRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SpendingRecordCountAggregateInputType | true
    }

  export interface SpendingRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SpendingRecord'], meta: { name: 'SpendingRecord' } }
    /**
     * Find zero or one SpendingRecord that matches the filter.
     * @param {SpendingRecordFindUniqueArgs} args - Arguments to find a SpendingRecord
     * @example
     * // Get one SpendingRecord
     * const spendingRecord = await prisma.spendingRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SpendingRecordFindUniqueArgs>(args: SelectSubset<T, SpendingRecordFindUniqueArgs<ExtArgs>>): Prisma__SpendingRecordClient<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SpendingRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SpendingRecordFindUniqueOrThrowArgs} args - Arguments to find a SpendingRecord
     * @example
     * // Get one SpendingRecord
     * const spendingRecord = await prisma.spendingRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SpendingRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, SpendingRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SpendingRecordClient<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SpendingRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingRecordFindFirstArgs} args - Arguments to find a SpendingRecord
     * @example
     * // Get one SpendingRecord
     * const spendingRecord = await prisma.spendingRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SpendingRecordFindFirstArgs>(args?: SelectSubset<T, SpendingRecordFindFirstArgs<ExtArgs>>): Prisma__SpendingRecordClient<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SpendingRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingRecordFindFirstOrThrowArgs} args - Arguments to find a SpendingRecord
     * @example
     * // Get one SpendingRecord
     * const spendingRecord = await prisma.spendingRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SpendingRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, SpendingRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__SpendingRecordClient<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SpendingRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SpendingRecords
     * const spendingRecords = await prisma.spendingRecord.findMany()
     * 
     * // Get first 10 SpendingRecords
     * const spendingRecords = await prisma.spendingRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const spendingRecordWithIdOnly = await prisma.spendingRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SpendingRecordFindManyArgs>(args?: SelectSubset<T, SpendingRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SpendingRecord.
     * @param {SpendingRecordCreateArgs} args - Arguments to create a SpendingRecord.
     * @example
     * // Create one SpendingRecord
     * const SpendingRecord = await prisma.spendingRecord.create({
     *   data: {
     *     // ... data to create a SpendingRecord
     *   }
     * })
     * 
     */
    create<T extends SpendingRecordCreateArgs>(args: SelectSubset<T, SpendingRecordCreateArgs<ExtArgs>>): Prisma__SpendingRecordClient<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SpendingRecords.
     * @param {SpendingRecordCreateManyArgs} args - Arguments to create many SpendingRecords.
     * @example
     * // Create many SpendingRecords
     * const spendingRecord = await prisma.spendingRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SpendingRecordCreateManyArgs>(args?: SelectSubset<T, SpendingRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SpendingRecords and returns the data saved in the database.
     * @param {SpendingRecordCreateManyAndReturnArgs} args - Arguments to create many SpendingRecords.
     * @example
     * // Create many SpendingRecords
     * const spendingRecord = await prisma.spendingRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SpendingRecords and only return the `id`
     * const spendingRecordWithIdOnly = await prisma.spendingRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SpendingRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, SpendingRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SpendingRecord.
     * @param {SpendingRecordDeleteArgs} args - Arguments to delete one SpendingRecord.
     * @example
     * // Delete one SpendingRecord
     * const SpendingRecord = await prisma.spendingRecord.delete({
     *   where: {
     *     // ... filter to delete one SpendingRecord
     *   }
     * })
     * 
     */
    delete<T extends SpendingRecordDeleteArgs>(args: SelectSubset<T, SpendingRecordDeleteArgs<ExtArgs>>): Prisma__SpendingRecordClient<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SpendingRecord.
     * @param {SpendingRecordUpdateArgs} args - Arguments to update one SpendingRecord.
     * @example
     * // Update one SpendingRecord
     * const spendingRecord = await prisma.spendingRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SpendingRecordUpdateArgs>(args: SelectSubset<T, SpendingRecordUpdateArgs<ExtArgs>>): Prisma__SpendingRecordClient<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SpendingRecords.
     * @param {SpendingRecordDeleteManyArgs} args - Arguments to filter SpendingRecords to delete.
     * @example
     * // Delete a few SpendingRecords
     * const { count } = await prisma.spendingRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SpendingRecordDeleteManyArgs>(args?: SelectSubset<T, SpendingRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SpendingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SpendingRecords
     * const spendingRecord = await prisma.spendingRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SpendingRecordUpdateManyArgs>(args: SelectSubset<T, SpendingRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SpendingRecord.
     * @param {SpendingRecordUpsertArgs} args - Arguments to update or create a SpendingRecord.
     * @example
     * // Update or create a SpendingRecord
     * const spendingRecord = await prisma.spendingRecord.upsert({
     *   create: {
     *     // ... data to create a SpendingRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SpendingRecord we want to update
     *   }
     * })
     */
    upsert<T extends SpendingRecordUpsertArgs>(args: SelectSubset<T, SpendingRecordUpsertArgs<ExtArgs>>): Prisma__SpendingRecordClient<$Result.GetResult<Prisma.$SpendingRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SpendingRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingRecordCountArgs} args - Arguments to filter SpendingRecords to count.
     * @example
     * // Count the number of SpendingRecords
     * const count = await prisma.spendingRecord.count({
     *   where: {
     *     // ... the filter for the SpendingRecords we want to count
     *   }
     * })
    **/
    count<T extends SpendingRecordCountArgs>(
      args?: Subset<T, SpendingRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SpendingRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SpendingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SpendingRecordAggregateArgs>(args: Subset<T, SpendingRecordAggregateArgs>): Prisma.PrismaPromise<GetSpendingRecordAggregateType<T>>

    /**
     * Group by SpendingRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SpendingRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SpendingRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SpendingRecordGroupByArgs['orderBy'] }
        : { orderBy?: SpendingRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SpendingRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSpendingRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SpendingRecord model
   */
  readonly fields: SpendingRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SpendingRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SpendingRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    invoiceMcc<T extends SpendingRecord$invoiceMccArgs<ExtArgs> = {}>(args?: Subset<T, SpendingRecord$invoiceMccArgs<ExtArgs>>): Prisma__InvoiceMCCClient<$Result.GetResult<Prisma.$InvoiceMCCPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    customer<T extends SpendingRecord$customerArgs<ExtArgs> = {}>(args?: Subset<T, SpendingRecord$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SpendingRecord model
   */ 
  interface SpendingRecordFieldRefs {
    readonly id: FieldRef<"SpendingRecord", 'String'>
    readonly spendingDate: FieldRef<"SpendingRecord", 'DateTime'>
    readonly amount: FieldRef<"SpendingRecord", 'Decimal'>
    readonly currency: FieldRef<"SpendingRecord", 'String'>
    readonly periodStart: FieldRef<"SpendingRecord", 'DateTime'>
    readonly periodEnd: FieldRef<"SpendingRecord", 'DateTime'>
    readonly createdAt: FieldRef<"SpendingRecord", 'DateTime'>
    readonly accountId: FieldRef<"SpendingRecord", 'String'>
    readonly invoiceMccId: FieldRef<"SpendingRecord", 'String'>
    readonly customerId: FieldRef<"SpendingRecord", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SpendingRecord findUnique
   */
  export type SpendingRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * Filter, which SpendingRecord to fetch.
     */
    where: SpendingRecordWhereUniqueInput
  }

  /**
   * SpendingRecord findUniqueOrThrow
   */
  export type SpendingRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * Filter, which SpendingRecord to fetch.
     */
    where: SpendingRecordWhereUniqueInput
  }

  /**
   * SpendingRecord findFirst
   */
  export type SpendingRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * Filter, which SpendingRecord to fetch.
     */
    where?: SpendingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingRecords to fetch.
     */
    orderBy?: SpendingRecordOrderByWithRelationInput | SpendingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpendingRecords.
     */
    cursor?: SpendingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpendingRecords.
     */
    distinct?: SpendingRecordScalarFieldEnum | SpendingRecordScalarFieldEnum[]
  }

  /**
   * SpendingRecord findFirstOrThrow
   */
  export type SpendingRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * Filter, which SpendingRecord to fetch.
     */
    where?: SpendingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingRecords to fetch.
     */
    orderBy?: SpendingRecordOrderByWithRelationInput | SpendingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SpendingRecords.
     */
    cursor?: SpendingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SpendingRecords.
     */
    distinct?: SpendingRecordScalarFieldEnum | SpendingRecordScalarFieldEnum[]
  }

  /**
   * SpendingRecord findMany
   */
  export type SpendingRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * Filter, which SpendingRecords to fetch.
     */
    where?: SpendingRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SpendingRecords to fetch.
     */
    orderBy?: SpendingRecordOrderByWithRelationInput | SpendingRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SpendingRecords.
     */
    cursor?: SpendingRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SpendingRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SpendingRecords.
     */
    skip?: number
    distinct?: SpendingRecordScalarFieldEnum | SpendingRecordScalarFieldEnum[]
  }

  /**
   * SpendingRecord create
   */
  export type SpendingRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a SpendingRecord.
     */
    data: XOR<SpendingRecordCreateInput, SpendingRecordUncheckedCreateInput>
  }

  /**
   * SpendingRecord createMany
   */
  export type SpendingRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SpendingRecords.
     */
    data: SpendingRecordCreateManyInput | SpendingRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SpendingRecord createManyAndReturn
   */
  export type SpendingRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SpendingRecords.
     */
    data: SpendingRecordCreateManyInput | SpendingRecordCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SpendingRecord update
   */
  export type SpendingRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a SpendingRecord.
     */
    data: XOR<SpendingRecordUpdateInput, SpendingRecordUncheckedUpdateInput>
    /**
     * Choose, which SpendingRecord to update.
     */
    where: SpendingRecordWhereUniqueInput
  }

  /**
   * SpendingRecord updateMany
   */
  export type SpendingRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SpendingRecords.
     */
    data: XOR<SpendingRecordUpdateManyMutationInput, SpendingRecordUncheckedUpdateManyInput>
    /**
     * Filter which SpendingRecords to update
     */
    where?: SpendingRecordWhereInput
  }

  /**
   * SpendingRecord upsert
   */
  export type SpendingRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the SpendingRecord to update in case it exists.
     */
    where: SpendingRecordWhereUniqueInput
    /**
     * In case the SpendingRecord found by the `where` argument doesn't exist, create a new SpendingRecord with this data.
     */
    create: XOR<SpendingRecordCreateInput, SpendingRecordUncheckedCreateInput>
    /**
     * In case the SpendingRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SpendingRecordUpdateInput, SpendingRecordUncheckedUpdateInput>
  }

  /**
   * SpendingRecord delete
   */
  export type SpendingRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
    /**
     * Filter which SpendingRecord to delete.
     */
    where: SpendingRecordWhereUniqueInput
  }

  /**
   * SpendingRecord deleteMany
   */
  export type SpendingRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SpendingRecords to delete
     */
    where?: SpendingRecordWhereInput
  }

  /**
   * SpendingRecord.invoiceMcc
   */
  export type SpendingRecord$invoiceMccArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceMCC
     */
    select?: InvoiceMCCSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceMCCInclude<ExtArgs> | null
    where?: InvoiceMCCWhereInput
  }

  /**
   * SpendingRecord.customer
   */
  export type SpendingRecord$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * SpendingRecord without action
   */
  export type SpendingRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SpendingRecord
     */
    select?: SpendingRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SpendingRecordInclude<ExtArgs> | null
  }


  /**
   * Model ActivityLog
   */

  export type AggregateActivityLog = {
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  export type ActivityLogMinAggregateOutputType = {
    id: string | null
    action: $Enums.ActivityAction | null
    entityType: string | null
    entityId: string | null
    description: string | null
    ipAddress: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type ActivityLogMaxAggregateOutputType = {
    id: string | null
    action: $Enums.ActivityAction | null
    entityType: string | null
    entityId: string | null
    description: string | null
    ipAddress: string | null
    createdAt: Date | null
    userId: string | null
  }

  export type ActivityLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    oldValues: number
    newValues: number
    description: number
    ipAddress: number
    createdAt: number
    userId: number
    _all: number
  }


  export type ActivityLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    ipAddress?: true
    createdAt?: true
    userId?: true
  }

  export type ActivityLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    description?: true
    ipAddress?: true
    createdAt?: true
    userId?: true
  }

  export type ActivityLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValues?: true
    newValues?: true
    description?: true
    ipAddress?: true
    createdAt?: true
    userId?: true
    _all?: true
  }

  export type ActivityLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLog to aggregate.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ActivityLogs
    **/
    _count?: true | ActivityLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ActivityLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ActivityLogMaxAggregateInputType
  }

  export type GetActivityLogAggregateType<T extends ActivityLogAggregateArgs> = {
        [P in keyof T & keyof AggregateActivityLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateActivityLog[P]>
      : GetScalarType<T[P], AggregateActivityLog[P]>
  }




  export type ActivityLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ActivityLogWhereInput
    orderBy?: ActivityLogOrderByWithAggregationInput | ActivityLogOrderByWithAggregationInput[]
    by: ActivityLogScalarFieldEnum[] | ActivityLogScalarFieldEnum
    having?: ActivityLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ActivityLogCountAggregateInputType | true
    _min?: ActivityLogMinAggregateInputType
    _max?: ActivityLogMaxAggregateInputType
  }

  export type ActivityLogGroupByOutputType = {
    id: string
    action: $Enums.ActivityAction
    entityType: string
    entityId: string
    oldValues: JsonValue | null
    newValues: JsonValue | null
    description: string | null
    ipAddress: string | null
    createdAt: Date
    userId: string
    _count: ActivityLogCountAggregateOutputType | null
    _min: ActivityLogMinAggregateOutputType | null
    _max: ActivityLogMaxAggregateOutputType | null
  }

  type GetActivityLogGroupByPayload<T extends ActivityLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ActivityLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ActivityLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
            : GetScalarType<T[P], ActivityLogGroupByOutputType[P]>
        }
      >
    >


  export type ActivityLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    description?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    description?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["activityLog"]>

  export type ActivityLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValues?: boolean
    newValues?: boolean
    description?: boolean
    ipAddress?: boolean
    createdAt?: boolean
    userId?: boolean
  }

  export type ActivityLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ActivityLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ActivityLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ActivityLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: $Enums.ActivityAction
      entityType: string
      entityId: string
      oldValues: Prisma.JsonValue | null
      newValues: Prisma.JsonValue | null
      description: string | null
      ipAddress: string | null
      createdAt: Date
      userId: string
    }, ExtArgs["result"]["activityLog"]>
    composites: {}
  }

  type ActivityLogGetPayload<S extends boolean | null | undefined | ActivityLogDefaultArgs> = $Result.GetResult<Prisma.$ActivityLogPayload, S>

  type ActivityLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ActivityLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ActivityLogCountAggregateInputType | true
    }

  export interface ActivityLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ActivityLog'], meta: { name: 'ActivityLog' } }
    /**
     * Find zero or one ActivityLog that matches the filter.
     * @param {ActivityLogFindUniqueArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ActivityLogFindUniqueArgs>(args: SelectSubset<T, ActivityLogFindUniqueArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ActivityLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ActivityLogFindUniqueOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ActivityLogFindUniqueOrThrowArgs>(args: SelectSubset<T, ActivityLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ActivityLogFindFirstArgs>(args?: SelectSubset<T, ActivityLogFindFirstArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ActivityLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindFirstOrThrowArgs} args - Arguments to find a ActivityLog
     * @example
     * // Get one ActivityLog
     * const activityLog = await prisma.activityLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ActivityLogFindFirstOrThrowArgs>(args?: SelectSubset<T, ActivityLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ActivityLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany()
     * 
     * // Get first 10 ActivityLogs
     * const activityLogs = await prisma.activityLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ActivityLogFindManyArgs>(args?: SelectSubset<T, ActivityLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ActivityLog.
     * @param {ActivityLogCreateArgs} args - Arguments to create a ActivityLog.
     * @example
     * // Create one ActivityLog
     * const ActivityLog = await prisma.activityLog.create({
     *   data: {
     *     // ... data to create a ActivityLog
     *   }
     * })
     * 
     */
    create<T extends ActivityLogCreateArgs>(args: SelectSubset<T, ActivityLogCreateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ActivityLogs.
     * @param {ActivityLogCreateManyArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ActivityLogCreateManyArgs>(args?: SelectSubset<T, ActivityLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ActivityLogs and returns the data saved in the database.
     * @param {ActivityLogCreateManyAndReturnArgs} args - Arguments to create many ActivityLogs.
     * @example
     * // Create many ActivityLogs
     * const activityLog = await prisma.activityLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ActivityLogs and only return the `id`
     * const activityLogWithIdOnly = await prisma.activityLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ActivityLogCreateManyAndReturnArgs>(args?: SelectSubset<T, ActivityLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ActivityLog.
     * @param {ActivityLogDeleteArgs} args - Arguments to delete one ActivityLog.
     * @example
     * // Delete one ActivityLog
     * const ActivityLog = await prisma.activityLog.delete({
     *   where: {
     *     // ... filter to delete one ActivityLog
     *   }
     * })
     * 
     */
    delete<T extends ActivityLogDeleteArgs>(args: SelectSubset<T, ActivityLogDeleteArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ActivityLog.
     * @param {ActivityLogUpdateArgs} args - Arguments to update one ActivityLog.
     * @example
     * // Update one ActivityLog
     * const activityLog = await prisma.activityLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ActivityLogUpdateArgs>(args: SelectSubset<T, ActivityLogUpdateArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ActivityLogs.
     * @param {ActivityLogDeleteManyArgs} args - Arguments to filter ActivityLogs to delete.
     * @example
     * // Delete a few ActivityLogs
     * const { count } = await prisma.activityLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ActivityLogDeleteManyArgs>(args?: SelectSubset<T, ActivityLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ActivityLogs
     * const activityLog = await prisma.activityLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ActivityLogUpdateManyArgs>(args: SelectSubset<T, ActivityLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ActivityLog.
     * @param {ActivityLogUpsertArgs} args - Arguments to update or create a ActivityLog.
     * @example
     * // Update or create a ActivityLog
     * const activityLog = await prisma.activityLog.upsert({
     *   create: {
     *     // ... data to create a ActivityLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ActivityLog we want to update
     *   }
     * })
     */
    upsert<T extends ActivityLogUpsertArgs>(args: SelectSubset<T, ActivityLogUpsertArgs<ExtArgs>>): Prisma__ActivityLogClient<$Result.GetResult<Prisma.$ActivityLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ActivityLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogCountArgs} args - Arguments to filter ActivityLogs to count.
     * @example
     * // Count the number of ActivityLogs
     * const count = await prisma.activityLog.count({
     *   where: {
     *     // ... the filter for the ActivityLogs we want to count
     *   }
     * })
    **/
    count<T extends ActivityLogCountArgs>(
      args?: Subset<T, ActivityLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ActivityLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ActivityLogAggregateArgs>(args: Subset<T, ActivityLogAggregateArgs>): Prisma.PrismaPromise<GetActivityLogAggregateType<T>>

    /**
     * Group by ActivityLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ActivityLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ActivityLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ActivityLogGroupByArgs['orderBy'] }
        : { orderBy?: ActivityLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ActivityLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetActivityLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ActivityLog model
   */
  readonly fields: ActivityLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ActivityLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ActivityLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ActivityLog model
   */ 
  interface ActivityLogFieldRefs {
    readonly id: FieldRef<"ActivityLog", 'String'>
    readonly action: FieldRef<"ActivityLog", 'ActivityAction'>
    readonly entityType: FieldRef<"ActivityLog", 'String'>
    readonly entityId: FieldRef<"ActivityLog", 'String'>
    readonly oldValues: FieldRef<"ActivityLog", 'Json'>
    readonly newValues: FieldRef<"ActivityLog", 'Json'>
    readonly description: FieldRef<"ActivityLog", 'String'>
    readonly ipAddress: FieldRef<"ActivityLog", 'String'>
    readonly createdAt: FieldRef<"ActivityLog", 'DateTime'>
    readonly userId: FieldRef<"ActivityLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ActivityLog findUnique
   */
  export type ActivityLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findUniqueOrThrow
   */
  export type ActivityLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog findFirst
   */
  export type ActivityLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findFirstOrThrow
   */
  export type ActivityLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLog to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ActivityLogs.
     */
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog findMany
   */
  export type ActivityLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter, which ActivityLogs to fetch.
     */
    where?: ActivityLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ActivityLogs to fetch.
     */
    orderBy?: ActivityLogOrderByWithRelationInput | ActivityLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ActivityLogs.
     */
    cursor?: ActivityLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ActivityLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ActivityLogs.
     */
    skip?: number
    distinct?: ActivityLogScalarFieldEnum | ActivityLogScalarFieldEnum[]
  }

  /**
   * ActivityLog create
   */
  export type ActivityLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to create a ActivityLog.
     */
    data: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
  }

  /**
   * ActivityLog createMany
   */
  export type ActivityLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ActivityLog createManyAndReturn
   */
  export type ActivityLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ActivityLogs.
     */
    data: ActivityLogCreateManyInput | ActivityLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ActivityLog update
   */
  export type ActivityLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The data needed to update a ActivityLog.
     */
    data: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
    /**
     * Choose, which ActivityLog to update.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog updateMany
   */
  export type ActivityLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ActivityLogs.
     */
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyInput>
    /**
     * Filter which ActivityLogs to update
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog upsert
   */
  export type ActivityLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * The filter to search for the ActivityLog to update in case it exists.
     */
    where: ActivityLogWhereUniqueInput
    /**
     * In case the ActivityLog found by the `where` argument doesn't exist, create a new ActivityLog with this data.
     */
    create: XOR<ActivityLogCreateInput, ActivityLogUncheckedCreateInput>
    /**
     * In case the ActivityLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ActivityLogUpdateInput, ActivityLogUncheckedUpdateInput>
  }

  /**
   * ActivityLog delete
   */
  export type ActivityLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
    /**
     * Filter which ActivityLog to delete.
     */
    where: ActivityLogWhereUniqueInput
  }

  /**
   * ActivityLog deleteMany
   */
  export type ActivityLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ActivityLogs to delete
     */
    where?: ActivityLogWhereInput
  }

  /**
   * ActivityLog without action
   */
  export type ActivityLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ActivityLog
     */
    select?: ActivityLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ActivityLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    role: 'role',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PartnerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactInfo: 'contactInfo',
    type: 'type',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type PartnerScalarFieldEnum = (typeof PartnerScalarFieldEnum)[keyof typeof PartnerScalarFieldEnum]


  export const AccountBatchScalarFieldEnum: {
    id: 'id',
    mccAccountName: 'mccAccountName',
    mccAccountId: 'mccAccountId',
    isPrelinked: 'isPrelinked',
    status: 'status',
    totalAccounts: 'totalAccounts',
    liveAccounts: 'liveAccounts',
    timezone: 'timezone',
    year: 'year',
    readiness: 'readiness',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    partnerId: 'partnerId',
    createdById: 'createdById'
  };

  export type AccountBatchScalarFieldEnum = (typeof AccountBatchScalarFieldEnum)[keyof typeof AccountBatchScalarFieldEnum]


  export const InvoiceMCCScalarFieldEnum: {
    id: 'id',
    name: 'name',
    mccInvoiceId: 'mccInvoiceId',
    status: 'status',
    creditStatus: 'creditStatus',
    linkedAccountsCount: 'linkedAccountsCount',
    activeAccountsCount: 'activeAccountsCount',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    partnerId: 'partnerId',
    createdById: 'createdById'
  };

  export type InvoiceMCCScalarFieldEnum = (typeof InvoiceMCCScalarFieldEnum)[keyof typeof InvoiceMCCScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contactInfo: 'contactInfo',
    status: 'status',
    totalSpending: 'totalSpending',
    totalAccounts: 'totalAccounts',
    activeAccounts: 'activeAccounts',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedStaffId: 'assignedStaffId'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    googleAccountId: 'googleAccountId',
    accountName: 'accountName',
    status: 'status',
    currency: 'currency',
    timezone: 'timezone',
    mccAccountName: 'mccAccountName',
    mccAccountId: 'mccAccountId',
    totalSpending: 'totalSpending',
    lastSynced: 'lastSynced',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    batchId: 'batchId',
    currentMiId: 'currentMiId',
    currentMcId: 'currentMcId'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountMIHistoryScalarFieldEnum: {
    id: 'id',
    linkedAt: 'linkedAt',
    unlinkedAt: 'unlinkedAt',
    reason: 'reason',
    notes: 'notes',
    createdAt: 'createdAt',
    accountId: 'accountId',
    invoiceMccId: 'invoiceMccId',
    linkedById: 'linkedById',
    unlinkedById: 'unlinkedById'
  };

  export type AccountMIHistoryScalarFieldEnum = (typeof AccountMIHistoryScalarFieldEnum)[keyof typeof AccountMIHistoryScalarFieldEnum]


  export const AccountMCHistoryScalarFieldEnum: {
    id: 'id',
    assignedAt: 'assignedAt',
    unassignedAt: 'unassignedAt',
    reason: 'reason',
    notes: 'notes',
    createdAt: 'createdAt',
    accountId: 'accountId',
    customerId: 'customerId',
    assignedById: 'assignedById',
    unassignedById: 'unassignedById'
  };

  export type AccountMCHistoryScalarFieldEnum = (typeof AccountMCHistoryScalarFieldEnum)[keyof typeof AccountMCHistoryScalarFieldEnum]


  export const SpendingSnapshotScalarFieldEnum: {
    id: 'id',
    spendingDate: 'spendingDate',
    cumulativeAmount: 'cumulativeAmount',
    snapshotAt: 'snapshotAt',
    snapshotType: 'snapshotType',
    createdAt: 'createdAt',
    accountId: 'accountId',
    invoiceMccId: 'invoiceMccId',
    customerId: 'customerId',
    createdById: 'createdById'
  };

  export type SpendingSnapshotScalarFieldEnum = (typeof SpendingSnapshotScalarFieldEnum)[keyof typeof SpendingSnapshotScalarFieldEnum]


  export const SpendingRecordScalarFieldEnum: {
    id: 'id',
    spendingDate: 'spendingDate',
    amount: 'amount',
    currency: 'currency',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    createdAt: 'createdAt',
    accountId: 'accountId',
    invoiceMccId: 'invoiceMccId',
    customerId: 'customerId'
  };

  export type SpendingRecordScalarFieldEnum = (typeof SpendingRecordScalarFieldEnum)[keyof typeof SpendingRecordScalarFieldEnum]


  export const ActivityLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValues: 'oldValues',
    newValues: 'newValues',
    description: 'description',
    ipAddress: 'ipAddress',
    createdAt: 'createdAt',
    userId: 'userId'
  };

  export type ActivityLogScalarFieldEnum = (typeof ActivityLogScalarFieldEnum)[keyof typeof ActivityLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PartnerType'
   */
  export type EnumPartnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerType'>
    


  /**
   * Reference to a field of type 'PartnerType[]'
   */
  export type ListEnumPartnerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PartnerType[]'>
    


  /**
   * Reference to a field of type 'BatchStatus'
   */
  export type EnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus'>
    


  /**
   * Reference to a field of type 'BatchStatus[]'
   */
  export type ListEnumBatchStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BatchStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'InvoiceMCCStatus'
   */
  export type EnumInvoiceMCCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceMCCStatus'>
    


  /**
   * Reference to a field of type 'InvoiceMCCStatus[]'
   */
  export type ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceMCCStatus[]'>
    


  /**
   * Reference to a field of type 'CreditStatus'
   */
  export type EnumCreditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditStatus'>
    


  /**
   * Reference to a field of type 'CreditStatus[]'
   */
  export type ListEnumCreditStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CreditStatus[]'>
    


  /**
   * Reference to a field of type 'CustomerStatus'
   */
  export type EnumCustomerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerStatus'>
    


  /**
   * Reference to a field of type 'CustomerStatus[]'
   */
  export type ListEnumCustomerStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CustomerStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'AccountStatus'
   */
  export type EnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus'>
    


  /**
   * Reference to a field of type 'AccountStatus[]'
   */
  export type ListEnumAccountStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountStatus[]'>
    


  /**
   * Reference to a field of type 'HistoryReason'
   */
  export type EnumHistoryReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HistoryReason'>
    


  /**
   * Reference to a field of type 'HistoryReason[]'
   */
  export type ListEnumHistoryReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HistoryReason[]'>
    


  /**
   * Reference to a field of type 'SnapshotType'
   */
  export type EnumSnapshotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnapshotType'>
    


  /**
   * Reference to a field of type 'SnapshotType[]'
   */
  export type ListEnumSnapshotTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SnapshotType[]'>
    


  /**
   * Reference to a field of type 'ActivityAction'
   */
  export type EnumActivityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityAction'>
    


  /**
   * Reference to a field of type 'ActivityAction[]'
   */
  export type ListEnumActivityActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ActivityAction[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    customersAssigned?: CustomerListRelationFilter
    batchesCreated?: AccountBatchListRelationFilter
    invoiceMCCsCreated?: InvoiceMCCListRelationFilter
    miHistoriesLinked?: AccountMIHistoryListRelationFilter
    miHistoriesUnlinked?: AccountMIHistoryListRelationFilter
    mcHistoriesAssigned?: AccountMCHistoryListRelationFilter
    mcHistoriesUnassigned?: AccountMCHistoryListRelationFilter
    snapshots?: SpendingSnapshotListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    customersAssigned?: CustomerOrderByRelationAggregateInput
    batchesCreated?: AccountBatchOrderByRelationAggregateInput
    invoiceMCCsCreated?: InvoiceMCCOrderByRelationAggregateInput
    miHistoriesLinked?: AccountMIHistoryOrderByRelationAggregateInput
    miHistoriesUnlinked?: AccountMIHistoryOrderByRelationAggregateInput
    mcHistoriesAssigned?: AccountMCHistoryOrderByRelationAggregateInput
    mcHistoriesUnassigned?: AccountMCHistoryOrderByRelationAggregateInput
    snapshots?: SpendingSnapshotOrderByRelationAggregateInput
    activityLogs?: ActivityLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    customersAssigned?: CustomerListRelationFilter
    batchesCreated?: AccountBatchListRelationFilter
    invoiceMCCsCreated?: InvoiceMCCListRelationFilter
    miHistoriesLinked?: AccountMIHistoryListRelationFilter
    miHistoriesUnlinked?: AccountMIHistoryListRelationFilter
    mcHistoriesAssigned?: AccountMCHistoryListRelationFilter
    mcHistoriesUnassigned?: AccountMCHistoryListRelationFilter
    snapshots?: SpendingSnapshotListRelationFilter
    activityLogs?: ActivityLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PartnerWhereInput = {
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    id?: StringFilter<"Partner"> | string
    name?: StringFilter<"Partner"> | string
    contactInfo?: StringNullableFilter<"Partner"> | string | null
    type?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    notes?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    batches?: AccountBatchListRelationFilter
    invoiceMCCs?: InvoiceMCCListRelationFilter
  }

  export type PartnerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    type?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    batches?: AccountBatchOrderByRelationAggregateInput
    invoiceMCCs?: InvoiceMCCOrderByRelationAggregateInput
  }

  export type PartnerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PartnerWhereInput | PartnerWhereInput[]
    OR?: PartnerWhereInput[]
    NOT?: PartnerWhereInput | PartnerWhereInput[]
    name?: StringFilter<"Partner"> | string
    contactInfo?: StringNullableFilter<"Partner"> | string | null
    type?: EnumPartnerTypeFilter<"Partner"> | $Enums.PartnerType
    notes?: StringNullableFilter<"Partner"> | string | null
    createdAt?: DateTimeFilter<"Partner"> | Date | string
    batches?: AccountBatchListRelationFilter
    invoiceMCCs?: InvoiceMCCListRelationFilter
  }, "id">

  export type PartnerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    type?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PartnerCountOrderByAggregateInput
    _max?: PartnerMaxOrderByAggregateInput
    _min?: PartnerMinOrderByAggregateInput
  }

  export type PartnerScalarWhereWithAggregatesInput = {
    AND?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    OR?: PartnerScalarWhereWithAggregatesInput[]
    NOT?: PartnerScalarWhereWithAggregatesInput | PartnerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Partner"> | string
    name?: StringWithAggregatesFilter<"Partner"> | string
    contactInfo?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    type?: EnumPartnerTypeWithAggregatesFilter<"Partner"> | $Enums.PartnerType
    notes?: StringNullableWithAggregatesFilter<"Partner"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Partner"> | Date | string
  }

  export type AccountBatchWhereInput = {
    AND?: AccountBatchWhereInput | AccountBatchWhereInput[]
    OR?: AccountBatchWhereInput[]
    NOT?: AccountBatchWhereInput | AccountBatchWhereInput[]
    id?: StringFilter<"AccountBatch"> | string
    mccAccountName?: StringNullableFilter<"AccountBatch"> | string | null
    mccAccountId?: StringNullableFilter<"AccountBatch"> | string | null
    isPrelinked?: BoolFilter<"AccountBatch"> | boolean
    status?: EnumBatchStatusFilter<"AccountBatch"> | $Enums.BatchStatus
    totalAccounts?: IntFilter<"AccountBatch"> | number
    liveAccounts?: IntFilter<"AccountBatch"> | number
    timezone?: StringNullableFilter<"AccountBatch"> | string | null
    year?: IntNullableFilter<"AccountBatch"> | number | null
    readiness?: IntFilter<"AccountBatch"> | number
    notes?: StringNullableFilter<"AccountBatch"> | string | null
    createdAt?: DateTimeFilter<"AccountBatch"> | Date | string
    updatedAt?: DateTimeFilter<"AccountBatch"> | Date | string
    partnerId?: StringNullableFilter<"AccountBatch"> | string | null
    createdById?: StringFilter<"AccountBatch"> | string
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    accounts?: AccountListRelationFilter
  }

  export type AccountBatchOrderByWithRelationInput = {
    id?: SortOrder
    mccAccountName?: SortOrderInput | SortOrder
    mccAccountId?: SortOrderInput | SortOrder
    isPrelinked?: SortOrder
    status?: SortOrder
    totalAccounts?: SortOrder
    liveAccounts?: SortOrder
    timezone?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    readiness?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    partner?: PartnerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
  }

  export type AccountBatchWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountBatchWhereInput | AccountBatchWhereInput[]
    OR?: AccountBatchWhereInput[]
    NOT?: AccountBatchWhereInput | AccountBatchWhereInput[]
    mccAccountName?: StringNullableFilter<"AccountBatch"> | string | null
    mccAccountId?: StringNullableFilter<"AccountBatch"> | string | null
    isPrelinked?: BoolFilter<"AccountBatch"> | boolean
    status?: EnumBatchStatusFilter<"AccountBatch"> | $Enums.BatchStatus
    totalAccounts?: IntFilter<"AccountBatch"> | number
    liveAccounts?: IntFilter<"AccountBatch"> | number
    timezone?: StringNullableFilter<"AccountBatch"> | string | null
    year?: IntNullableFilter<"AccountBatch"> | number | null
    readiness?: IntFilter<"AccountBatch"> | number
    notes?: StringNullableFilter<"AccountBatch"> | string | null
    createdAt?: DateTimeFilter<"AccountBatch"> | Date | string
    updatedAt?: DateTimeFilter<"AccountBatch"> | Date | string
    partnerId?: StringNullableFilter<"AccountBatch"> | string | null
    createdById?: StringFilter<"AccountBatch"> | string
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    accounts?: AccountListRelationFilter
  }, "id">

  export type AccountBatchOrderByWithAggregationInput = {
    id?: SortOrder
    mccAccountName?: SortOrderInput | SortOrder
    mccAccountId?: SortOrderInput | SortOrder
    isPrelinked?: SortOrder
    status?: SortOrder
    totalAccounts?: SortOrder
    liveAccounts?: SortOrder
    timezone?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    readiness?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    _count?: AccountBatchCountOrderByAggregateInput
    _avg?: AccountBatchAvgOrderByAggregateInput
    _max?: AccountBatchMaxOrderByAggregateInput
    _min?: AccountBatchMinOrderByAggregateInput
    _sum?: AccountBatchSumOrderByAggregateInput
  }

  export type AccountBatchScalarWhereWithAggregatesInput = {
    AND?: AccountBatchScalarWhereWithAggregatesInput | AccountBatchScalarWhereWithAggregatesInput[]
    OR?: AccountBatchScalarWhereWithAggregatesInput[]
    NOT?: AccountBatchScalarWhereWithAggregatesInput | AccountBatchScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountBatch"> | string
    mccAccountName?: StringNullableWithAggregatesFilter<"AccountBatch"> | string | null
    mccAccountId?: StringNullableWithAggregatesFilter<"AccountBatch"> | string | null
    isPrelinked?: BoolWithAggregatesFilter<"AccountBatch"> | boolean
    status?: EnumBatchStatusWithAggregatesFilter<"AccountBatch"> | $Enums.BatchStatus
    totalAccounts?: IntWithAggregatesFilter<"AccountBatch"> | number
    liveAccounts?: IntWithAggregatesFilter<"AccountBatch"> | number
    timezone?: StringNullableWithAggregatesFilter<"AccountBatch"> | string | null
    year?: IntNullableWithAggregatesFilter<"AccountBatch"> | number | null
    readiness?: IntWithAggregatesFilter<"AccountBatch"> | number
    notes?: StringNullableWithAggregatesFilter<"AccountBatch"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AccountBatch"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccountBatch"> | Date | string
    partnerId?: StringNullableWithAggregatesFilter<"AccountBatch"> | string | null
    createdById?: StringWithAggregatesFilter<"AccountBatch"> | string
  }

  export type InvoiceMCCWhereInput = {
    AND?: InvoiceMCCWhereInput | InvoiceMCCWhereInput[]
    OR?: InvoiceMCCWhereInput[]
    NOT?: InvoiceMCCWhereInput | InvoiceMCCWhereInput[]
    id?: StringFilter<"InvoiceMCC"> | string
    name?: StringFilter<"InvoiceMCC"> | string
    mccInvoiceId?: StringFilter<"InvoiceMCC"> | string
    status?: EnumInvoiceMCCStatusFilter<"InvoiceMCC"> | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFilter<"InvoiceMCC"> | $Enums.CreditStatus
    linkedAccountsCount?: IntFilter<"InvoiceMCC"> | number
    activeAccountsCount?: IntFilter<"InvoiceMCC"> | number
    notes?: StringNullableFilter<"InvoiceMCC"> | string | null
    createdAt?: DateTimeFilter<"InvoiceMCC"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceMCC"> | Date | string
    partnerId?: StringNullableFilter<"InvoiceMCC"> | string | null
    createdById?: StringFilter<"InvoiceMCC"> | string
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    accounts?: AccountListRelationFilter
    miHistories?: AccountMIHistoryListRelationFilter
    snapshots?: SpendingSnapshotListRelationFilter
    spendingRecords?: SpendingRecordListRelationFilter
  }

  export type InvoiceMCCOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    mccInvoiceId?: SortOrder
    status?: SortOrder
    creditStatus?: SortOrder
    linkedAccountsCount?: SortOrder
    activeAccountsCount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    partner?: PartnerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    miHistories?: AccountMIHistoryOrderByRelationAggregateInput
    snapshots?: SpendingSnapshotOrderByRelationAggregateInput
    spendingRecords?: SpendingRecordOrderByRelationAggregateInput
  }

  export type InvoiceMCCWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    mccInvoiceId?: string
    AND?: InvoiceMCCWhereInput | InvoiceMCCWhereInput[]
    OR?: InvoiceMCCWhereInput[]
    NOT?: InvoiceMCCWhereInput | InvoiceMCCWhereInput[]
    name?: StringFilter<"InvoiceMCC"> | string
    status?: EnumInvoiceMCCStatusFilter<"InvoiceMCC"> | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFilter<"InvoiceMCC"> | $Enums.CreditStatus
    linkedAccountsCount?: IntFilter<"InvoiceMCC"> | number
    activeAccountsCount?: IntFilter<"InvoiceMCC"> | number
    notes?: StringNullableFilter<"InvoiceMCC"> | string | null
    createdAt?: DateTimeFilter<"InvoiceMCC"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceMCC"> | Date | string
    partnerId?: StringNullableFilter<"InvoiceMCC"> | string | null
    createdById?: StringFilter<"InvoiceMCC"> | string
    partner?: XOR<PartnerNullableRelationFilter, PartnerWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
    accounts?: AccountListRelationFilter
    miHistories?: AccountMIHistoryListRelationFilter
    snapshots?: SpendingSnapshotListRelationFilter
    spendingRecords?: SpendingRecordListRelationFilter
  }, "id" | "mccInvoiceId">

  export type InvoiceMCCOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    mccInvoiceId?: SortOrder
    status?: SortOrder
    creditStatus?: SortOrder
    linkedAccountsCount?: SortOrder
    activeAccountsCount?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    _count?: InvoiceMCCCountOrderByAggregateInput
    _avg?: InvoiceMCCAvgOrderByAggregateInput
    _max?: InvoiceMCCMaxOrderByAggregateInput
    _min?: InvoiceMCCMinOrderByAggregateInput
    _sum?: InvoiceMCCSumOrderByAggregateInput
  }

  export type InvoiceMCCScalarWhereWithAggregatesInput = {
    AND?: InvoiceMCCScalarWhereWithAggregatesInput | InvoiceMCCScalarWhereWithAggregatesInput[]
    OR?: InvoiceMCCScalarWhereWithAggregatesInput[]
    NOT?: InvoiceMCCScalarWhereWithAggregatesInput | InvoiceMCCScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InvoiceMCC"> | string
    name?: StringWithAggregatesFilter<"InvoiceMCC"> | string
    mccInvoiceId?: StringWithAggregatesFilter<"InvoiceMCC"> | string
    status?: EnumInvoiceMCCStatusWithAggregatesFilter<"InvoiceMCC"> | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusWithAggregatesFilter<"InvoiceMCC"> | $Enums.CreditStatus
    linkedAccountsCount?: IntWithAggregatesFilter<"InvoiceMCC"> | number
    activeAccountsCount?: IntWithAggregatesFilter<"InvoiceMCC"> | number
    notes?: StringNullableWithAggregatesFilter<"InvoiceMCC"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InvoiceMCC"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InvoiceMCC"> | Date | string
    partnerId?: StringNullableWithAggregatesFilter<"InvoiceMCC"> | string | null
    createdById?: StringWithAggregatesFilter<"InvoiceMCC"> | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    contactInfo?: StringNullableFilter<"Customer"> | string | null
    status?: EnumCustomerStatusFilter<"Customer"> | $Enums.CustomerStatus
    totalSpending?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFilter<"Customer"> | number
    activeAccounts?: IntFilter<"Customer"> | number
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    assignedStaffId?: StringNullableFilter<"Customer"> | string | null
    assignedStaff?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    accounts?: AccountListRelationFilter
    mcHistories?: AccountMCHistoryListRelationFilter
    snapshots?: SpendingSnapshotListRelationFilter
    spendingRecords?: SpendingRecordListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    status?: SortOrder
    totalSpending?: SortOrder
    totalAccounts?: SortOrder
    activeAccounts?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedStaffId?: SortOrderInput | SortOrder
    assignedStaff?: UserOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    mcHistories?: AccountMCHistoryOrderByRelationAggregateInput
    snapshots?: SpendingSnapshotOrderByRelationAggregateInput
    spendingRecords?: SpendingRecordOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    contactInfo?: StringNullableFilter<"Customer"> | string | null
    status?: EnumCustomerStatusFilter<"Customer"> | $Enums.CustomerStatus
    totalSpending?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFilter<"Customer"> | number
    activeAccounts?: IntFilter<"Customer"> | number
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    assignedStaffId?: StringNullableFilter<"Customer"> | string | null
    assignedStaff?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    accounts?: AccountListRelationFilter
    mcHistories?: AccountMCHistoryListRelationFilter
    snapshots?: SpendingSnapshotListRelationFilter
    spendingRecords?: SpendingRecordListRelationFilter
  }, "id" | "name">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrderInput | SortOrder
    status?: SortOrder
    totalSpending?: SortOrder
    totalAccounts?: SortOrder
    activeAccounts?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedStaffId?: SortOrderInput | SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringWithAggregatesFilter<"Customer"> | string
    contactInfo?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    status?: EnumCustomerStatusWithAggregatesFilter<"Customer"> | $Enums.CustomerStatus
    totalSpending?: DecimalWithAggregatesFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntWithAggregatesFilter<"Customer"> | number
    activeAccounts?: IntWithAggregatesFilter<"Customer"> | number
    notes?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    assignedStaffId?: StringNullableWithAggregatesFilter<"Customer"> | string | null
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    googleAccountId?: StringFilter<"Account"> | string
    accountName?: StringFilter<"Account"> | string
    status?: EnumAccountStatusFilter<"Account"> | $Enums.AccountStatus
    currency?: StringFilter<"Account"> | string
    timezone?: StringNullableFilter<"Account"> | string | null
    mccAccountName?: StringNullableFilter<"Account"> | string | null
    mccAccountId?: StringNullableFilter<"Account"> | string | null
    totalSpending?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    lastSynced?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    batchId?: StringFilter<"Account"> | string
    currentMiId?: StringNullableFilter<"Account"> | string | null
    currentMcId?: StringNullableFilter<"Account"> | string | null
    batch?: XOR<AccountBatchRelationFilter, AccountBatchWhereInput>
    currentMi?: XOR<InvoiceMCCNullableRelationFilter, InvoiceMCCWhereInput> | null
    currentMc?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    miHistories?: AccountMIHistoryListRelationFilter
    mcHistories?: AccountMCHistoryListRelationFilter
    snapshots?: SpendingSnapshotListRelationFilter
    spendingRecords?: SpendingRecordListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    googleAccountId?: SortOrder
    accountName?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    timezone?: SortOrderInput | SortOrder
    mccAccountName?: SortOrderInput | SortOrder
    mccAccountId?: SortOrderInput | SortOrder
    totalSpending?: SortOrder
    lastSynced?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batchId?: SortOrder
    currentMiId?: SortOrderInput | SortOrder
    currentMcId?: SortOrderInput | SortOrder
    batch?: AccountBatchOrderByWithRelationInput
    currentMi?: InvoiceMCCOrderByWithRelationInput
    currentMc?: CustomerOrderByWithRelationInput
    miHistories?: AccountMIHistoryOrderByRelationAggregateInput
    mcHistories?: AccountMCHistoryOrderByRelationAggregateInput
    snapshots?: SpendingSnapshotOrderByRelationAggregateInput
    spendingRecords?: SpendingRecordOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    googleAccountId?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    accountName?: StringFilter<"Account"> | string
    status?: EnumAccountStatusFilter<"Account"> | $Enums.AccountStatus
    currency?: StringFilter<"Account"> | string
    timezone?: StringNullableFilter<"Account"> | string | null
    mccAccountName?: StringNullableFilter<"Account"> | string | null
    mccAccountId?: StringNullableFilter<"Account"> | string | null
    totalSpending?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    lastSynced?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    batchId?: StringFilter<"Account"> | string
    currentMiId?: StringNullableFilter<"Account"> | string | null
    currentMcId?: StringNullableFilter<"Account"> | string | null
    batch?: XOR<AccountBatchRelationFilter, AccountBatchWhereInput>
    currentMi?: XOR<InvoiceMCCNullableRelationFilter, InvoiceMCCWhereInput> | null
    currentMc?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    miHistories?: AccountMIHistoryListRelationFilter
    mcHistories?: AccountMCHistoryListRelationFilter
    snapshots?: SpendingSnapshotListRelationFilter
    spendingRecords?: SpendingRecordListRelationFilter
  }, "id" | "googleAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    googleAccountId?: SortOrder
    accountName?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    timezone?: SortOrderInput | SortOrder
    mccAccountName?: SortOrderInput | SortOrder
    mccAccountId?: SortOrderInput | SortOrder
    totalSpending?: SortOrder
    lastSynced?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batchId?: SortOrder
    currentMiId?: SortOrderInput | SortOrder
    currentMcId?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    googleAccountId?: StringWithAggregatesFilter<"Account"> | string
    accountName?: StringWithAggregatesFilter<"Account"> | string
    status?: EnumAccountStatusWithAggregatesFilter<"Account"> | $Enums.AccountStatus
    currency?: StringWithAggregatesFilter<"Account"> | string
    timezone?: StringNullableWithAggregatesFilter<"Account"> | string | null
    mccAccountName?: StringNullableWithAggregatesFilter<"Account"> | string | null
    mccAccountId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    totalSpending?: DecimalWithAggregatesFilter<"Account"> | Decimal | DecimalJsLike | number | string
    lastSynced?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    batchId?: StringWithAggregatesFilter<"Account"> | string
    currentMiId?: StringNullableWithAggregatesFilter<"Account"> | string | null
    currentMcId?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type AccountMIHistoryWhereInput = {
    AND?: AccountMIHistoryWhereInput | AccountMIHistoryWhereInput[]
    OR?: AccountMIHistoryWhereInput[]
    NOT?: AccountMIHistoryWhereInput | AccountMIHistoryWhereInput[]
    id?: StringFilter<"AccountMIHistory"> | string
    linkedAt?: DateTimeFilter<"AccountMIHistory"> | Date | string
    unlinkedAt?: DateTimeNullableFilter<"AccountMIHistory"> | Date | string | null
    reason?: EnumHistoryReasonFilter<"AccountMIHistory"> | $Enums.HistoryReason
    notes?: StringNullableFilter<"AccountMIHistory"> | string | null
    createdAt?: DateTimeFilter<"AccountMIHistory"> | Date | string
    accountId?: StringFilter<"AccountMIHistory"> | string
    invoiceMccId?: StringFilter<"AccountMIHistory"> | string
    linkedById?: StringFilter<"AccountMIHistory"> | string
    unlinkedById?: StringNullableFilter<"AccountMIHistory"> | string | null
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    invoiceMcc?: XOR<InvoiceMCCRelationFilter, InvoiceMCCWhereInput>
    linkedBy?: XOR<UserRelationFilter, UserWhereInput>
    unlinkedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AccountMIHistoryOrderByWithRelationInput = {
    id?: SortOrder
    linkedAt?: SortOrder
    unlinkedAt?: SortOrderInput | SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    linkedById?: SortOrder
    unlinkedById?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    invoiceMcc?: InvoiceMCCOrderByWithRelationInput
    linkedBy?: UserOrderByWithRelationInput
    unlinkedBy?: UserOrderByWithRelationInput
  }

  export type AccountMIHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountMIHistoryWhereInput | AccountMIHistoryWhereInput[]
    OR?: AccountMIHistoryWhereInput[]
    NOT?: AccountMIHistoryWhereInput | AccountMIHistoryWhereInput[]
    linkedAt?: DateTimeFilter<"AccountMIHistory"> | Date | string
    unlinkedAt?: DateTimeNullableFilter<"AccountMIHistory"> | Date | string | null
    reason?: EnumHistoryReasonFilter<"AccountMIHistory"> | $Enums.HistoryReason
    notes?: StringNullableFilter<"AccountMIHistory"> | string | null
    createdAt?: DateTimeFilter<"AccountMIHistory"> | Date | string
    accountId?: StringFilter<"AccountMIHistory"> | string
    invoiceMccId?: StringFilter<"AccountMIHistory"> | string
    linkedById?: StringFilter<"AccountMIHistory"> | string
    unlinkedById?: StringNullableFilter<"AccountMIHistory"> | string | null
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    invoiceMcc?: XOR<InvoiceMCCRelationFilter, InvoiceMCCWhereInput>
    linkedBy?: XOR<UserRelationFilter, UserWhereInput>
    unlinkedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AccountMIHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    linkedAt?: SortOrder
    unlinkedAt?: SortOrderInput | SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    linkedById?: SortOrder
    unlinkedById?: SortOrderInput | SortOrder
    _count?: AccountMIHistoryCountOrderByAggregateInput
    _max?: AccountMIHistoryMaxOrderByAggregateInput
    _min?: AccountMIHistoryMinOrderByAggregateInput
  }

  export type AccountMIHistoryScalarWhereWithAggregatesInput = {
    AND?: AccountMIHistoryScalarWhereWithAggregatesInput | AccountMIHistoryScalarWhereWithAggregatesInput[]
    OR?: AccountMIHistoryScalarWhereWithAggregatesInput[]
    NOT?: AccountMIHistoryScalarWhereWithAggregatesInput | AccountMIHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountMIHistory"> | string
    linkedAt?: DateTimeWithAggregatesFilter<"AccountMIHistory"> | Date | string
    unlinkedAt?: DateTimeNullableWithAggregatesFilter<"AccountMIHistory"> | Date | string | null
    reason?: EnumHistoryReasonWithAggregatesFilter<"AccountMIHistory"> | $Enums.HistoryReason
    notes?: StringNullableWithAggregatesFilter<"AccountMIHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AccountMIHistory"> | Date | string
    accountId?: StringWithAggregatesFilter<"AccountMIHistory"> | string
    invoiceMccId?: StringWithAggregatesFilter<"AccountMIHistory"> | string
    linkedById?: StringWithAggregatesFilter<"AccountMIHistory"> | string
    unlinkedById?: StringNullableWithAggregatesFilter<"AccountMIHistory"> | string | null
  }

  export type AccountMCHistoryWhereInput = {
    AND?: AccountMCHistoryWhereInput | AccountMCHistoryWhereInput[]
    OR?: AccountMCHistoryWhereInput[]
    NOT?: AccountMCHistoryWhereInput | AccountMCHistoryWhereInput[]
    id?: StringFilter<"AccountMCHistory"> | string
    assignedAt?: DateTimeFilter<"AccountMCHistory"> | Date | string
    unassignedAt?: DateTimeNullableFilter<"AccountMCHistory"> | Date | string | null
    reason?: EnumHistoryReasonFilter<"AccountMCHistory"> | $Enums.HistoryReason
    notes?: StringNullableFilter<"AccountMCHistory"> | string | null
    createdAt?: DateTimeFilter<"AccountMCHistory"> | Date | string
    accountId?: StringFilter<"AccountMCHistory"> | string
    customerId?: StringFilter<"AccountMCHistory"> | string
    assignedById?: StringFilter<"AccountMCHistory"> | string
    unassignedById?: StringNullableFilter<"AccountMCHistory"> | string | null
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    assignedBy?: XOR<UserRelationFilter, UserWhereInput>
    unassignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AccountMCHistoryOrderByWithRelationInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    unassignedAt?: SortOrderInput | SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    customerId?: SortOrder
    assignedById?: SortOrder
    unassignedById?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    assignedBy?: UserOrderByWithRelationInput
    unassignedBy?: UserOrderByWithRelationInput
  }

  export type AccountMCHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountMCHistoryWhereInput | AccountMCHistoryWhereInput[]
    OR?: AccountMCHistoryWhereInput[]
    NOT?: AccountMCHistoryWhereInput | AccountMCHistoryWhereInput[]
    assignedAt?: DateTimeFilter<"AccountMCHistory"> | Date | string
    unassignedAt?: DateTimeNullableFilter<"AccountMCHistory"> | Date | string | null
    reason?: EnumHistoryReasonFilter<"AccountMCHistory"> | $Enums.HistoryReason
    notes?: StringNullableFilter<"AccountMCHistory"> | string | null
    createdAt?: DateTimeFilter<"AccountMCHistory"> | Date | string
    accountId?: StringFilter<"AccountMCHistory"> | string
    customerId?: StringFilter<"AccountMCHistory"> | string
    assignedById?: StringFilter<"AccountMCHistory"> | string
    unassignedById?: StringNullableFilter<"AccountMCHistory"> | string | null
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    customer?: XOR<CustomerRelationFilter, CustomerWhereInput>
    assignedBy?: XOR<UserRelationFilter, UserWhereInput>
    unassignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AccountMCHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    unassignedAt?: SortOrderInput | SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    customerId?: SortOrder
    assignedById?: SortOrder
    unassignedById?: SortOrderInput | SortOrder
    _count?: AccountMCHistoryCountOrderByAggregateInput
    _max?: AccountMCHistoryMaxOrderByAggregateInput
    _min?: AccountMCHistoryMinOrderByAggregateInput
  }

  export type AccountMCHistoryScalarWhereWithAggregatesInput = {
    AND?: AccountMCHistoryScalarWhereWithAggregatesInput | AccountMCHistoryScalarWhereWithAggregatesInput[]
    OR?: AccountMCHistoryScalarWhereWithAggregatesInput[]
    NOT?: AccountMCHistoryScalarWhereWithAggregatesInput | AccountMCHistoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountMCHistory"> | string
    assignedAt?: DateTimeWithAggregatesFilter<"AccountMCHistory"> | Date | string
    unassignedAt?: DateTimeNullableWithAggregatesFilter<"AccountMCHistory"> | Date | string | null
    reason?: EnumHistoryReasonWithAggregatesFilter<"AccountMCHistory"> | $Enums.HistoryReason
    notes?: StringNullableWithAggregatesFilter<"AccountMCHistory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AccountMCHistory"> | Date | string
    accountId?: StringWithAggregatesFilter<"AccountMCHistory"> | string
    customerId?: StringWithAggregatesFilter<"AccountMCHistory"> | string
    assignedById?: StringWithAggregatesFilter<"AccountMCHistory"> | string
    unassignedById?: StringNullableWithAggregatesFilter<"AccountMCHistory"> | string | null
  }

  export type SpendingSnapshotWhereInput = {
    AND?: SpendingSnapshotWhereInput | SpendingSnapshotWhereInput[]
    OR?: SpendingSnapshotWhereInput[]
    NOT?: SpendingSnapshotWhereInput | SpendingSnapshotWhereInput[]
    id?: StringFilter<"SpendingSnapshot"> | string
    spendingDate?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    cumulativeAmount?: DecimalFilter<"SpendingSnapshot"> | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    snapshotType?: EnumSnapshotTypeFilter<"SpendingSnapshot"> | $Enums.SnapshotType
    createdAt?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    accountId?: StringFilter<"SpendingSnapshot"> | string
    invoiceMccId?: StringNullableFilter<"SpendingSnapshot"> | string | null
    customerId?: StringNullableFilter<"SpendingSnapshot"> | string | null
    createdById?: StringFilter<"SpendingSnapshot"> | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    invoiceMcc?: XOR<InvoiceMCCNullableRelationFilter, InvoiceMCCWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SpendingSnapshotOrderByWithRelationInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    cumulativeAmount?: SortOrder
    snapshotAt?: SortOrder
    snapshotType?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    account?: AccountOrderByWithRelationInput
    invoiceMcc?: InvoiceMCCOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    createdBy?: UserOrderByWithRelationInput
  }

  export type SpendingSnapshotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpendingSnapshotWhereInput | SpendingSnapshotWhereInput[]
    OR?: SpendingSnapshotWhereInput[]
    NOT?: SpendingSnapshotWhereInput | SpendingSnapshotWhereInput[]
    spendingDate?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    cumulativeAmount?: DecimalFilter<"SpendingSnapshot"> | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    snapshotType?: EnumSnapshotTypeFilter<"SpendingSnapshot"> | $Enums.SnapshotType
    createdAt?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    accountId?: StringFilter<"SpendingSnapshot"> | string
    invoiceMccId?: StringNullableFilter<"SpendingSnapshot"> | string | null
    customerId?: StringNullableFilter<"SpendingSnapshot"> | string | null
    createdById?: StringFilter<"SpendingSnapshot"> | string
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    invoiceMcc?: XOR<InvoiceMCCNullableRelationFilter, InvoiceMCCWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
    createdBy?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type SpendingSnapshotOrderByWithAggregationInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    cumulativeAmount?: SortOrder
    snapshotAt?: SortOrder
    snapshotType?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    createdById?: SortOrder
    _count?: SpendingSnapshotCountOrderByAggregateInput
    _avg?: SpendingSnapshotAvgOrderByAggregateInput
    _max?: SpendingSnapshotMaxOrderByAggregateInput
    _min?: SpendingSnapshotMinOrderByAggregateInput
    _sum?: SpendingSnapshotSumOrderByAggregateInput
  }

  export type SpendingSnapshotScalarWhereWithAggregatesInput = {
    AND?: SpendingSnapshotScalarWhereWithAggregatesInput | SpendingSnapshotScalarWhereWithAggregatesInput[]
    OR?: SpendingSnapshotScalarWhereWithAggregatesInput[]
    NOT?: SpendingSnapshotScalarWhereWithAggregatesInput | SpendingSnapshotScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpendingSnapshot"> | string
    spendingDate?: DateTimeWithAggregatesFilter<"SpendingSnapshot"> | Date | string
    cumulativeAmount?: DecimalWithAggregatesFilter<"SpendingSnapshot"> | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeWithAggregatesFilter<"SpendingSnapshot"> | Date | string
    snapshotType?: EnumSnapshotTypeWithAggregatesFilter<"SpendingSnapshot"> | $Enums.SnapshotType
    createdAt?: DateTimeWithAggregatesFilter<"SpendingSnapshot"> | Date | string
    accountId?: StringWithAggregatesFilter<"SpendingSnapshot"> | string
    invoiceMccId?: StringNullableWithAggregatesFilter<"SpendingSnapshot"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"SpendingSnapshot"> | string | null
    createdById?: StringWithAggregatesFilter<"SpendingSnapshot"> | string
  }

  export type SpendingRecordWhereInput = {
    AND?: SpendingRecordWhereInput | SpendingRecordWhereInput[]
    OR?: SpendingRecordWhereInput[]
    NOT?: SpendingRecordWhereInput | SpendingRecordWhereInput[]
    id?: StringFilter<"SpendingRecord"> | string
    spendingDate?: DateTimeFilter<"SpendingRecord"> | Date | string
    amount?: DecimalFilter<"SpendingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SpendingRecord"> | string
    periodStart?: DateTimeFilter<"SpendingRecord"> | Date | string
    periodEnd?: DateTimeFilter<"SpendingRecord"> | Date | string
    createdAt?: DateTimeFilter<"SpendingRecord"> | Date | string
    accountId?: StringFilter<"SpendingRecord"> | string
    invoiceMccId?: StringNullableFilter<"SpendingRecord"> | string | null
    customerId?: StringNullableFilter<"SpendingRecord"> | string | null
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    invoiceMcc?: XOR<InvoiceMCCNullableRelationFilter, InvoiceMCCWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
  }

  export type SpendingRecordOrderByWithRelationInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    account?: AccountOrderByWithRelationInput
    invoiceMcc?: InvoiceMCCOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type SpendingRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SpendingRecordWhereInput | SpendingRecordWhereInput[]
    OR?: SpendingRecordWhereInput[]
    NOT?: SpendingRecordWhereInput | SpendingRecordWhereInput[]
    spendingDate?: DateTimeFilter<"SpendingRecord"> | Date | string
    amount?: DecimalFilter<"SpendingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SpendingRecord"> | string
    periodStart?: DateTimeFilter<"SpendingRecord"> | Date | string
    periodEnd?: DateTimeFilter<"SpendingRecord"> | Date | string
    createdAt?: DateTimeFilter<"SpendingRecord"> | Date | string
    accountId?: StringFilter<"SpendingRecord"> | string
    invoiceMccId?: StringNullableFilter<"SpendingRecord"> | string | null
    customerId?: StringNullableFilter<"SpendingRecord"> | string | null
    account?: XOR<AccountRelationFilter, AccountWhereInput>
    invoiceMcc?: XOR<InvoiceMCCNullableRelationFilter, InvoiceMCCWhereInput> | null
    customer?: XOR<CustomerNullableRelationFilter, CustomerWhereInput> | null
  }, "id">

  export type SpendingRecordOrderByWithAggregationInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    _count?: SpendingRecordCountOrderByAggregateInput
    _avg?: SpendingRecordAvgOrderByAggregateInput
    _max?: SpendingRecordMaxOrderByAggregateInput
    _min?: SpendingRecordMinOrderByAggregateInput
    _sum?: SpendingRecordSumOrderByAggregateInput
  }

  export type SpendingRecordScalarWhereWithAggregatesInput = {
    AND?: SpendingRecordScalarWhereWithAggregatesInput | SpendingRecordScalarWhereWithAggregatesInput[]
    OR?: SpendingRecordScalarWhereWithAggregatesInput[]
    NOT?: SpendingRecordScalarWhereWithAggregatesInput | SpendingRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SpendingRecord"> | string
    spendingDate?: DateTimeWithAggregatesFilter<"SpendingRecord"> | Date | string
    amount?: DecimalWithAggregatesFilter<"SpendingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"SpendingRecord"> | string
    periodStart?: DateTimeWithAggregatesFilter<"SpendingRecord"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"SpendingRecord"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"SpendingRecord"> | Date | string
    accountId?: StringWithAggregatesFilter<"SpendingRecord"> | string
    invoiceMccId?: StringNullableWithAggregatesFilter<"SpendingRecord"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"SpendingRecord"> | string | null
  }

  export type ActivityLogWhereInput = {
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    action?: EnumActivityActionFilter<"ActivityLog"> | $Enums.ActivityAction
    entityType?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    oldValues?: JsonNullableFilter<"ActivityLog">
    newValues?: JsonNullableFilter<"ActivityLog">
    description?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: StringFilter<"ActivityLog"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ActivityLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ActivityLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ActivityLogWhereInput | ActivityLogWhereInput[]
    OR?: ActivityLogWhereInput[]
    NOT?: ActivityLogWhereInput | ActivityLogWhereInput[]
    action?: EnumActivityActionFilter<"ActivityLog"> | $Enums.ActivityAction
    entityType?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    oldValues?: JsonNullableFilter<"ActivityLog">
    newValues?: JsonNullableFilter<"ActivityLog">
    description?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: StringFilter<"ActivityLog"> | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ActivityLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrderInput | SortOrder
    newValues?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    _count?: ActivityLogCountOrderByAggregateInput
    _max?: ActivityLogMaxOrderByAggregateInput
    _min?: ActivityLogMinOrderByAggregateInput
  }

  export type ActivityLogScalarWhereWithAggregatesInput = {
    AND?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    OR?: ActivityLogScalarWhereWithAggregatesInput[]
    NOT?: ActivityLogScalarWhereWithAggregatesInput | ActivityLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ActivityLog"> | string
    action?: EnumActivityActionWithAggregatesFilter<"ActivityLog"> | $Enums.ActivityAction
    entityType?: StringWithAggregatesFilter<"ActivityLog"> | string
    entityId?: StringWithAggregatesFilter<"ActivityLog"> | string
    oldValues?: JsonNullableWithAggregatesFilter<"ActivityLog">
    newValues?: JsonNullableWithAggregatesFilter<"ActivityLog">
    description?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ActivityLog"> | Date | string
    userId?: StringWithAggregatesFilter<"ActivityLog"> | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerCreateInput = {
    id?: string
    name: string
    contactInfo?: string | null
    type: $Enums.PartnerType
    notes?: string | null
    createdAt?: Date | string
    batches?: AccountBatchCreateNestedManyWithoutPartnerInput
    invoiceMCCs?: InvoiceMCCCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateInput = {
    id?: string
    name: string
    contactInfo?: string | null
    type: $Enums.PartnerType
    notes?: string | null
    createdAt?: Date | string
    batches?: AccountBatchUncheckedCreateNestedManyWithoutPartnerInput
    invoiceMCCs?: InvoiceMCCUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: AccountBatchUpdateManyWithoutPartnerNestedInput
    invoiceMCCs?: InvoiceMCCUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: AccountBatchUncheckedUpdateManyWithoutPartnerNestedInput
    invoiceMCCs?: InvoiceMCCUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerCreateManyInput = {
    id?: string
    name: string
    contactInfo?: string | null
    type: $Enums.PartnerType
    notes?: string | null
    createdAt?: Date | string
  }

  export type PartnerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PartnerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountBatchCreateInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutBatchesInput
    createdBy: UserCreateNestedOneWithoutBatchesCreatedInput
    accounts?: AccountCreateNestedManyWithoutBatchInput
  }

  export type AccountBatchUncheckedCreateInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
    accounts?: AccountUncheckedCreateNestedManyWithoutBatchInput
  }

  export type AccountBatchUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutBatchesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutBatchesCreatedNestedInput
    accounts?: AccountUpdateManyWithoutBatchNestedInput
  }

  export type AccountBatchUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type AccountBatchCreateManyInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
  }

  export type AccountBatchUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountBatchUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceMCCCreateInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutInvoiceMCCsInput
    createdBy: UserCreateNestedOneWithoutInvoiceMCCsCreatedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCUncheckedCreateInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutInvoiceMCCsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoiceMCCsCreatedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCCreateManyInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
  }

  export type InvoiceMCCUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceMCCUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerCreateInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaff?: UserCreateNestedOneWithoutCustomersAssignedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMcInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutCustomerInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaffId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMcInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutCustomerInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaff?: UserUpdateOneWithoutCustomersAssignedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMcNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutCustomerNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMcNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaffId?: string | null
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: AccountBatchCreateNestedOneWithoutAccountsInput
    currentMi?: InvoiceMCCCreateNestedOneWithoutAccountsInput
    currentMc?: CustomerCreateNestedOneWithoutAccountsInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMiId?: string | null
    currentMcId?: string | null
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AccountBatchUpdateOneRequiredWithoutAccountsNestedInput
    currentMi?: InvoiceMCCUpdateOneWithoutAccountsNestedInput
    currentMc?: CustomerUpdateOneWithoutAccountsNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMiId?: string | null
    currentMcId?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryCreateInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutMiHistoriesInput
    invoiceMcc: InvoiceMCCCreateNestedOneWithoutMiHistoriesInput
    linkedBy: UserCreateNestedOneWithoutMiHistoriesLinkedInput
    unlinkedBy?: UserCreateNestedOneWithoutMiHistoriesUnlinkedInput
  }

  export type AccountMIHistoryUncheckedCreateInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    invoiceMccId: string
    linkedById: string
    unlinkedById?: string | null
  }

  export type AccountMIHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutMiHistoriesNestedInput
    invoiceMcc?: InvoiceMCCUpdateOneRequiredWithoutMiHistoriesNestedInput
    linkedBy?: UserUpdateOneRequiredWithoutMiHistoriesLinkedNestedInput
    unlinkedBy?: UserUpdateOneWithoutMiHistoriesUnlinkedNestedInput
  }

  export type AccountMIHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: StringFieldUpdateOperationsInput | string
    linkedById?: StringFieldUpdateOperationsInput | string
    unlinkedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryCreateManyInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    invoiceMccId: string
    linkedById: string
    unlinkedById?: string | null
  }

  export type AccountMIHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountMIHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: StringFieldUpdateOperationsInput | string
    linkedById?: StringFieldUpdateOperationsInput | string
    unlinkedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMCHistoryCreateInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutMcHistoriesInput
    customer: CustomerCreateNestedOneWithoutMcHistoriesInput
    assignedBy: UserCreateNestedOneWithoutMcHistoriesAssignedInput
    unassignedBy?: UserCreateNestedOneWithoutMcHistoriesUnassignedInput
  }

  export type AccountMCHistoryUncheckedCreateInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    customerId: string
    assignedById: string
    unassignedById?: string | null
  }

  export type AccountMCHistoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutMcHistoriesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutMcHistoriesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutMcHistoriesAssignedNestedInput
    unassignedBy?: UserUpdateOneWithoutMcHistoriesUnassignedNestedInput
  }

  export type AccountMCHistoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    unassignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMCHistoryCreateManyInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    customerId: string
    assignedById: string
    unassignedById?: string | null
  }

  export type AccountMCHistoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountMCHistoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    unassignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingSnapshotCreateInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutSnapshotsInput
    invoiceMcc?: InvoiceMCCCreateNestedOneWithoutSnapshotsInput
    customer?: CustomerCreateNestedOneWithoutSnapshotsInput
    createdBy: UserCreateNestedOneWithoutSnapshotsInput
  }

  export type SpendingSnapshotUncheckedCreateInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
    customerId?: string | null
    createdById: string
  }

  export type SpendingSnapshotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSnapshotsNestedInput
    invoiceMcc?: InvoiceMCCUpdateOneWithoutSnapshotsNestedInput
    customer?: CustomerUpdateOneWithoutSnapshotsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type SpendingSnapshotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingSnapshotCreateManyInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
    customerId?: string | null
    createdById: string
  }

  export type SpendingSnapshotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendingSnapshotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingRecordCreateInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutSpendingRecordsInput
    invoiceMcc?: InvoiceMCCCreateNestedOneWithoutSpendingRecordsInput
    customer?: CustomerCreateNestedOneWithoutSpendingRecordsInput
  }

  export type SpendingRecordUncheckedCreateInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
    customerId?: string | null
  }

  export type SpendingRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSpendingRecordsNestedInput
    invoiceMcc?: InvoiceMCCUpdateOneWithoutSpendingRecordsNestedInput
    customer?: CustomerUpdateOneWithoutSpendingRecordsNestedInput
  }

  export type SpendingRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingRecordCreateManyInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
    customerId?: string | null
  }

  export type SpendingRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SpendingRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogCreateInput = {
    id?: string
    action: $Enums.ActivityAction
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutActivityLogsInput
  }

  export type ActivityLogUncheckedCreateInput = {
    id?: string
    action: $Enums.ActivityAction
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type ActivityLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityActionFieldUpdateOperationsInput | $Enums.ActivityAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutActivityLogsNestedInput
  }

  export type ActivityLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityActionFieldUpdateOperationsInput | $Enums.ActivityAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type ActivityLogCreateManyInput = {
    id?: string
    action: $Enums.ActivityAction
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
    userId: string
  }

  export type ActivityLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityActionFieldUpdateOperationsInput | $Enums.ActivityAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityActionFieldUpdateOperationsInput | $Enums.ActivityAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CustomerListRelationFilter = {
    every?: CustomerWhereInput
    some?: CustomerWhereInput
    none?: CustomerWhereInput
  }

  export type AccountBatchListRelationFilter = {
    every?: AccountBatchWhereInput
    some?: AccountBatchWhereInput
    none?: AccountBatchWhereInput
  }

  export type InvoiceMCCListRelationFilter = {
    every?: InvoiceMCCWhereInput
    some?: InvoiceMCCWhereInput
    none?: InvoiceMCCWhereInput
  }

  export type AccountMIHistoryListRelationFilter = {
    every?: AccountMIHistoryWhereInput
    some?: AccountMIHistoryWhereInput
    none?: AccountMIHistoryWhereInput
  }

  export type AccountMCHistoryListRelationFilter = {
    every?: AccountMCHistoryWhereInput
    some?: AccountMCHistoryWhereInput
    none?: AccountMCHistoryWhereInput
  }

  export type SpendingSnapshotListRelationFilter = {
    every?: SpendingSnapshotWhereInput
    some?: SpendingSnapshotWhereInput
    none?: SpendingSnapshotWhereInput
  }

  export type ActivityLogListRelationFilter = {
    every?: ActivityLogWhereInput
    some?: ActivityLogWhereInput
    none?: ActivityLogWhereInput
  }

  export type CustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountBatchOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceMCCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountMIHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountMCHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SpendingSnapshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ActivityLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumPartnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeFilter<$PrismaModel> | $Enums.PartnerType
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PartnerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    type?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PartnerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    type?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type PartnerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    type?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumPartnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerTypeFilter<$PrismaModel>
    _max?: NestedEnumPartnerTypeFilter<$PrismaModel>
  }

  export type EnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PartnerNullableRelationFilter = {
    is?: PartnerWhereInput | null
    isNot?: PartnerWhereInput | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountBatchCountOrderByAggregateInput = {
    id?: SortOrder
    mccAccountName?: SortOrder
    mccAccountId?: SortOrder
    isPrelinked?: SortOrder
    status?: SortOrder
    totalAccounts?: SortOrder
    liveAccounts?: SortOrder
    timezone?: SortOrder
    year?: SortOrder
    readiness?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrder
    createdById?: SortOrder
  }

  export type AccountBatchAvgOrderByAggregateInput = {
    totalAccounts?: SortOrder
    liveAccounts?: SortOrder
    year?: SortOrder
    readiness?: SortOrder
  }

  export type AccountBatchMaxOrderByAggregateInput = {
    id?: SortOrder
    mccAccountName?: SortOrder
    mccAccountId?: SortOrder
    isPrelinked?: SortOrder
    status?: SortOrder
    totalAccounts?: SortOrder
    liveAccounts?: SortOrder
    timezone?: SortOrder
    year?: SortOrder
    readiness?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrder
    createdById?: SortOrder
  }

  export type AccountBatchMinOrderByAggregateInput = {
    id?: SortOrder
    mccAccountName?: SortOrder
    mccAccountId?: SortOrder
    isPrelinked?: SortOrder
    status?: SortOrder
    totalAccounts?: SortOrder
    liveAccounts?: SortOrder
    timezone?: SortOrder
    year?: SortOrder
    readiness?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrder
    createdById?: SortOrder
  }

  export type AccountBatchSumOrderByAggregateInput = {
    totalAccounts?: SortOrder
    liveAccounts?: SortOrder
    year?: SortOrder
    readiness?: SortOrder
  }

  export type EnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumInvoiceMCCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceMCCStatus | EnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceMCCStatus[] | ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceMCCStatus[] | ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceMCCStatusFilter<$PrismaModel> | $Enums.InvoiceMCCStatus
  }

  export type EnumCreditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[] | ListEnumCreditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditStatus[] | ListEnumCreditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditStatusFilter<$PrismaModel> | $Enums.CreditStatus
  }

  export type SpendingRecordListRelationFilter = {
    every?: SpendingRecordWhereInput
    some?: SpendingRecordWhereInput
    none?: SpendingRecordWhereInput
  }

  export type SpendingRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceMCCCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mccInvoiceId?: SortOrder
    status?: SortOrder
    creditStatus?: SortOrder
    linkedAccountsCount?: SortOrder
    activeAccountsCount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrder
    createdById?: SortOrder
  }

  export type InvoiceMCCAvgOrderByAggregateInput = {
    linkedAccountsCount?: SortOrder
    activeAccountsCount?: SortOrder
  }

  export type InvoiceMCCMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mccInvoiceId?: SortOrder
    status?: SortOrder
    creditStatus?: SortOrder
    linkedAccountsCount?: SortOrder
    activeAccountsCount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrder
    createdById?: SortOrder
  }

  export type InvoiceMCCMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    mccInvoiceId?: SortOrder
    status?: SortOrder
    creditStatus?: SortOrder
    linkedAccountsCount?: SortOrder
    activeAccountsCount?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    partnerId?: SortOrder
    createdById?: SortOrder
  }

  export type InvoiceMCCSumOrderByAggregateInput = {
    linkedAccountsCount?: SortOrder
    activeAccountsCount?: SortOrder
  }

  export type EnumInvoiceMCCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceMCCStatus | EnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceMCCStatus[] | ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceMCCStatus[] | ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceMCCStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceMCCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceMCCStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceMCCStatusFilter<$PrismaModel>
  }

  export type EnumCreditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[] | ListEnumCreditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditStatus[] | ListEnumCreditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditStatusFilter<$PrismaModel>
  }

  export type EnumCustomerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerStatus | EnumCustomerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerStatus[] | ListEnumCustomerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerStatus[] | ListEnumCustomerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerStatusFilter<$PrismaModel> | $Enums.CustomerStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    status?: SortOrder
    totalSpending?: SortOrder
    totalAccounts?: SortOrder
    activeAccounts?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedStaffId?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    totalSpending?: SortOrder
    totalAccounts?: SortOrder
    activeAccounts?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    status?: SortOrder
    totalSpending?: SortOrder
    totalAccounts?: SortOrder
    activeAccounts?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedStaffId?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contactInfo?: SortOrder
    status?: SortOrder
    totalSpending?: SortOrder
    totalAccounts?: SortOrder
    activeAccounts?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedStaffId?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    totalSpending?: SortOrder
    totalAccounts?: SortOrder
    activeAccounts?: SortOrder
  }

  export type EnumCustomerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerStatus | EnumCustomerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerStatus[] | ListEnumCustomerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerStatus[] | ListEnumCustomerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerStatusWithAggregatesFilter<$PrismaModel> | $Enums.CustomerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerStatusFilter<$PrismaModel>
    _max?: NestedEnumCustomerStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AccountBatchRelationFilter = {
    is?: AccountBatchWhereInput
    isNot?: AccountBatchWhereInput
  }

  export type InvoiceMCCNullableRelationFilter = {
    is?: InvoiceMCCWhereInput | null
    isNot?: InvoiceMCCWhereInput | null
  }

  export type CustomerNullableRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    googleAccountId?: SortOrder
    accountName?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    mccAccountName?: SortOrder
    mccAccountId?: SortOrder
    totalSpending?: SortOrder
    lastSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batchId?: SortOrder
    currentMiId?: SortOrder
    currentMcId?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    totalSpending?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    googleAccountId?: SortOrder
    accountName?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    mccAccountName?: SortOrder
    mccAccountId?: SortOrder
    totalSpending?: SortOrder
    lastSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batchId?: SortOrder
    currentMiId?: SortOrder
    currentMcId?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    googleAccountId?: SortOrder
    accountName?: SortOrder
    status?: SortOrder
    currency?: SortOrder
    timezone?: SortOrder
    mccAccountName?: SortOrder
    mccAccountId?: SortOrder
    totalSpending?: SortOrder
    lastSynced?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    batchId?: SortOrder
    currentMiId?: SortOrder
    currentMcId?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    totalSpending?: SortOrder
  }

  export type EnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumHistoryReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.HistoryReason | EnumHistoryReasonFieldRefInput<$PrismaModel>
    in?: $Enums.HistoryReason[] | ListEnumHistoryReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.HistoryReason[] | ListEnumHistoryReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumHistoryReasonFilter<$PrismaModel> | $Enums.HistoryReason
  }

  export type AccountRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type InvoiceMCCRelationFilter = {
    is?: InvoiceMCCWhereInput
    isNot?: InvoiceMCCWhereInput
  }

  export type AccountMIHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    linkedAt?: SortOrder
    unlinkedAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    linkedById?: SortOrder
    unlinkedById?: SortOrder
  }

  export type AccountMIHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    linkedAt?: SortOrder
    unlinkedAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    linkedById?: SortOrder
    unlinkedById?: SortOrder
  }

  export type AccountMIHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    linkedAt?: SortOrder
    unlinkedAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    linkedById?: SortOrder
    unlinkedById?: SortOrder
  }

  export type EnumHistoryReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HistoryReason | EnumHistoryReasonFieldRefInput<$PrismaModel>
    in?: $Enums.HistoryReason[] | ListEnumHistoryReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.HistoryReason[] | ListEnumHistoryReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumHistoryReasonWithAggregatesFilter<$PrismaModel> | $Enums.HistoryReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHistoryReasonFilter<$PrismaModel>
    _max?: NestedEnumHistoryReasonFilter<$PrismaModel>
  }

  export type CustomerRelationFilter = {
    is?: CustomerWhereInput
    isNot?: CustomerWhereInput
  }

  export type AccountMCHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    unassignedAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    customerId?: SortOrder
    assignedById?: SortOrder
    unassignedById?: SortOrder
  }

  export type AccountMCHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    unassignedAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    customerId?: SortOrder
    assignedById?: SortOrder
    unassignedById?: SortOrder
  }

  export type AccountMCHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    assignedAt?: SortOrder
    unassignedAt?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    customerId?: SortOrder
    assignedById?: SortOrder
    unassignedById?: SortOrder
  }

  export type EnumSnapshotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotType | EnumSnapshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotTypeFilter<$PrismaModel> | $Enums.SnapshotType
  }

  export type SpendingSnapshotCountOrderByAggregateInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    cumulativeAmount?: SortOrder
    snapshotAt?: SortOrder
    snapshotType?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
  }

  export type SpendingSnapshotAvgOrderByAggregateInput = {
    cumulativeAmount?: SortOrder
  }

  export type SpendingSnapshotMaxOrderByAggregateInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    cumulativeAmount?: SortOrder
    snapshotAt?: SortOrder
    snapshotType?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
  }

  export type SpendingSnapshotMinOrderByAggregateInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    cumulativeAmount?: SortOrder
    snapshotAt?: SortOrder
    snapshotType?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    customerId?: SortOrder
    createdById?: SortOrder
  }

  export type SpendingSnapshotSumOrderByAggregateInput = {
    cumulativeAmount?: SortOrder
  }

  export type EnumSnapshotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotType | EnumSnapshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SnapshotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnapshotTypeFilter<$PrismaModel>
    _max?: NestedEnumSnapshotTypeFilter<$PrismaModel>
  }

  export type SpendingRecordCountOrderByAggregateInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    customerId?: SortOrder
  }

  export type SpendingRecordAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type SpendingRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    customerId?: SortOrder
  }

  export type SpendingRecordMinOrderByAggregateInput = {
    id?: SortOrder
    spendingDate?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    accountId?: SortOrder
    invoiceMccId?: SortOrder
    customerId?: SortOrder
  }

  export type SpendingRecordSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumActivityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityAction | EnumActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityAction[] | ListEnumActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityAction[] | ListEnumActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityActionFilter<$PrismaModel> | $Enums.ActivityAction
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ActivityLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValues?: SortOrder
    newValues?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type ActivityLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    description?: SortOrder
    ipAddress?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
  }

  export type EnumActivityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityAction | EnumActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityAction[] | ListEnumActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityAction[] | ListEnumActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityActionWithAggregatesFilter<$PrismaModel> | $Enums.ActivityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityActionFilter<$PrismaModel>
    _max?: NestedEnumActivityActionFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type CustomerCreateNestedManyWithoutAssignedStaffInput = {
    create?: XOR<CustomerCreateWithoutAssignedStaffInput, CustomerUncheckedCreateWithoutAssignedStaffInput> | CustomerCreateWithoutAssignedStaffInput[] | CustomerUncheckedCreateWithoutAssignedStaffInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignedStaffInput | CustomerCreateOrConnectWithoutAssignedStaffInput[]
    createMany?: CustomerCreateManyAssignedStaffInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type AccountBatchCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AccountBatchCreateWithoutCreatedByInput, AccountBatchUncheckedCreateWithoutCreatedByInput> | AccountBatchCreateWithoutCreatedByInput[] | AccountBatchUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AccountBatchCreateOrConnectWithoutCreatedByInput | AccountBatchCreateOrConnectWithoutCreatedByInput[]
    createMany?: AccountBatchCreateManyCreatedByInputEnvelope
    connect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
  }

  export type InvoiceMCCCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceMCCCreateWithoutCreatedByInput, InvoiceMCCUncheckedCreateWithoutCreatedByInput> | InvoiceMCCCreateWithoutCreatedByInput[] | InvoiceMCCUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutCreatedByInput | InvoiceMCCCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceMCCCreateManyCreatedByInputEnvelope
    connect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
  }

  export type AccountMIHistoryCreateNestedManyWithoutLinkedByInput = {
    create?: XOR<AccountMIHistoryCreateWithoutLinkedByInput, AccountMIHistoryUncheckedCreateWithoutLinkedByInput> | AccountMIHistoryCreateWithoutLinkedByInput[] | AccountMIHistoryUncheckedCreateWithoutLinkedByInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutLinkedByInput | AccountMIHistoryCreateOrConnectWithoutLinkedByInput[]
    createMany?: AccountMIHistoryCreateManyLinkedByInputEnvelope
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
  }

  export type AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput = {
    create?: XOR<AccountMIHistoryCreateWithoutUnlinkedByInput, AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput> | AccountMIHistoryCreateWithoutUnlinkedByInput[] | AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput | AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput[]
    createMany?: AccountMIHistoryCreateManyUnlinkedByInputEnvelope
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
  }

  export type AccountMCHistoryCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<AccountMCHistoryCreateWithoutAssignedByInput, AccountMCHistoryUncheckedCreateWithoutAssignedByInput> | AccountMCHistoryCreateWithoutAssignedByInput[] | AccountMCHistoryUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutAssignedByInput | AccountMCHistoryCreateOrConnectWithoutAssignedByInput[]
    createMany?: AccountMCHistoryCreateManyAssignedByInputEnvelope
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
  }

  export type AccountMCHistoryCreateNestedManyWithoutUnassignedByInput = {
    create?: XOR<AccountMCHistoryCreateWithoutUnassignedByInput, AccountMCHistoryUncheckedCreateWithoutUnassignedByInput> | AccountMCHistoryCreateWithoutUnassignedByInput[] | AccountMCHistoryUncheckedCreateWithoutUnassignedByInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutUnassignedByInput | AccountMCHistoryCreateOrConnectWithoutUnassignedByInput[]
    createMany?: AccountMCHistoryCreateManyUnassignedByInputEnvelope
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
  }

  export type SpendingSnapshotCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SpendingSnapshotCreateWithoutCreatedByInput, SpendingSnapshotUncheckedCreateWithoutCreatedByInput> | SpendingSnapshotCreateWithoutCreatedByInput[] | SpendingSnapshotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutCreatedByInput | SpendingSnapshotCreateOrConnectWithoutCreatedByInput[]
    createMany?: SpendingSnapshotCreateManyCreatedByInputEnvelope
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
  }

  export type ActivityLogCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput = {
    create?: XOR<CustomerCreateWithoutAssignedStaffInput, CustomerUncheckedCreateWithoutAssignedStaffInput> | CustomerCreateWithoutAssignedStaffInput[] | CustomerUncheckedCreateWithoutAssignedStaffInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignedStaffInput | CustomerCreateOrConnectWithoutAssignedStaffInput[]
    createMany?: CustomerCreateManyAssignedStaffInputEnvelope
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
  }

  export type AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<AccountBatchCreateWithoutCreatedByInput, AccountBatchUncheckedCreateWithoutCreatedByInput> | AccountBatchCreateWithoutCreatedByInput[] | AccountBatchUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AccountBatchCreateOrConnectWithoutCreatedByInput | AccountBatchCreateOrConnectWithoutCreatedByInput[]
    createMany?: AccountBatchCreateManyCreatedByInputEnvelope
    connect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
  }

  export type InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<InvoiceMCCCreateWithoutCreatedByInput, InvoiceMCCUncheckedCreateWithoutCreatedByInput> | InvoiceMCCCreateWithoutCreatedByInput[] | InvoiceMCCUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutCreatedByInput | InvoiceMCCCreateOrConnectWithoutCreatedByInput[]
    createMany?: InvoiceMCCCreateManyCreatedByInputEnvelope
    connect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
  }

  export type AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput = {
    create?: XOR<AccountMIHistoryCreateWithoutLinkedByInput, AccountMIHistoryUncheckedCreateWithoutLinkedByInput> | AccountMIHistoryCreateWithoutLinkedByInput[] | AccountMIHistoryUncheckedCreateWithoutLinkedByInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutLinkedByInput | AccountMIHistoryCreateOrConnectWithoutLinkedByInput[]
    createMany?: AccountMIHistoryCreateManyLinkedByInputEnvelope
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
  }

  export type AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput = {
    create?: XOR<AccountMIHistoryCreateWithoutUnlinkedByInput, AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput> | AccountMIHistoryCreateWithoutUnlinkedByInput[] | AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput | AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput[]
    createMany?: AccountMIHistoryCreateManyUnlinkedByInputEnvelope
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
  }

  export type AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<AccountMCHistoryCreateWithoutAssignedByInput, AccountMCHistoryUncheckedCreateWithoutAssignedByInput> | AccountMCHistoryCreateWithoutAssignedByInput[] | AccountMCHistoryUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutAssignedByInput | AccountMCHistoryCreateOrConnectWithoutAssignedByInput[]
    createMany?: AccountMCHistoryCreateManyAssignedByInputEnvelope
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
  }

  export type AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput = {
    create?: XOR<AccountMCHistoryCreateWithoutUnassignedByInput, AccountMCHistoryUncheckedCreateWithoutUnassignedByInput> | AccountMCHistoryCreateWithoutUnassignedByInput[] | AccountMCHistoryUncheckedCreateWithoutUnassignedByInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutUnassignedByInput | AccountMCHistoryCreateOrConnectWithoutUnassignedByInput[]
    createMany?: AccountMCHistoryCreateManyUnassignedByInputEnvelope
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
  }

  export type SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<SpendingSnapshotCreateWithoutCreatedByInput, SpendingSnapshotUncheckedCreateWithoutCreatedByInput> | SpendingSnapshotCreateWithoutCreatedByInput[] | SpendingSnapshotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutCreatedByInput | SpendingSnapshotCreateOrConnectWithoutCreatedByInput[]
    createMany?: SpendingSnapshotCreateManyCreatedByInputEnvelope
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
  }

  export type ActivityLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CustomerUpdateManyWithoutAssignedStaffNestedInput = {
    create?: XOR<CustomerCreateWithoutAssignedStaffInput, CustomerUncheckedCreateWithoutAssignedStaffInput> | CustomerCreateWithoutAssignedStaffInput[] | CustomerUncheckedCreateWithoutAssignedStaffInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignedStaffInput | CustomerCreateOrConnectWithoutAssignedStaffInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAssignedStaffInput | CustomerUpsertWithWhereUniqueWithoutAssignedStaffInput[]
    createMany?: CustomerCreateManyAssignedStaffInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAssignedStaffInput | CustomerUpdateWithWhereUniqueWithoutAssignedStaffInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAssignedStaffInput | CustomerUpdateManyWithWhereWithoutAssignedStaffInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type AccountBatchUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AccountBatchCreateWithoutCreatedByInput, AccountBatchUncheckedCreateWithoutCreatedByInput> | AccountBatchCreateWithoutCreatedByInput[] | AccountBatchUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AccountBatchCreateOrConnectWithoutCreatedByInput | AccountBatchCreateOrConnectWithoutCreatedByInput[]
    upsert?: AccountBatchUpsertWithWhereUniqueWithoutCreatedByInput | AccountBatchUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AccountBatchCreateManyCreatedByInputEnvelope
    set?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    disconnect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    delete?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    connect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    update?: AccountBatchUpdateWithWhereUniqueWithoutCreatedByInput | AccountBatchUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AccountBatchUpdateManyWithWhereWithoutCreatedByInput | AccountBatchUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AccountBatchScalarWhereInput | AccountBatchScalarWhereInput[]
  }

  export type InvoiceMCCUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceMCCCreateWithoutCreatedByInput, InvoiceMCCUncheckedCreateWithoutCreatedByInput> | InvoiceMCCCreateWithoutCreatedByInput[] | InvoiceMCCUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutCreatedByInput | InvoiceMCCCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceMCCUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceMCCUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceMCCCreateManyCreatedByInputEnvelope
    set?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    disconnect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    delete?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    connect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    update?: InvoiceMCCUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceMCCUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceMCCUpdateManyWithWhereWithoutCreatedByInput | InvoiceMCCUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceMCCScalarWhereInput | InvoiceMCCScalarWhereInput[]
  }

  export type AccountMIHistoryUpdateManyWithoutLinkedByNestedInput = {
    create?: XOR<AccountMIHistoryCreateWithoutLinkedByInput, AccountMIHistoryUncheckedCreateWithoutLinkedByInput> | AccountMIHistoryCreateWithoutLinkedByInput[] | AccountMIHistoryUncheckedCreateWithoutLinkedByInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutLinkedByInput | AccountMIHistoryCreateOrConnectWithoutLinkedByInput[]
    upsert?: AccountMIHistoryUpsertWithWhereUniqueWithoutLinkedByInput | AccountMIHistoryUpsertWithWhereUniqueWithoutLinkedByInput[]
    createMany?: AccountMIHistoryCreateManyLinkedByInputEnvelope
    set?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    disconnect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    delete?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    update?: AccountMIHistoryUpdateWithWhereUniqueWithoutLinkedByInput | AccountMIHistoryUpdateWithWhereUniqueWithoutLinkedByInput[]
    updateMany?: AccountMIHistoryUpdateManyWithWhereWithoutLinkedByInput | AccountMIHistoryUpdateManyWithWhereWithoutLinkedByInput[]
    deleteMany?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
  }

  export type AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput = {
    create?: XOR<AccountMIHistoryCreateWithoutUnlinkedByInput, AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput> | AccountMIHistoryCreateWithoutUnlinkedByInput[] | AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput | AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput[]
    upsert?: AccountMIHistoryUpsertWithWhereUniqueWithoutUnlinkedByInput | AccountMIHistoryUpsertWithWhereUniqueWithoutUnlinkedByInput[]
    createMany?: AccountMIHistoryCreateManyUnlinkedByInputEnvelope
    set?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    disconnect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    delete?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    update?: AccountMIHistoryUpdateWithWhereUniqueWithoutUnlinkedByInput | AccountMIHistoryUpdateWithWhereUniqueWithoutUnlinkedByInput[]
    updateMany?: AccountMIHistoryUpdateManyWithWhereWithoutUnlinkedByInput | AccountMIHistoryUpdateManyWithWhereWithoutUnlinkedByInput[]
    deleteMany?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
  }

  export type AccountMCHistoryUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<AccountMCHistoryCreateWithoutAssignedByInput, AccountMCHistoryUncheckedCreateWithoutAssignedByInput> | AccountMCHistoryCreateWithoutAssignedByInput[] | AccountMCHistoryUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutAssignedByInput | AccountMCHistoryCreateOrConnectWithoutAssignedByInput[]
    upsert?: AccountMCHistoryUpsertWithWhereUniqueWithoutAssignedByInput | AccountMCHistoryUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: AccountMCHistoryCreateManyAssignedByInputEnvelope
    set?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    disconnect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    delete?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    update?: AccountMCHistoryUpdateWithWhereUniqueWithoutAssignedByInput | AccountMCHistoryUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: AccountMCHistoryUpdateManyWithWhereWithoutAssignedByInput | AccountMCHistoryUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
  }

  export type AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput = {
    create?: XOR<AccountMCHistoryCreateWithoutUnassignedByInput, AccountMCHistoryUncheckedCreateWithoutUnassignedByInput> | AccountMCHistoryCreateWithoutUnassignedByInput[] | AccountMCHistoryUncheckedCreateWithoutUnassignedByInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutUnassignedByInput | AccountMCHistoryCreateOrConnectWithoutUnassignedByInput[]
    upsert?: AccountMCHistoryUpsertWithWhereUniqueWithoutUnassignedByInput | AccountMCHistoryUpsertWithWhereUniqueWithoutUnassignedByInput[]
    createMany?: AccountMCHistoryCreateManyUnassignedByInputEnvelope
    set?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    disconnect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    delete?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    update?: AccountMCHistoryUpdateWithWhereUniqueWithoutUnassignedByInput | AccountMCHistoryUpdateWithWhereUniqueWithoutUnassignedByInput[]
    updateMany?: AccountMCHistoryUpdateManyWithWhereWithoutUnassignedByInput | AccountMCHistoryUpdateManyWithWhereWithoutUnassignedByInput[]
    deleteMany?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
  }

  export type SpendingSnapshotUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SpendingSnapshotCreateWithoutCreatedByInput, SpendingSnapshotUncheckedCreateWithoutCreatedByInput> | SpendingSnapshotCreateWithoutCreatedByInput[] | SpendingSnapshotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutCreatedByInput | SpendingSnapshotCreateOrConnectWithoutCreatedByInput[]
    upsert?: SpendingSnapshotUpsertWithWhereUniqueWithoutCreatedByInput | SpendingSnapshotUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SpendingSnapshotCreateManyCreatedByInputEnvelope
    set?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    disconnect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    delete?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    update?: SpendingSnapshotUpdateWithWhereUniqueWithoutCreatedByInput | SpendingSnapshotUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SpendingSnapshotUpdateManyWithWhereWithoutCreatedByInput | SpendingSnapshotUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
  }

  export type ActivityLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput = {
    create?: XOR<CustomerCreateWithoutAssignedStaffInput, CustomerUncheckedCreateWithoutAssignedStaffInput> | CustomerCreateWithoutAssignedStaffInput[] | CustomerUncheckedCreateWithoutAssignedStaffInput[]
    connectOrCreate?: CustomerCreateOrConnectWithoutAssignedStaffInput | CustomerCreateOrConnectWithoutAssignedStaffInput[]
    upsert?: CustomerUpsertWithWhereUniqueWithoutAssignedStaffInput | CustomerUpsertWithWhereUniqueWithoutAssignedStaffInput[]
    createMany?: CustomerCreateManyAssignedStaffInputEnvelope
    set?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    disconnect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    delete?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    connect?: CustomerWhereUniqueInput | CustomerWhereUniqueInput[]
    update?: CustomerUpdateWithWhereUniqueWithoutAssignedStaffInput | CustomerUpdateWithWhereUniqueWithoutAssignedStaffInput[]
    updateMany?: CustomerUpdateManyWithWhereWithoutAssignedStaffInput | CustomerUpdateManyWithWhereWithoutAssignedStaffInput[]
    deleteMany?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
  }

  export type AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<AccountBatchCreateWithoutCreatedByInput, AccountBatchUncheckedCreateWithoutCreatedByInput> | AccountBatchCreateWithoutCreatedByInput[] | AccountBatchUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: AccountBatchCreateOrConnectWithoutCreatedByInput | AccountBatchCreateOrConnectWithoutCreatedByInput[]
    upsert?: AccountBatchUpsertWithWhereUniqueWithoutCreatedByInput | AccountBatchUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: AccountBatchCreateManyCreatedByInputEnvelope
    set?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    disconnect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    delete?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    connect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    update?: AccountBatchUpdateWithWhereUniqueWithoutCreatedByInput | AccountBatchUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: AccountBatchUpdateManyWithWhereWithoutCreatedByInput | AccountBatchUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: AccountBatchScalarWhereInput | AccountBatchScalarWhereInput[]
  }

  export type InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<InvoiceMCCCreateWithoutCreatedByInput, InvoiceMCCUncheckedCreateWithoutCreatedByInput> | InvoiceMCCCreateWithoutCreatedByInput[] | InvoiceMCCUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutCreatedByInput | InvoiceMCCCreateOrConnectWithoutCreatedByInput[]
    upsert?: InvoiceMCCUpsertWithWhereUniqueWithoutCreatedByInput | InvoiceMCCUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: InvoiceMCCCreateManyCreatedByInputEnvelope
    set?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    disconnect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    delete?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    connect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    update?: InvoiceMCCUpdateWithWhereUniqueWithoutCreatedByInput | InvoiceMCCUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: InvoiceMCCUpdateManyWithWhereWithoutCreatedByInput | InvoiceMCCUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: InvoiceMCCScalarWhereInput | InvoiceMCCScalarWhereInput[]
  }

  export type AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput = {
    create?: XOR<AccountMIHistoryCreateWithoutLinkedByInput, AccountMIHistoryUncheckedCreateWithoutLinkedByInput> | AccountMIHistoryCreateWithoutLinkedByInput[] | AccountMIHistoryUncheckedCreateWithoutLinkedByInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutLinkedByInput | AccountMIHistoryCreateOrConnectWithoutLinkedByInput[]
    upsert?: AccountMIHistoryUpsertWithWhereUniqueWithoutLinkedByInput | AccountMIHistoryUpsertWithWhereUniqueWithoutLinkedByInput[]
    createMany?: AccountMIHistoryCreateManyLinkedByInputEnvelope
    set?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    disconnect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    delete?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    update?: AccountMIHistoryUpdateWithWhereUniqueWithoutLinkedByInput | AccountMIHistoryUpdateWithWhereUniqueWithoutLinkedByInput[]
    updateMany?: AccountMIHistoryUpdateManyWithWhereWithoutLinkedByInput | AccountMIHistoryUpdateManyWithWhereWithoutLinkedByInput[]
    deleteMany?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
  }

  export type AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput = {
    create?: XOR<AccountMIHistoryCreateWithoutUnlinkedByInput, AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput> | AccountMIHistoryCreateWithoutUnlinkedByInput[] | AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput | AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput[]
    upsert?: AccountMIHistoryUpsertWithWhereUniqueWithoutUnlinkedByInput | AccountMIHistoryUpsertWithWhereUniqueWithoutUnlinkedByInput[]
    createMany?: AccountMIHistoryCreateManyUnlinkedByInputEnvelope
    set?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    disconnect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    delete?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    update?: AccountMIHistoryUpdateWithWhereUniqueWithoutUnlinkedByInput | AccountMIHistoryUpdateWithWhereUniqueWithoutUnlinkedByInput[]
    updateMany?: AccountMIHistoryUpdateManyWithWhereWithoutUnlinkedByInput | AccountMIHistoryUpdateManyWithWhereWithoutUnlinkedByInput[]
    deleteMany?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
  }

  export type AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<AccountMCHistoryCreateWithoutAssignedByInput, AccountMCHistoryUncheckedCreateWithoutAssignedByInput> | AccountMCHistoryCreateWithoutAssignedByInput[] | AccountMCHistoryUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutAssignedByInput | AccountMCHistoryCreateOrConnectWithoutAssignedByInput[]
    upsert?: AccountMCHistoryUpsertWithWhereUniqueWithoutAssignedByInput | AccountMCHistoryUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: AccountMCHistoryCreateManyAssignedByInputEnvelope
    set?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    disconnect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    delete?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    update?: AccountMCHistoryUpdateWithWhereUniqueWithoutAssignedByInput | AccountMCHistoryUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: AccountMCHistoryUpdateManyWithWhereWithoutAssignedByInput | AccountMCHistoryUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
  }

  export type AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput = {
    create?: XOR<AccountMCHistoryCreateWithoutUnassignedByInput, AccountMCHistoryUncheckedCreateWithoutUnassignedByInput> | AccountMCHistoryCreateWithoutUnassignedByInput[] | AccountMCHistoryUncheckedCreateWithoutUnassignedByInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutUnassignedByInput | AccountMCHistoryCreateOrConnectWithoutUnassignedByInput[]
    upsert?: AccountMCHistoryUpsertWithWhereUniqueWithoutUnassignedByInput | AccountMCHistoryUpsertWithWhereUniqueWithoutUnassignedByInput[]
    createMany?: AccountMCHistoryCreateManyUnassignedByInputEnvelope
    set?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    disconnect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    delete?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    update?: AccountMCHistoryUpdateWithWhereUniqueWithoutUnassignedByInput | AccountMCHistoryUpdateWithWhereUniqueWithoutUnassignedByInput[]
    updateMany?: AccountMCHistoryUpdateManyWithWhereWithoutUnassignedByInput | AccountMCHistoryUpdateManyWithWhereWithoutUnassignedByInput[]
    deleteMany?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
  }

  export type SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<SpendingSnapshotCreateWithoutCreatedByInput, SpendingSnapshotUncheckedCreateWithoutCreatedByInput> | SpendingSnapshotCreateWithoutCreatedByInput[] | SpendingSnapshotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutCreatedByInput | SpendingSnapshotCreateOrConnectWithoutCreatedByInput[]
    upsert?: SpendingSnapshotUpsertWithWhereUniqueWithoutCreatedByInput | SpendingSnapshotUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: SpendingSnapshotCreateManyCreatedByInputEnvelope
    set?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    disconnect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    delete?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    update?: SpendingSnapshotUpdateWithWhereUniqueWithoutCreatedByInput | SpendingSnapshotUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: SpendingSnapshotUpdateManyWithWhereWithoutCreatedByInput | SpendingSnapshotUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput> | ActivityLogCreateWithoutUserInput[] | ActivityLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ActivityLogCreateOrConnectWithoutUserInput | ActivityLogCreateOrConnectWithoutUserInput[]
    upsert?: ActivityLogUpsertWithWhereUniqueWithoutUserInput | ActivityLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ActivityLogCreateManyUserInputEnvelope
    set?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    disconnect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    delete?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    connect?: ActivityLogWhereUniqueInput | ActivityLogWhereUniqueInput[]
    update?: ActivityLogUpdateWithWhereUniqueWithoutUserInput | ActivityLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ActivityLogUpdateManyWithWhereWithoutUserInput | ActivityLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
  }

  export type AccountBatchCreateNestedManyWithoutPartnerInput = {
    create?: XOR<AccountBatchCreateWithoutPartnerInput, AccountBatchUncheckedCreateWithoutPartnerInput> | AccountBatchCreateWithoutPartnerInput[] | AccountBatchUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: AccountBatchCreateOrConnectWithoutPartnerInput | AccountBatchCreateOrConnectWithoutPartnerInput[]
    createMany?: AccountBatchCreateManyPartnerInputEnvelope
    connect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
  }

  export type InvoiceMCCCreateNestedManyWithoutPartnerInput = {
    create?: XOR<InvoiceMCCCreateWithoutPartnerInput, InvoiceMCCUncheckedCreateWithoutPartnerInput> | InvoiceMCCCreateWithoutPartnerInput[] | InvoiceMCCUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutPartnerInput | InvoiceMCCCreateOrConnectWithoutPartnerInput[]
    createMany?: InvoiceMCCCreateManyPartnerInputEnvelope
    connect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
  }

  export type AccountBatchUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<AccountBatchCreateWithoutPartnerInput, AccountBatchUncheckedCreateWithoutPartnerInput> | AccountBatchCreateWithoutPartnerInput[] | AccountBatchUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: AccountBatchCreateOrConnectWithoutPartnerInput | AccountBatchCreateOrConnectWithoutPartnerInput[]
    createMany?: AccountBatchCreateManyPartnerInputEnvelope
    connect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
  }

  export type InvoiceMCCUncheckedCreateNestedManyWithoutPartnerInput = {
    create?: XOR<InvoiceMCCCreateWithoutPartnerInput, InvoiceMCCUncheckedCreateWithoutPartnerInput> | InvoiceMCCCreateWithoutPartnerInput[] | InvoiceMCCUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutPartnerInput | InvoiceMCCCreateOrConnectWithoutPartnerInput[]
    createMany?: InvoiceMCCCreateManyPartnerInputEnvelope
    connect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumPartnerTypeFieldUpdateOperationsInput = {
    set?: $Enums.PartnerType
  }

  export type AccountBatchUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<AccountBatchCreateWithoutPartnerInput, AccountBatchUncheckedCreateWithoutPartnerInput> | AccountBatchCreateWithoutPartnerInput[] | AccountBatchUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: AccountBatchCreateOrConnectWithoutPartnerInput | AccountBatchCreateOrConnectWithoutPartnerInput[]
    upsert?: AccountBatchUpsertWithWhereUniqueWithoutPartnerInput | AccountBatchUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: AccountBatchCreateManyPartnerInputEnvelope
    set?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    disconnect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    delete?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    connect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    update?: AccountBatchUpdateWithWhereUniqueWithoutPartnerInput | AccountBatchUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: AccountBatchUpdateManyWithWhereWithoutPartnerInput | AccountBatchUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: AccountBatchScalarWhereInput | AccountBatchScalarWhereInput[]
  }

  export type InvoiceMCCUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<InvoiceMCCCreateWithoutPartnerInput, InvoiceMCCUncheckedCreateWithoutPartnerInput> | InvoiceMCCCreateWithoutPartnerInput[] | InvoiceMCCUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutPartnerInput | InvoiceMCCCreateOrConnectWithoutPartnerInput[]
    upsert?: InvoiceMCCUpsertWithWhereUniqueWithoutPartnerInput | InvoiceMCCUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: InvoiceMCCCreateManyPartnerInputEnvelope
    set?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    disconnect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    delete?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    connect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    update?: InvoiceMCCUpdateWithWhereUniqueWithoutPartnerInput | InvoiceMCCUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: InvoiceMCCUpdateManyWithWhereWithoutPartnerInput | InvoiceMCCUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: InvoiceMCCScalarWhereInput | InvoiceMCCScalarWhereInput[]
  }

  export type AccountBatchUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<AccountBatchCreateWithoutPartnerInput, AccountBatchUncheckedCreateWithoutPartnerInput> | AccountBatchCreateWithoutPartnerInput[] | AccountBatchUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: AccountBatchCreateOrConnectWithoutPartnerInput | AccountBatchCreateOrConnectWithoutPartnerInput[]
    upsert?: AccountBatchUpsertWithWhereUniqueWithoutPartnerInput | AccountBatchUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: AccountBatchCreateManyPartnerInputEnvelope
    set?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    disconnect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    delete?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    connect?: AccountBatchWhereUniqueInput | AccountBatchWhereUniqueInput[]
    update?: AccountBatchUpdateWithWhereUniqueWithoutPartnerInput | AccountBatchUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: AccountBatchUpdateManyWithWhereWithoutPartnerInput | AccountBatchUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: AccountBatchScalarWhereInput | AccountBatchScalarWhereInput[]
  }

  export type InvoiceMCCUncheckedUpdateManyWithoutPartnerNestedInput = {
    create?: XOR<InvoiceMCCCreateWithoutPartnerInput, InvoiceMCCUncheckedCreateWithoutPartnerInput> | InvoiceMCCCreateWithoutPartnerInput[] | InvoiceMCCUncheckedCreateWithoutPartnerInput[]
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutPartnerInput | InvoiceMCCCreateOrConnectWithoutPartnerInput[]
    upsert?: InvoiceMCCUpsertWithWhereUniqueWithoutPartnerInput | InvoiceMCCUpsertWithWhereUniqueWithoutPartnerInput[]
    createMany?: InvoiceMCCCreateManyPartnerInputEnvelope
    set?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    disconnect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    delete?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    connect?: InvoiceMCCWhereUniqueInput | InvoiceMCCWhereUniqueInput[]
    update?: InvoiceMCCUpdateWithWhereUniqueWithoutPartnerInput | InvoiceMCCUpdateWithWhereUniqueWithoutPartnerInput[]
    updateMany?: InvoiceMCCUpdateManyWithWhereWithoutPartnerInput | InvoiceMCCUpdateManyWithWhereWithoutPartnerInput[]
    deleteMany?: InvoiceMCCScalarWhereInput | InvoiceMCCScalarWhereInput[]
  }

  export type PartnerCreateNestedOneWithoutBatchesInput = {
    create?: XOR<PartnerCreateWithoutBatchesInput, PartnerUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutBatchesInput
    connect?: PartnerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBatchesCreatedInput = {
    create?: XOR<UserCreateWithoutBatchesCreatedInput, UserUncheckedCreateWithoutBatchesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatchesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutBatchInput = {
    create?: XOR<AccountCreateWithoutBatchInput, AccountUncheckedCreateWithoutBatchInput> | AccountCreateWithoutBatchInput[] | AccountUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutBatchInput | AccountCreateOrConnectWithoutBatchInput[]
    createMany?: AccountCreateManyBatchInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutBatchInput = {
    create?: XOR<AccountCreateWithoutBatchInput, AccountUncheckedCreateWithoutBatchInput> | AccountCreateWithoutBatchInput[] | AccountUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutBatchInput | AccountCreateOrConnectWithoutBatchInput[]
    createMany?: AccountCreateManyBatchInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type EnumBatchStatusFieldUpdateOperationsInput = {
    set?: $Enums.BatchStatus
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PartnerUpdateOneWithoutBatchesNestedInput = {
    create?: XOR<PartnerCreateWithoutBatchesInput, PartnerUncheckedCreateWithoutBatchesInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutBatchesInput
    upsert?: PartnerUpsertWithoutBatchesInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutBatchesInput, PartnerUpdateWithoutBatchesInput>, PartnerUncheckedUpdateWithoutBatchesInput>
  }

  export type UserUpdateOneRequiredWithoutBatchesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutBatchesCreatedInput, UserUncheckedCreateWithoutBatchesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutBatchesCreatedInput
    upsert?: UserUpsertWithoutBatchesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBatchesCreatedInput, UserUpdateWithoutBatchesCreatedInput>, UserUncheckedUpdateWithoutBatchesCreatedInput>
  }

  export type AccountUpdateManyWithoutBatchNestedInput = {
    create?: XOR<AccountCreateWithoutBatchInput, AccountUncheckedCreateWithoutBatchInput> | AccountCreateWithoutBatchInput[] | AccountUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutBatchInput | AccountCreateOrConnectWithoutBatchInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutBatchInput | AccountUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: AccountCreateManyBatchInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutBatchInput | AccountUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutBatchInput | AccountUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutBatchNestedInput = {
    create?: XOR<AccountCreateWithoutBatchInput, AccountUncheckedCreateWithoutBatchInput> | AccountCreateWithoutBatchInput[] | AccountUncheckedCreateWithoutBatchInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutBatchInput | AccountCreateOrConnectWithoutBatchInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutBatchInput | AccountUpsertWithWhereUniqueWithoutBatchInput[]
    createMany?: AccountCreateManyBatchInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutBatchInput | AccountUpdateWithWhereUniqueWithoutBatchInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutBatchInput | AccountUpdateManyWithWhereWithoutBatchInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type PartnerCreateNestedOneWithoutInvoiceMCCsInput = {
    create?: XOR<PartnerCreateWithoutInvoiceMCCsInput, PartnerUncheckedCreateWithoutInvoiceMCCsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutInvoiceMCCsInput
    connect?: PartnerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoiceMCCsCreatedInput = {
    create?: XOR<UserCreateWithoutInvoiceMCCsCreatedInput, UserUncheckedCreateWithoutInvoiceMCCsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceMCCsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutCurrentMiInput = {
    create?: XOR<AccountCreateWithoutCurrentMiInput, AccountUncheckedCreateWithoutCurrentMiInput> | AccountCreateWithoutCurrentMiInput[] | AccountUncheckedCreateWithoutCurrentMiInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCurrentMiInput | AccountCreateOrConnectWithoutCurrentMiInput[]
    createMany?: AccountCreateManyCurrentMiInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountMIHistoryCreateNestedManyWithoutInvoiceMccInput = {
    create?: XOR<AccountMIHistoryCreateWithoutInvoiceMccInput, AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput> | AccountMIHistoryCreateWithoutInvoiceMccInput[] | AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput | AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput[]
    createMany?: AccountMIHistoryCreateManyInvoiceMccInputEnvelope
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
  }

  export type SpendingSnapshotCreateNestedManyWithoutInvoiceMccInput = {
    create?: XOR<SpendingSnapshotCreateWithoutInvoiceMccInput, SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput> | SpendingSnapshotCreateWithoutInvoiceMccInput[] | SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput | SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput[]
    createMany?: SpendingSnapshotCreateManyInvoiceMccInputEnvelope
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
  }

  export type SpendingRecordCreateNestedManyWithoutInvoiceMccInput = {
    create?: XOR<SpendingRecordCreateWithoutInvoiceMccInput, SpendingRecordUncheckedCreateWithoutInvoiceMccInput> | SpendingRecordCreateWithoutInvoiceMccInput[] | SpendingRecordUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutInvoiceMccInput | SpendingRecordCreateOrConnectWithoutInvoiceMccInput[]
    createMany?: SpendingRecordCreateManyInvoiceMccInputEnvelope
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutCurrentMiInput = {
    create?: XOR<AccountCreateWithoutCurrentMiInput, AccountUncheckedCreateWithoutCurrentMiInput> | AccountCreateWithoutCurrentMiInput[] | AccountUncheckedCreateWithoutCurrentMiInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCurrentMiInput | AccountCreateOrConnectWithoutCurrentMiInput[]
    createMany?: AccountCreateManyCurrentMiInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountMIHistoryUncheckedCreateNestedManyWithoutInvoiceMccInput = {
    create?: XOR<AccountMIHistoryCreateWithoutInvoiceMccInput, AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput> | AccountMIHistoryCreateWithoutInvoiceMccInput[] | AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput | AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput[]
    createMany?: AccountMIHistoryCreateManyInvoiceMccInputEnvelope
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
  }

  export type SpendingSnapshotUncheckedCreateNestedManyWithoutInvoiceMccInput = {
    create?: XOR<SpendingSnapshotCreateWithoutInvoiceMccInput, SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput> | SpendingSnapshotCreateWithoutInvoiceMccInput[] | SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput | SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput[]
    createMany?: SpendingSnapshotCreateManyInvoiceMccInputEnvelope
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
  }

  export type SpendingRecordUncheckedCreateNestedManyWithoutInvoiceMccInput = {
    create?: XOR<SpendingRecordCreateWithoutInvoiceMccInput, SpendingRecordUncheckedCreateWithoutInvoiceMccInput> | SpendingRecordCreateWithoutInvoiceMccInput[] | SpendingRecordUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutInvoiceMccInput | SpendingRecordCreateOrConnectWithoutInvoiceMccInput[]
    createMany?: SpendingRecordCreateManyInvoiceMccInputEnvelope
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
  }

  export type EnumInvoiceMCCStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceMCCStatus
  }

  export type EnumCreditStatusFieldUpdateOperationsInput = {
    set?: $Enums.CreditStatus
  }

  export type PartnerUpdateOneWithoutInvoiceMCCsNestedInput = {
    create?: XOR<PartnerCreateWithoutInvoiceMCCsInput, PartnerUncheckedCreateWithoutInvoiceMCCsInput>
    connectOrCreate?: PartnerCreateOrConnectWithoutInvoiceMCCsInput
    upsert?: PartnerUpsertWithoutInvoiceMCCsInput
    disconnect?: PartnerWhereInput | boolean
    delete?: PartnerWhereInput | boolean
    connect?: PartnerWhereUniqueInput
    update?: XOR<XOR<PartnerUpdateToOneWithWhereWithoutInvoiceMCCsInput, PartnerUpdateWithoutInvoiceMCCsInput>, PartnerUncheckedUpdateWithoutInvoiceMCCsInput>
  }

  export type UserUpdateOneRequiredWithoutInvoiceMCCsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutInvoiceMCCsCreatedInput, UserUncheckedCreateWithoutInvoiceMCCsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoiceMCCsCreatedInput
    upsert?: UserUpsertWithoutInvoiceMCCsCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoiceMCCsCreatedInput, UserUpdateWithoutInvoiceMCCsCreatedInput>, UserUncheckedUpdateWithoutInvoiceMCCsCreatedInput>
  }

  export type AccountUpdateManyWithoutCurrentMiNestedInput = {
    create?: XOR<AccountCreateWithoutCurrentMiInput, AccountUncheckedCreateWithoutCurrentMiInput> | AccountCreateWithoutCurrentMiInput[] | AccountUncheckedCreateWithoutCurrentMiInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCurrentMiInput | AccountCreateOrConnectWithoutCurrentMiInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCurrentMiInput | AccountUpsertWithWhereUniqueWithoutCurrentMiInput[]
    createMany?: AccountCreateManyCurrentMiInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCurrentMiInput | AccountUpdateWithWhereUniqueWithoutCurrentMiInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCurrentMiInput | AccountUpdateManyWithWhereWithoutCurrentMiInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountMIHistoryUpdateManyWithoutInvoiceMccNestedInput = {
    create?: XOR<AccountMIHistoryCreateWithoutInvoiceMccInput, AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput> | AccountMIHistoryCreateWithoutInvoiceMccInput[] | AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput | AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput[]
    upsert?: AccountMIHistoryUpsertWithWhereUniqueWithoutInvoiceMccInput | AccountMIHistoryUpsertWithWhereUniqueWithoutInvoiceMccInput[]
    createMany?: AccountMIHistoryCreateManyInvoiceMccInputEnvelope
    set?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    disconnect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    delete?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    update?: AccountMIHistoryUpdateWithWhereUniqueWithoutInvoiceMccInput | AccountMIHistoryUpdateWithWhereUniqueWithoutInvoiceMccInput[]
    updateMany?: AccountMIHistoryUpdateManyWithWhereWithoutInvoiceMccInput | AccountMIHistoryUpdateManyWithWhereWithoutInvoiceMccInput[]
    deleteMany?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
  }

  export type SpendingSnapshotUpdateManyWithoutInvoiceMccNestedInput = {
    create?: XOR<SpendingSnapshotCreateWithoutInvoiceMccInput, SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput> | SpendingSnapshotCreateWithoutInvoiceMccInput[] | SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput | SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput[]
    upsert?: SpendingSnapshotUpsertWithWhereUniqueWithoutInvoiceMccInput | SpendingSnapshotUpsertWithWhereUniqueWithoutInvoiceMccInput[]
    createMany?: SpendingSnapshotCreateManyInvoiceMccInputEnvelope
    set?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    disconnect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    delete?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    update?: SpendingSnapshotUpdateWithWhereUniqueWithoutInvoiceMccInput | SpendingSnapshotUpdateWithWhereUniqueWithoutInvoiceMccInput[]
    updateMany?: SpendingSnapshotUpdateManyWithWhereWithoutInvoiceMccInput | SpendingSnapshotUpdateManyWithWhereWithoutInvoiceMccInput[]
    deleteMany?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
  }

  export type SpendingRecordUpdateManyWithoutInvoiceMccNestedInput = {
    create?: XOR<SpendingRecordCreateWithoutInvoiceMccInput, SpendingRecordUncheckedCreateWithoutInvoiceMccInput> | SpendingRecordCreateWithoutInvoiceMccInput[] | SpendingRecordUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutInvoiceMccInput | SpendingRecordCreateOrConnectWithoutInvoiceMccInput[]
    upsert?: SpendingRecordUpsertWithWhereUniqueWithoutInvoiceMccInput | SpendingRecordUpsertWithWhereUniqueWithoutInvoiceMccInput[]
    createMany?: SpendingRecordCreateManyInvoiceMccInputEnvelope
    set?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    disconnect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    delete?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    update?: SpendingRecordUpdateWithWhereUniqueWithoutInvoiceMccInput | SpendingRecordUpdateWithWhereUniqueWithoutInvoiceMccInput[]
    updateMany?: SpendingRecordUpdateManyWithWhereWithoutInvoiceMccInput | SpendingRecordUpdateManyWithWhereWithoutInvoiceMccInput[]
    deleteMany?: SpendingRecordScalarWhereInput | SpendingRecordScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutCurrentMiNestedInput = {
    create?: XOR<AccountCreateWithoutCurrentMiInput, AccountUncheckedCreateWithoutCurrentMiInput> | AccountCreateWithoutCurrentMiInput[] | AccountUncheckedCreateWithoutCurrentMiInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCurrentMiInput | AccountCreateOrConnectWithoutCurrentMiInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCurrentMiInput | AccountUpsertWithWhereUniqueWithoutCurrentMiInput[]
    createMany?: AccountCreateManyCurrentMiInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCurrentMiInput | AccountUpdateWithWhereUniqueWithoutCurrentMiInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCurrentMiInput | AccountUpdateManyWithWhereWithoutCurrentMiInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccNestedInput = {
    create?: XOR<AccountMIHistoryCreateWithoutInvoiceMccInput, AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput> | AccountMIHistoryCreateWithoutInvoiceMccInput[] | AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput | AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput[]
    upsert?: AccountMIHistoryUpsertWithWhereUniqueWithoutInvoiceMccInput | AccountMIHistoryUpsertWithWhereUniqueWithoutInvoiceMccInput[]
    createMany?: AccountMIHistoryCreateManyInvoiceMccInputEnvelope
    set?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    disconnect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    delete?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    update?: AccountMIHistoryUpdateWithWhereUniqueWithoutInvoiceMccInput | AccountMIHistoryUpdateWithWhereUniqueWithoutInvoiceMccInput[]
    updateMany?: AccountMIHistoryUpdateManyWithWhereWithoutInvoiceMccInput | AccountMIHistoryUpdateManyWithWhereWithoutInvoiceMccInput[]
    deleteMany?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
  }

  export type SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccNestedInput = {
    create?: XOR<SpendingSnapshotCreateWithoutInvoiceMccInput, SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput> | SpendingSnapshotCreateWithoutInvoiceMccInput[] | SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput | SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput[]
    upsert?: SpendingSnapshotUpsertWithWhereUniqueWithoutInvoiceMccInput | SpendingSnapshotUpsertWithWhereUniqueWithoutInvoiceMccInput[]
    createMany?: SpendingSnapshotCreateManyInvoiceMccInputEnvelope
    set?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    disconnect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    delete?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    update?: SpendingSnapshotUpdateWithWhereUniqueWithoutInvoiceMccInput | SpendingSnapshotUpdateWithWhereUniqueWithoutInvoiceMccInput[]
    updateMany?: SpendingSnapshotUpdateManyWithWhereWithoutInvoiceMccInput | SpendingSnapshotUpdateManyWithWhereWithoutInvoiceMccInput[]
    deleteMany?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
  }

  export type SpendingRecordUncheckedUpdateManyWithoutInvoiceMccNestedInput = {
    create?: XOR<SpendingRecordCreateWithoutInvoiceMccInput, SpendingRecordUncheckedCreateWithoutInvoiceMccInput> | SpendingRecordCreateWithoutInvoiceMccInput[] | SpendingRecordUncheckedCreateWithoutInvoiceMccInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutInvoiceMccInput | SpendingRecordCreateOrConnectWithoutInvoiceMccInput[]
    upsert?: SpendingRecordUpsertWithWhereUniqueWithoutInvoiceMccInput | SpendingRecordUpsertWithWhereUniqueWithoutInvoiceMccInput[]
    createMany?: SpendingRecordCreateManyInvoiceMccInputEnvelope
    set?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    disconnect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    delete?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    update?: SpendingRecordUpdateWithWhereUniqueWithoutInvoiceMccInput | SpendingRecordUpdateWithWhereUniqueWithoutInvoiceMccInput[]
    updateMany?: SpendingRecordUpdateManyWithWhereWithoutInvoiceMccInput | SpendingRecordUpdateManyWithWhereWithoutInvoiceMccInput[]
    deleteMany?: SpendingRecordScalarWhereInput | SpendingRecordScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCustomersAssignedInput = {
    create?: XOR<UserCreateWithoutCustomersAssignedInput, UserUncheckedCreateWithoutCustomersAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomersAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutCurrentMcInput = {
    create?: XOR<AccountCreateWithoutCurrentMcInput, AccountUncheckedCreateWithoutCurrentMcInput> | AccountCreateWithoutCurrentMcInput[] | AccountUncheckedCreateWithoutCurrentMcInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCurrentMcInput | AccountCreateOrConnectWithoutCurrentMcInput[]
    createMany?: AccountCreateManyCurrentMcInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountMCHistoryCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AccountMCHistoryCreateWithoutCustomerInput, AccountMCHistoryUncheckedCreateWithoutCustomerInput> | AccountMCHistoryCreateWithoutCustomerInput[] | AccountMCHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutCustomerInput | AccountMCHistoryCreateOrConnectWithoutCustomerInput[]
    createMany?: AccountMCHistoryCreateManyCustomerInputEnvelope
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
  }

  export type SpendingSnapshotCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SpendingSnapshotCreateWithoutCustomerInput, SpendingSnapshotUncheckedCreateWithoutCustomerInput> | SpendingSnapshotCreateWithoutCustomerInput[] | SpendingSnapshotUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutCustomerInput | SpendingSnapshotCreateOrConnectWithoutCustomerInput[]
    createMany?: SpendingSnapshotCreateManyCustomerInputEnvelope
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
  }

  export type SpendingRecordCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SpendingRecordCreateWithoutCustomerInput, SpendingRecordUncheckedCreateWithoutCustomerInput> | SpendingRecordCreateWithoutCustomerInput[] | SpendingRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutCustomerInput | SpendingRecordCreateOrConnectWithoutCustomerInput[]
    createMany?: SpendingRecordCreateManyCustomerInputEnvelope
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutCurrentMcInput = {
    create?: XOR<AccountCreateWithoutCurrentMcInput, AccountUncheckedCreateWithoutCurrentMcInput> | AccountCreateWithoutCurrentMcInput[] | AccountUncheckedCreateWithoutCurrentMcInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCurrentMcInput | AccountCreateOrConnectWithoutCurrentMcInput[]
    createMany?: AccountCreateManyCurrentMcInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type AccountMCHistoryUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<AccountMCHistoryCreateWithoutCustomerInput, AccountMCHistoryUncheckedCreateWithoutCustomerInput> | AccountMCHistoryCreateWithoutCustomerInput[] | AccountMCHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutCustomerInput | AccountMCHistoryCreateOrConnectWithoutCustomerInput[]
    createMany?: AccountMCHistoryCreateManyCustomerInputEnvelope
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
  }

  export type SpendingSnapshotUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SpendingSnapshotCreateWithoutCustomerInput, SpendingSnapshotUncheckedCreateWithoutCustomerInput> | SpendingSnapshotCreateWithoutCustomerInput[] | SpendingSnapshotUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutCustomerInput | SpendingSnapshotCreateOrConnectWithoutCustomerInput[]
    createMany?: SpendingSnapshotCreateManyCustomerInputEnvelope
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
  }

  export type SpendingRecordUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<SpendingRecordCreateWithoutCustomerInput, SpendingRecordUncheckedCreateWithoutCustomerInput> | SpendingRecordCreateWithoutCustomerInput[] | SpendingRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutCustomerInput | SpendingRecordCreateOrConnectWithoutCustomerInput[]
    createMany?: SpendingRecordCreateManyCustomerInputEnvelope
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
  }

  export type EnumCustomerStatusFieldUpdateOperationsInput = {
    set?: $Enums.CustomerStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneWithoutCustomersAssignedNestedInput = {
    create?: XOR<UserCreateWithoutCustomersAssignedInput, UserUncheckedCreateWithoutCustomersAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutCustomersAssignedInput
    upsert?: UserUpsertWithoutCustomersAssignedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCustomersAssignedInput, UserUpdateWithoutCustomersAssignedInput>, UserUncheckedUpdateWithoutCustomersAssignedInput>
  }

  export type AccountUpdateManyWithoutCurrentMcNestedInput = {
    create?: XOR<AccountCreateWithoutCurrentMcInput, AccountUncheckedCreateWithoutCurrentMcInput> | AccountCreateWithoutCurrentMcInput[] | AccountUncheckedCreateWithoutCurrentMcInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCurrentMcInput | AccountCreateOrConnectWithoutCurrentMcInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCurrentMcInput | AccountUpsertWithWhereUniqueWithoutCurrentMcInput[]
    createMany?: AccountCreateManyCurrentMcInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCurrentMcInput | AccountUpdateWithWhereUniqueWithoutCurrentMcInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCurrentMcInput | AccountUpdateManyWithWhereWithoutCurrentMcInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountMCHistoryUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AccountMCHistoryCreateWithoutCustomerInput, AccountMCHistoryUncheckedCreateWithoutCustomerInput> | AccountMCHistoryCreateWithoutCustomerInput[] | AccountMCHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutCustomerInput | AccountMCHistoryCreateOrConnectWithoutCustomerInput[]
    upsert?: AccountMCHistoryUpsertWithWhereUniqueWithoutCustomerInput | AccountMCHistoryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AccountMCHistoryCreateManyCustomerInputEnvelope
    set?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    disconnect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    delete?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    update?: AccountMCHistoryUpdateWithWhereUniqueWithoutCustomerInput | AccountMCHistoryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AccountMCHistoryUpdateManyWithWhereWithoutCustomerInput | AccountMCHistoryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
  }

  export type SpendingSnapshotUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SpendingSnapshotCreateWithoutCustomerInput, SpendingSnapshotUncheckedCreateWithoutCustomerInput> | SpendingSnapshotCreateWithoutCustomerInput[] | SpendingSnapshotUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutCustomerInput | SpendingSnapshotCreateOrConnectWithoutCustomerInput[]
    upsert?: SpendingSnapshotUpsertWithWhereUniqueWithoutCustomerInput | SpendingSnapshotUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SpendingSnapshotCreateManyCustomerInputEnvelope
    set?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    disconnect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    delete?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    update?: SpendingSnapshotUpdateWithWhereUniqueWithoutCustomerInput | SpendingSnapshotUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SpendingSnapshotUpdateManyWithWhereWithoutCustomerInput | SpendingSnapshotUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
  }

  export type SpendingRecordUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SpendingRecordCreateWithoutCustomerInput, SpendingRecordUncheckedCreateWithoutCustomerInput> | SpendingRecordCreateWithoutCustomerInput[] | SpendingRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutCustomerInput | SpendingRecordCreateOrConnectWithoutCustomerInput[]
    upsert?: SpendingRecordUpsertWithWhereUniqueWithoutCustomerInput | SpendingRecordUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SpendingRecordCreateManyCustomerInputEnvelope
    set?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    disconnect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    delete?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    update?: SpendingRecordUpdateWithWhereUniqueWithoutCustomerInput | SpendingRecordUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SpendingRecordUpdateManyWithWhereWithoutCustomerInput | SpendingRecordUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SpendingRecordScalarWhereInput | SpendingRecordScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutCurrentMcNestedInput = {
    create?: XOR<AccountCreateWithoutCurrentMcInput, AccountUncheckedCreateWithoutCurrentMcInput> | AccountCreateWithoutCurrentMcInput[] | AccountUncheckedCreateWithoutCurrentMcInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutCurrentMcInput | AccountCreateOrConnectWithoutCurrentMcInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutCurrentMcInput | AccountUpsertWithWhereUniqueWithoutCurrentMcInput[]
    createMany?: AccountCreateManyCurrentMcInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutCurrentMcInput | AccountUpdateWithWhereUniqueWithoutCurrentMcInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutCurrentMcInput | AccountUpdateManyWithWhereWithoutCurrentMcInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type AccountMCHistoryUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<AccountMCHistoryCreateWithoutCustomerInput, AccountMCHistoryUncheckedCreateWithoutCustomerInput> | AccountMCHistoryCreateWithoutCustomerInput[] | AccountMCHistoryUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutCustomerInput | AccountMCHistoryCreateOrConnectWithoutCustomerInput[]
    upsert?: AccountMCHistoryUpsertWithWhereUniqueWithoutCustomerInput | AccountMCHistoryUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: AccountMCHistoryCreateManyCustomerInputEnvelope
    set?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    disconnect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    delete?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    update?: AccountMCHistoryUpdateWithWhereUniqueWithoutCustomerInput | AccountMCHistoryUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: AccountMCHistoryUpdateManyWithWhereWithoutCustomerInput | AccountMCHistoryUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
  }

  export type SpendingSnapshotUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SpendingSnapshotCreateWithoutCustomerInput, SpendingSnapshotUncheckedCreateWithoutCustomerInput> | SpendingSnapshotCreateWithoutCustomerInput[] | SpendingSnapshotUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutCustomerInput | SpendingSnapshotCreateOrConnectWithoutCustomerInput[]
    upsert?: SpendingSnapshotUpsertWithWhereUniqueWithoutCustomerInput | SpendingSnapshotUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SpendingSnapshotCreateManyCustomerInputEnvelope
    set?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    disconnect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    delete?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    update?: SpendingSnapshotUpdateWithWhereUniqueWithoutCustomerInput | SpendingSnapshotUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SpendingSnapshotUpdateManyWithWhereWithoutCustomerInput | SpendingSnapshotUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
  }

  export type SpendingRecordUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<SpendingRecordCreateWithoutCustomerInput, SpendingRecordUncheckedCreateWithoutCustomerInput> | SpendingRecordCreateWithoutCustomerInput[] | SpendingRecordUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutCustomerInput | SpendingRecordCreateOrConnectWithoutCustomerInput[]
    upsert?: SpendingRecordUpsertWithWhereUniqueWithoutCustomerInput | SpendingRecordUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: SpendingRecordCreateManyCustomerInputEnvelope
    set?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    disconnect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    delete?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    update?: SpendingRecordUpdateWithWhereUniqueWithoutCustomerInput | SpendingRecordUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: SpendingRecordUpdateManyWithWhereWithoutCustomerInput | SpendingRecordUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: SpendingRecordScalarWhereInput | SpendingRecordScalarWhereInput[]
  }

  export type AccountBatchCreateNestedOneWithoutAccountsInput = {
    create?: XOR<AccountBatchCreateWithoutAccountsInput, AccountBatchUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: AccountBatchCreateOrConnectWithoutAccountsInput
    connect?: AccountBatchWhereUniqueInput
  }

  export type InvoiceMCCCreateNestedOneWithoutAccountsInput = {
    create?: XOR<InvoiceMCCCreateWithoutAccountsInput, InvoiceMCCUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutAccountsInput
    connect?: InvoiceMCCWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutAccountsInput = {
    create?: XOR<CustomerCreateWithoutAccountsInput, CustomerUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountsInput
    connect?: CustomerWhereUniqueInput
  }

  export type AccountMIHistoryCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountMIHistoryCreateWithoutAccountInput, AccountMIHistoryUncheckedCreateWithoutAccountInput> | AccountMIHistoryCreateWithoutAccountInput[] | AccountMIHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutAccountInput | AccountMIHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: AccountMIHistoryCreateManyAccountInputEnvelope
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
  }

  export type AccountMCHistoryCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountMCHistoryCreateWithoutAccountInput, AccountMCHistoryUncheckedCreateWithoutAccountInput> | AccountMCHistoryCreateWithoutAccountInput[] | AccountMCHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutAccountInput | AccountMCHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: AccountMCHistoryCreateManyAccountInputEnvelope
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
  }

  export type SpendingSnapshotCreateNestedManyWithoutAccountInput = {
    create?: XOR<SpendingSnapshotCreateWithoutAccountInput, SpendingSnapshotUncheckedCreateWithoutAccountInput> | SpendingSnapshotCreateWithoutAccountInput[] | SpendingSnapshotUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutAccountInput | SpendingSnapshotCreateOrConnectWithoutAccountInput[]
    createMany?: SpendingSnapshotCreateManyAccountInputEnvelope
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
  }

  export type SpendingRecordCreateNestedManyWithoutAccountInput = {
    create?: XOR<SpendingRecordCreateWithoutAccountInput, SpendingRecordUncheckedCreateWithoutAccountInput> | SpendingRecordCreateWithoutAccountInput[] | SpendingRecordUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutAccountInput | SpendingRecordCreateOrConnectWithoutAccountInput[]
    createMany?: SpendingRecordCreateManyAccountInputEnvelope
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
  }

  export type AccountMIHistoryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountMIHistoryCreateWithoutAccountInput, AccountMIHistoryUncheckedCreateWithoutAccountInput> | AccountMIHistoryCreateWithoutAccountInput[] | AccountMIHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutAccountInput | AccountMIHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: AccountMIHistoryCreateManyAccountInputEnvelope
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
  }

  export type AccountMCHistoryUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountMCHistoryCreateWithoutAccountInput, AccountMCHistoryUncheckedCreateWithoutAccountInput> | AccountMCHistoryCreateWithoutAccountInput[] | AccountMCHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutAccountInput | AccountMCHistoryCreateOrConnectWithoutAccountInput[]
    createMany?: AccountMCHistoryCreateManyAccountInputEnvelope
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
  }

  export type SpendingSnapshotUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<SpendingSnapshotCreateWithoutAccountInput, SpendingSnapshotUncheckedCreateWithoutAccountInput> | SpendingSnapshotCreateWithoutAccountInput[] | SpendingSnapshotUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutAccountInput | SpendingSnapshotCreateOrConnectWithoutAccountInput[]
    createMany?: SpendingSnapshotCreateManyAccountInputEnvelope
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
  }

  export type SpendingRecordUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<SpendingRecordCreateWithoutAccountInput, SpendingRecordUncheckedCreateWithoutAccountInput> | SpendingRecordCreateWithoutAccountInput[] | SpendingRecordUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutAccountInput | SpendingRecordCreateOrConnectWithoutAccountInput[]
    createMany?: SpendingRecordCreateManyAccountInputEnvelope
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
  }

  export type EnumAccountStatusFieldUpdateOperationsInput = {
    set?: $Enums.AccountStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AccountBatchUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<AccountBatchCreateWithoutAccountsInput, AccountBatchUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: AccountBatchCreateOrConnectWithoutAccountsInput
    upsert?: AccountBatchUpsertWithoutAccountsInput
    connect?: AccountBatchWhereUniqueInput
    update?: XOR<XOR<AccountBatchUpdateToOneWithWhereWithoutAccountsInput, AccountBatchUpdateWithoutAccountsInput>, AccountBatchUncheckedUpdateWithoutAccountsInput>
  }

  export type InvoiceMCCUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<InvoiceMCCCreateWithoutAccountsInput, InvoiceMCCUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutAccountsInput
    upsert?: InvoiceMCCUpsertWithoutAccountsInput
    disconnect?: InvoiceMCCWhereInput | boolean
    delete?: InvoiceMCCWhereInput | boolean
    connect?: InvoiceMCCWhereUniqueInput
    update?: XOR<XOR<InvoiceMCCUpdateToOneWithWhereWithoutAccountsInput, InvoiceMCCUpdateWithoutAccountsInput>, InvoiceMCCUncheckedUpdateWithoutAccountsInput>
  }

  export type CustomerUpdateOneWithoutAccountsNestedInput = {
    create?: XOR<CustomerCreateWithoutAccountsInput, CustomerUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutAccountsInput
    upsert?: CustomerUpsertWithoutAccountsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutAccountsInput, CustomerUpdateWithoutAccountsInput>, CustomerUncheckedUpdateWithoutAccountsInput>
  }

  export type AccountMIHistoryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountMIHistoryCreateWithoutAccountInput, AccountMIHistoryUncheckedCreateWithoutAccountInput> | AccountMIHistoryCreateWithoutAccountInput[] | AccountMIHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutAccountInput | AccountMIHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: AccountMIHistoryUpsertWithWhereUniqueWithoutAccountInput | AccountMIHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountMIHistoryCreateManyAccountInputEnvelope
    set?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    disconnect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    delete?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    update?: AccountMIHistoryUpdateWithWhereUniqueWithoutAccountInput | AccountMIHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountMIHistoryUpdateManyWithWhereWithoutAccountInput | AccountMIHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
  }

  export type AccountMCHistoryUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountMCHistoryCreateWithoutAccountInput, AccountMCHistoryUncheckedCreateWithoutAccountInput> | AccountMCHistoryCreateWithoutAccountInput[] | AccountMCHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutAccountInput | AccountMCHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: AccountMCHistoryUpsertWithWhereUniqueWithoutAccountInput | AccountMCHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountMCHistoryCreateManyAccountInputEnvelope
    set?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    disconnect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    delete?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    update?: AccountMCHistoryUpdateWithWhereUniqueWithoutAccountInput | AccountMCHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountMCHistoryUpdateManyWithWhereWithoutAccountInput | AccountMCHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
  }

  export type SpendingSnapshotUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SpendingSnapshotCreateWithoutAccountInput, SpendingSnapshotUncheckedCreateWithoutAccountInput> | SpendingSnapshotCreateWithoutAccountInput[] | SpendingSnapshotUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutAccountInput | SpendingSnapshotCreateOrConnectWithoutAccountInput[]
    upsert?: SpendingSnapshotUpsertWithWhereUniqueWithoutAccountInput | SpendingSnapshotUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SpendingSnapshotCreateManyAccountInputEnvelope
    set?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    disconnect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    delete?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    update?: SpendingSnapshotUpdateWithWhereUniqueWithoutAccountInput | SpendingSnapshotUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SpendingSnapshotUpdateManyWithWhereWithoutAccountInput | SpendingSnapshotUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
  }

  export type SpendingRecordUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SpendingRecordCreateWithoutAccountInput, SpendingRecordUncheckedCreateWithoutAccountInput> | SpendingRecordCreateWithoutAccountInput[] | SpendingRecordUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutAccountInput | SpendingRecordCreateOrConnectWithoutAccountInput[]
    upsert?: SpendingRecordUpsertWithWhereUniqueWithoutAccountInput | SpendingRecordUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SpendingRecordCreateManyAccountInputEnvelope
    set?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    disconnect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    delete?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    update?: SpendingRecordUpdateWithWhereUniqueWithoutAccountInput | SpendingRecordUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SpendingRecordUpdateManyWithWhereWithoutAccountInput | SpendingRecordUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SpendingRecordScalarWhereInput | SpendingRecordScalarWhereInput[]
  }

  export type AccountMIHistoryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountMIHistoryCreateWithoutAccountInput, AccountMIHistoryUncheckedCreateWithoutAccountInput> | AccountMIHistoryCreateWithoutAccountInput[] | AccountMIHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountMIHistoryCreateOrConnectWithoutAccountInput | AccountMIHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: AccountMIHistoryUpsertWithWhereUniqueWithoutAccountInput | AccountMIHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountMIHistoryCreateManyAccountInputEnvelope
    set?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    disconnect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    delete?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    connect?: AccountMIHistoryWhereUniqueInput | AccountMIHistoryWhereUniqueInput[]
    update?: AccountMIHistoryUpdateWithWhereUniqueWithoutAccountInput | AccountMIHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountMIHistoryUpdateManyWithWhereWithoutAccountInput | AccountMIHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
  }

  export type AccountMCHistoryUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountMCHistoryCreateWithoutAccountInput, AccountMCHistoryUncheckedCreateWithoutAccountInput> | AccountMCHistoryCreateWithoutAccountInput[] | AccountMCHistoryUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountMCHistoryCreateOrConnectWithoutAccountInput | AccountMCHistoryCreateOrConnectWithoutAccountInput[]
    upsert?: AccountMCHistoryUpsertWithWhereUniqueWithoutAccountInput | AccountMCHistoryUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountMCHistoryCreateManyAccountInputEnvelope
    set?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    disconnect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    delete?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    connect?: AccountMCHistoryWhereUniqueInput | AccountMCHistoryWhereUniqueInput[]
    update?: AccountMCHistoryUpdateWithWhereUniqueWithoutAccountInput | AccountMCHistoryUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountMCHistoryUpdateManyWithWhereWithoutAccountInput | AccountMCHistoryUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
  }

  export type SpendingSnapshotUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SpendingSnapshotCreateWithoutAccountInput, SpendingSnapshotUncheckedCreateWithoutAccountInput> | SpendingSnapshotCreateWithoutAccountInput[] | SpendingSnapshotUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SpendingSnapshotCreateOrConnectWithoutAccountInput | SpendingSnapshotCreateOrConnectWithoutAccountInput[]
    upsert?: SpendingSnapshotUpsertWithWhereUniqueWithoutAccountInput | SpendingSnapshotUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SpendingSnapshotCreateManyAccountInputEnvelope
    set?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    disconnect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    delete?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    connect?: SpendingSnapshotWhereUniqueInput | SpendingSnapshotWhereUniqueInput[]
    update?: SpendingSnapshotUpdateWithWhereUniqueWithoutAccountInput | SpendingSnapshotUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SpendingSnapshotUpdateManyWithWhereWithoutAccountInput | SpendingSnapshotUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
  }

  export type SpendingRecordUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<SpendingRecordCreateWithoutAccountInput, SpendingRecordUncheckedCreateWithoutAccountInput> | SpendingRecordCreateWithoutAccountInput[] | SpendingRecordUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: SpendingRecordCreateOrConnectWithoutAccountInput | SpendingRecordCreateOrConnectWithoutAccountInput[]
    upsert?: SpendingRecordUpsertWithWhereUniqueWithoutAccountInput | SpendingRecordUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: SpendingRecordCreateManyAccountInputEnvelope
    set?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    disconnect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    delete?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    connect?: SpendingRecordWhereUniqueInput | SpendingRecordWhereUniqueInput[]
    update?: SpendingRecordUpdateWithWhereUniqueWithoutAccountInput | SpendingRecordUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: SpendingRecordUpdateManyWithWhereWithoutAccountInput | SpendingRecordUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: SpendingRecordScalarWhereInput | SpendingRecordScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutMiHistoriesInput = {
    create?: XOR<AccountCreateWithoutMiHistoriesInput, AccountUncheckedCreateWithoutMiHistoriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutMiHistoriesInput
    connect?: AccountWhereUniqueInput
  }

  export type InvoiceMCCCreateNestedOneWithoutMiHistoriesInput = {
    create?: XOR<InvoiceMCCCreateWithoutMiHistoriesInput, InvoiceMCCUncheckedCreateWithoutMiHistoriesInput>
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutMiHistoriesInput
    connect?: InvoiceMCCWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMiHistoriesLinkedInput = {
    create?: XOR<UserCreateWithoutMiHistoriesLinkedInput, UserUncheckedCreateWithoutMiHistoriesLinkedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMiHistoriesLinkedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMiHistoriesUnlinkedInput = {
    create?: XOR<UserCreateWithoutMiHistoriesUnlinkedInput, UserUncheckedCreateWithoutMiHistoriesUnlinkedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMiHistoriesUnlinkedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumHistoryReasonFieldUpdateOperationsInput = {
    set?: $Enums.HistoryReason
  }

  export type AccountUpdateOneRequiredWithoutMiHistoriesNestedInput = {
    create?: XOR<AccountCreateWithoutMiHistoriesInput, AccountUncheckedCreateWithoutMiHistoriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutMiHistoriesInput
    upsert?: AccountUpsertWithoutMiHistoriesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutMiHistoriesInput, AccountUpdateWithoutMiHistoriesInput>, AccountUncheckedUpdateWithoutMiHistoriesInput>
  }

  export type InvoiceMCCUpdateOneRequiredWithoutMiHistoriesNestedInput = {
    create?: XOR<InvoiceMCCCreateWithoutMiHistoriesInput, InvoiceMCCUncheckedCreateWithoutMiHistoriesInput>
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutMiHistoriesInput
    upsert?: InvoiceMCCUpsertWithoutMiHistoriesInput
    connect?: InvoiceMCCWhereUniqueInput
    update?: XOR<XOR<InvoiceMCCUpdateToOneWithWhereWithoutMiHistoriesInput, InvoiceMCCUpdateWithoutMiHistoriesInput>, InvoiceMCCUncheckedUpdateWithoutMiHistoriesInput>
  }

  export type UserUpdateOneRequiredWithoutMiHistoriesLinkedNestedInput = {
    create?: XOR<UserCreateWithoutMiHistoriesLinkedInput, UserUncheckedCreateWithoutMiHistoriesLinkedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMiHistoriesLinkedInput
    upsert?: UserUpsertWithoutMiHistoriesLinkedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMiHistoriesLinkedInput, UserUpdateWithoutMiHistoriesLinkedInput>, UserUncheckedUpdateWithoutMiHistoriesLinkedInput>
  }

  export type UserUpdateOneWithoutMiHistoriesUnlinkedNestedInput = {
    create?: XOR<UserCreateWithoutMiHistoriesUnlinkedInput, UserUncheckedCreateWithoutMiHistoriesUnlinkedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMiHistoriesUnlinkedInput
    upsert?: UserUpsertWithoutMiHistoriesUnlinkedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMiHistoriesUnlinkedInput, UserUpdateWithoutMiHistoriesUnlinkedInput>, UserUncheckedUpdateWithoutMiHistoriesUnlinkedInput>
  }

  export type AccountCreateNestedOneWithoutMcHistoriesInput = {
    create?: XOR<AccountCreateWithoutMcHistoriesInput, AccountUncheckedCreateWithoutMcHistoriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutMcHistoriesInput
    connect?: AccountWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutMcHistoriesInput = {
    create?: XOR<CustomerCreateWithoutMcHistoriesInput, CustomerUncheckedCreateWithoutMcHistoriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMcHistoriesInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMcHistoriesAssignedInput = {
    create?: XOR<UserCreateWithoutMcHistoriesAssignedInput, UserUncheckedCreateWithoutMcHistoriesAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMcHistoriesAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMcHistoriesUnassignedInput = {
    create?: XOR<UserCreateWithoutMcHistoriesUnassignedInput, UserUncheckedCreateWithoutMcHistoriesUnassignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMcHistoriesUnassignedInput
    connect?: UserWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutMcHistoriesNestedInput = {
    create?: XOR<AccountCreateWithoutMcHistoriesInput, AccountUncheckedCreateWithoutMcHistoriesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutMcHistoriesInput
    upsert?: AccountUpsertWithoutMcHistoriesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutMcHistoriesInput, AccountUpdateWithoutMcHistoriesInput>, AccountUncheckedUpdateWithoutMcHistoriesInput>
  }

  export type CustomerUpdateOneRequiredWithoutMcHistoriesNestedInput = {
    create?: XOR<CustomerCreateWithoutMcHistoriesInput, CustomerUncheckedCreateWithoutMcHistoriesInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutMcHistoriesInput
    upsert?: CustomerUpsertWithoutMcHistoriesInput
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutMcHistoriesInput, CustomerUpdateWithoutMcHistoriesInput>, CustomerUncheckedUpdateWithoutMcHistoriesInput>
  }

  export type UserUpdateOneRequiredWithoutMcHistoriesAssignedNestedInput = {
    create?: XOR<UserCreateWithoutMcHistoriesAssignedInput, UserUncheckedCreateWithoutMcHistoriesAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMcHistoriesAssignedInput
    upsert?: UserUpsertWithoutMcHistoriesAssignedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMcHistoriesAssignedInput, UserUpdateWithoutMcHistoriesAssignedInput>, UserUncheckedUpdateWithoutMcHistoriesAssignedInput>
  }

  export type UserUpdateOneWithoutMcHistoriesUnassignedNestedInput = {
    create?: XOR<UserCreateWithoutMcHistoriesUnassignedInput, UserUncheckedCreateWithoutMcHistoriesUnassignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutMcHistoriesUnassignedInput
    upsert?: UserUpsertWithoutMcHistoriesUnassignedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMcHistoriesUnassignedInput, UserUpdateWithoutMcHistoriesUnassignedInput>, UserUncheckedUpdateWithoutMcHistoriesUnassignedInput>
  }

  export type AccountCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<AccountCreateWithoutSnapshotsInput, AccountUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSnapshotsInput
    connect?: AccountWhereUniqueInput
  }

  export type InvoiceMCCCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<InvoiceMCCCreateWithoutSnapshotsInput, InvoiceMCCUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutSnapshotsInput
    connect?: InvoiceMCCWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<CustomerCreateWithoutSnapshotsInput, CustomerUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSnapshotsInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<UserCreateWithoutSnapshotsInput, UserUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSnapshotsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSnapshotTypeFieldUpdateOperationsInput = {
    set?: $Enums.SnapshotType
  }

  export type AccountUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<AccountCreateWithoutSnapshotsInput, AccountUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSnapshotsInput
    upsert?: AccountUpsertWithoutSnapshotsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSnapshotsInput, AccountUpdateWithoutSnapshotsInput>, AccountUncheckedUpdateWithoutSnapshotsInput>
  }

  export type InvoiceMCCUpdateOneWithoutSnapshotsNestedInput = {
    create?: XOR<InvoiceMCCCreateWithoutSnapshotsInput, InvoiceMCCUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutSnapshotsInput
    upsert?: InvoiceMCCUpsertWithoutSnapshotsInput
    disconnect?: InvoiceMCCWhereInput | boolean
    delete?: InvoiceMCCWhereInput | boolean
    connect?: InvoiceMCCWhereUniqueInput
    update?: XOR<XOR<InvoiceMCCUpdateToOneWithWhereWithoutSnapshotsInput, InvoiceMCCUpdateWithoutSnapshotsInput>, InvoiceMCCUncheckedUpdateWithoutSnapshotsInput>
  }

  export type CustomerUpdateOneWithoutSnapshotsNestedInput = {
    create?: XOR<CustomerCreateWithoutSnapshotsInput, CustomerUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSnapshotsInput
    upsert?: CustomerUpsertWithoutSnapshotsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSnapshotsInput, CustomerUpdateWithoutSnapshotsInput>, CustomerUncheckedUpdateWithoutSnapshotsInput>
  }

  export type UserUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<UserCreateWithoutSnapshotsInput, UserUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSnapshotsInput
    upsert?: UserUpsertWithoutSnapshotsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSnapshotsInput, UserUpdateWithoutSnapshotsInput>, UserUncheckedUpdateWithoutSnapshotsInput>
  }

  export type AccountCreateNestedOneWithoutSpendingRecordsInput = {
    create?: XOR<AccountCreateWithoutSpendingRecordsInput, AccountUncheckedCreateWithoutSpendingRecordsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSpendingRecordsInput
    connect?: AccountWhereUniqueInput
  }

  export type InvoiceMCCCreateNestedOneWithoutSpendingRecordsInput = {
    create?: XOR<InvoiceMCCCreateWithoutSpendingRecordsInput, InvoiceMCCUncheckedCreateWithoutSpendingRecordsInput>
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutSpendingRecordsInput
    connect?: InvoiceMCCWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutSpendingRecordsInput = {
    create?: XOR<CustomerCreateWithoutSpendingRecordsInput, CustomerUncheckedCreateWithoutSpendingRecordsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSpendingRecordsInput
    connect?: CustomerWhereUniqueInput
  }

  export type AccountUpdateOneRequiredWithoutSpendingRecordsNestedInput = {
    create?: XOR<AccountCreateWithoutSpendingRecordsInput, AccountUncheckedCreateWithoutSpendingRecordsInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSpendingRecordsInput
    upsert?: AccountUpsertWithoutSpendingRecordsInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSpendingRecordsInput, AccountUpdateWithoutSpendingRecordsInput>, AccountUncheckedUpdateWithoutSpendingRecordsInput>
  }

  export type InvoiceMCCUpdateOneWithoutSpendingRecordsNestedInput = {
    create?: XOR<InvoiceMCCCreateWithoutSpendingRecordsInput, InvoiceMCCUncheckedCreateWithoutSpendingRecordsInput>
    connectOrCreate?: InvoiceMCCCreateOrConnectWithoutSpendingRecordsInput
    upsert?: InvoiceMCCUpsertWithoutSpendingRecordsInput
    disconnect?: InvoiceMCCWhereInput | boolean
    delete?: InvoiceMCCWhereInput | boolean
    connect?: InvoiceMCCWhereUniqueInput
    update?: XOR<XOR<InvoiceMCCUpdateToOneWithWhereWithoutSpendingRecordsInput, InvoiceMCCUpdateWithoutSpendingRecordsInput>, InvoiceMCCUncheckedUpdateWithoutSpendingRecordsInput>
  }

  export type CustomerUpdateOneWithoutSpendingRecordsNestedInput = {
    create?: XOR<CustomerCreateWithoutSpendingRecordsInput, CustomerUncheckedCreateWithoutSpendingRecordsInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutSpendingRecordsInput
    upsert?: CustomerUpsertWithoutSpendingRecordsInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutSpendingRecordsInput, CustomerUpdateWithoutSpendingRecordsInput>, CustomerUncheckedUpdateWithoutSpendingRecordsInput>
  }

  export type UserCreateNestedOneWithoutActivityLogsInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumActivityActionFieldUpdateOperationsInput = {
    set?: $Enums.ActivityAction
  }

  export type UserUpdateOneRequiredWithoutActivityLogsNestedInput = {
    create?: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutActivityLogsInput
    upsert?: UserUpsertWithoutActivityLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutActivityLogsInput, UserUpdateWithoutActivityLogsInput>, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumPartnerTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeFilter<$PrismaModel> | $Enums.PartnerType
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PartnerType | EnumPartnerTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PartnerType[] | ListEnumPartnerTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPartnerTypeWithAggregatesFilter<$PrismaModel> | $Enums.PartnerType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPartnerTypeFilter<$PrismaModel>
    _max?: NestedEnumPartnerTypeFilter<$PrismaModel>
  }

  export type NestedEnumBatchStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusFilter<$PrismaModel> | $Enums.BatchStatus
  }

  export type NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BatchStatus | EnumBatchStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BatchStatus[] | ListEnumBatchStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBatchStatusWithAggregatesFilter<$PrismaModel> | $Enums.BatchStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBatchStatusFilter<$PrismaModel>
    _max?: NestedEnumBatchStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumInvoiceMCCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceMCCStatus | EnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceMCCStatus[] | ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceMCCStatus[] | ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceMCCStatusFilter<$PrismaModel> | $Enums.InvoiceMCCStatus
  }

  export type NestedEnumCreditStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[] | ListEnumCreditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditStatus[] | ListEnumCreditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditStatusFilter<$PrismaModel> | $Enums.CreditStatus
  }

  export type NestedEnumInvoiceMCCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceMCCStatus | EnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceMCCStatus[] | ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceMCCStatus[] | ListEnumInvoiceMCCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceMCCStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceMCCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceMCCStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceMCCStatusFilter<$PrismaModel>
  }

  export type NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CreditStatus | EnumCreditStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CreditStatus[] | ListEnumCreditStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CreditStatus[] | ListEnumCreditStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCreditStatusWithAggregatesFilter<$PrismaModel> | $Enums.CreditStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCreditStatusFilter<$PrismaModel>
    _max?: NestedEnumCreditStatusFilter<$PrismaModel>
  }

  export type NestedEnumCustomerStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerStatus | EnumCustomerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerStatus[] | ListEnumCustomerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerStatus[] | ListEnumCustomerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerStatusFilter<$PrismaModel> | $Enums.CustomerStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCustomerStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CustomerStatus | EnumCustomerStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CustomerStatus[] | ListEnumCustomerStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CustomerStatus[] | ListEnumCustomerStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCustomerStatusWithAggregatesFilter<$PrismaModel> | $Enums.CustomerStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCustomerStatusFilter<$PrismaModel>
    _max?: NestedEnumCustomerStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumAccountStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusFilter<$PrismaModel> | $Enums.AccountStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountStatus | EnumAccountStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountStatus[] | ListEnumAccountStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountStatusWithAggregatesFilter<$PrismaModel> | $Enums.AccountStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountStatusFilter<$PrismaModel>
    _max?: NestedEnumAccountStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumHistoryReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.HistoryReason | EnumHistoryReasonFieldRefInput<$PrismaModel>
    in?: $Enums.HistoryReason[] | ListEnumHistoryReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.HistoryReason[] | ListEnumHistoryReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumHistoryReasonFilter<$PrismaModel> | $Enums.HistoryReason
  }

  export type NestedEnumHistoryReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HistoryReason | EnumHistoryReasonFieldRefInput<$PrismaModel>
    in?: $Enums.HistoryReason[] | ListEnumHistoryReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.HistoryReason[] | ListEnumHistoryReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumHistoryReasonWithAggregatesFilter<$PrismaModel> | $Enums.HistoryReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHistoryReasonFilter<$PrismaModel>
    _max?: NestedEnumHistoryReasonFilter<$PrismaModel>
  }

  export type NestedEnumSnapshotTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotType | EnumSnapshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotTypeFilter<$PrismaModel> | $Enums.SnapshotType
  }

  export type NestedEnumSnapshotTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SnapshotType | EnumSnapshotTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SnapshotType[] | ListEnumSnapshotTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSnapshotTypeWithAggregatesFilter<$PrismaModel> | $Enums.SnapshotType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSnapshotTypeFilter<$PrismaModel>
    _max?: NestedEnumSnapshotTypeFilter<$PrismaModel>
  }

  export type NestedEnumActivityActionFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityAction | EnumActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityAction[] | ListEnumActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityAction[] | ListEnumActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityActionFilter<$PrismaModel> | $Enums.ActivityAction
  }

  export type NestedEnumActivityActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ActivityAction | EnumActivityActionFieldRefInput<$PrismaModel>
    in?: $Enums.ActivityAction[] | ListEnumActivityActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.ActivityAction[] | ListEnumActivityActionFieldRefInput<$PrismaModel>
    not?: NestedEnumActivityActionWithAggregatesFilter<$PrismaModel> | $Enums.ActivityAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumActivityActionFilter<$PrismaModel>
    _max?: NestedEnumActivityActionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CustomerCreateWithoutAssignedStaffInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutCurrentMcInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutCustomerInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAssignedStaffInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMcInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutCustomerInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAssignedStaffInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAssignedStaffInput, CustomerUncheckedCreateWithoutAssignedStaffInput>
  }

  export type CustomerCreateManyAssignedStaffInputEnvelope = {
    data: CustomerCreateManyAssignedStaffInput | CustomerCreateManyAssignedStaffInput[]
    skipDuplicates?: boolean
  }

  export type AccountBatchCreateWithoutCreatedByInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutBatchesInput
    accounts?: AccountCreateNestedManyWithoutBatchInput
  }

  export type AccountBatchUncheckedCreateWithoutCreatedByInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutBatchInput
  }

  export type AccountBatchCreateOrConnectWithoutCreatedByInput = {
    where: AccountBatchWhereUniqueInput
    create: XOR<AccountBatchCreateWithoutCreatedByInput, AccountBatchUncheckedCreateWithoutCreatedByInput>
  }

  export type AccountBatchCreateManyCreatedByInputEnvelope = {
    data: AccountBatchCreateManyCreatedByInput | AccountBatchCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceMCCCreateWithoutCreatedByInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutInvoiceMCCsInput
    accounts?: AccountCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCCreateOrConnectWithoutCreatedByInput = {
    where: InvoiceMCCWhereUniqueInput
    create: XOR<InvoiceMCCCreateWithoutCreatedByInput, InvoiceMCCUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceMCCCreateManyCreatedByInputEnvelope = {
    data: InvoiceMCCCreateManyCreatedByInput | InvoiceMCCCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type AccountMIHistoryCreateWithoutLinkedByInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutMiHistoriesInput
    invoiceMcc: InvoiceMCCCreateNestedOneWithoutMiHistoriesInput
    unlinkedBy?: UserCreateNestedOneWithoutMiHistoriesUnlinkedInput
  }

  export type AccountMIHistoryUncheckedCreateWithoutLinkedByInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    invoiceMccId: string
    unlinkedById?: string | null
  }

  export type AccountMIHistoryCreateOrConnectWithoutLinkedByInput = {
    where: AccountMIHistoryWhereUniqueInput
    create: XOR<AccountMIHistoryCreateWithoutLinkedByInput, AccountMIHistoryUncheckedCreateWithoutLinkedByInput>
  }

  export type AccountMIHistoryCreateManyLinkedByInputEnvelope = {
    data: AccountMIHistoryCreateManyLinkedByInput | AccountMIHistoryCreateManyLinkedByInput[]
    skipDuplicates?: boolean
  }

  export type AccountMIHistoryCreateWithoutUnlinkedByInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutMiHistoriesInput
    invoiceMcc: InvoiceMCCCreateNestedOneWithoutMiHistoriesInput
    linkedBy: UserCreateNestedOneWithoutMiHistoriesLinkedInput
  }

  export type AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    invoiceMccId: string
    linkedById: string
  }

  export type AccountMIHistoryCreateOrConnectWithoutUnlinkedByInput = {
    where: AccountMIHistoryWhereUniqueInput
    create: XOR<AccountMIHistoryCreateWithoutUnlinkedByInput, AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput>
  }

  export type AccountMIHistoryCreateManyUnlinkedByInputEnvelope = {
    data: AccountMIHistoryCreateManyUnlinkedByInput | AccountMIHistoryCreateManyUnlinkedByInput[]
    skipDuplicates?: boolean
  }

  export type AccountMCHistoryCreateWithoutAssignedByInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutMcHistoriesInput
    customer: CustomerCreateNestedOneWithoutMcHistoriesInput
    unassignedBy?: UserCreateNestedOneWithoutMcHistoriesUnassignedInput
  }

  export type AccountMCHistoryUncheckedCreateWithoutAssignedByInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    customerId: string
    unassignedById?: string | null
  }

  export type AccountMCHistoryCreateOrConnectWithoutAssignedByInput = {
    where: AccountMCHistoryWhereUniqueInput
    create: XOR<AccountMCHistoryCreateWithoutAssignedByInput, AccountMCHistoryUncheckedCreateWithoutAssignedByInput>
  }

  export type AccountMCHistoryCreateManyAssignedByInputEnvelope = {
    data: AccountMCHistoryCreateManyAssignedByInput | AccountMCHistoryCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type AccountMCHistoryCreateWithoutUnassignedByInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutMcHistoriesInput
    customer: CustomerCreateNestedOneWithoutMcHistoriesInput
    assignedBy: UserCreateNestedOneWithoutMcHistoriesAssignedInput
  }

  export type AccountMCHistoryUncheckedCreateWithoutUnassignedByInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    customerId: string
    assignedById: string
  }

  export type AccountMCHistoryCreateOrConnectWithoutUnassignedByInput = {
    where: AccountMCHistoryWhereUniqueInput
    create: XOR<AccountMCHistoryCreateWithoutUnassignedByInput, AccountMCHistoryUncheckedCreateWithoutUnassignedByInput>
  }

  export type AccountMCHistoryCreateManyUnassignedByInputEnvelope = {
    data: AccountMCHistoryCreateManyUnassignedByInput | AccountMCHistoryCreateManyUnassignedByInput[]
    skipDuplicates?: boolean
  }

  export type SpendingSnapshotCreateWithoutCreatedByInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutSnapshotsInput
    invoiceMcc?: InvoiceMCCCreateNestedOneWithoutSnapshotsInput
    customer?: CustomerCreateNestedOneWithoutSnapshotsInput
  }

  export type SpendingSnapshotUncheckedCreateWithoutCreatedByInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
    customerId?: string | null
  }

  export type SpendingSnapshotCreateOrConnectWithoutCreatedByInput = {
    where: SpendingSnapshotWhereUniqueInput
    create: XOR<SpendingSnapshotCreateWithoutCreatedByInput, SpendingSnapshotUncheckedCreateWithoutCreatedByInput>
  }

  export type SpendingSnapshotCreateManyCreatedByInputEnvelope = {
    data: SpendingSnapshotCreateManyCreatedByInput | SpendingSnapshotCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ActivityLogCreateWithoutUserInput = {
    id?: string
    action: $Enums.ActivityAction
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: $Enums.ActivityAction
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type ActivityLogCreateOrConnectWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogCreateManyUserInputEnvelope = {
    data: ActivityLogCreateManyUserInput | ActivityLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CustomerUpsertWithWhereUniqueWithoutAssignedStaffInput = {
    where: CustomerWhereUniqueInput
    update: XOR<CustomerUpdateWithoutAssignedStaffInput, CustomerUncheckedUpdateWithoutAssignedStaffInput>
    create: XOR<CustomerCreateWithoutAssignedStaffInput, CustomerUncheckedCreateWithoutAssignedStaffInput>
  }

  export type CustomerUpdateWithWhereUniqueWithoutAssignedStaffInput = {
    where: CustomerWhereUniqueInput
    data: XOR<CustomerUpdateWithoutAssignedStaffInput, CustomerUncheckedUpdateWithoutAssignedStaffInput>
  }

  export type CustomerUpdateManyWithWhereWithoutAssignedStaffInput = {
    where: CustomerScalarWhereInput
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyWithoutAssignedStaffInput>
  }

  export type CustomerScalarWhereInput = {
    AND?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    OR?: CustomerScalarWhereInput[]
    NOT?: CustomerScalarWhereInput | CustomerScalarWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringFilter<"Customer"> | string
    contactInfo?: StringNullableFilter<"Customer"> | string | null
    status?: EnumCustomerStatusFilter<"Customer"> | $Enums.CustomerStatus
    totalSpending?: DecimalFilter<"Customer"> | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFilter<"Customer"> | number
    activeAccounts?: IntFilter<"Customer"> | number
    notes?: StringNullableFilter<"Customer"> | string | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    assignedStaffId?: StringNullableFilter<"Customer"> | string | null
  }

  export type AccountBatchUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: AccountBatchWhereUniqueInput
    update: XOR<AccountBatchUpdateWithoutCreatedByInput, AccountBatchUncheckedUpdateWithoutCreatedByInput>
    create: XOR<AccountBatchCreateWithoutCreatedByInput, AccountBatchUncheckedCreateWithoutCreatedByInput>
  }

  export type AccountBatchUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: AccountBatchWhereUniqueInput
    data: XOR<AccountBatchUpdateWithoutCreatedByInput, AccountBatchUncheckedUpdateWithoutCreatedByInput>
  }

  export type AccountBatchUpdateManyWithWhereWithoutCreatedByInput = {
    where: AccountBatchScalarWhereInput
    data: XOR<AccountBatchUpdateManyMutationInput, AccountBatchUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type AccountBatchScalarWhereInput = {
    AND?: AccountBatchScalarWhereInput | AccountBatchScalarWhereInput[]
    OR?: AccountBatchScalarWhereInput[]
    NOT?: AccountBatchScalarWhereInput | AccountBatchScalarWhereInput[]
    id?: StringFilter<"AccountBatch"> | string
    mccAccountName?: StringNullableFilter<"AccountBatch"> | string | null
    mccAccountId?: StringNullableFilter<"AccountBatch"> | string | null
    isPrelinked?: BoolFilter<"AccountBatch"> | boolean
    status?: EnumBatchStatusFilter<"AccountBatch"> | $Enums.BatchStatus
    totalAccounts?: IntFilter<"AccountBatch"> | number
    liveAccounts?: IntFilter<"AccountBatch"> | number
    timezone?: StringNullableFilter<"AccountBatch"> | string | null
    year?: IntNullableFilter<"AccountBatch"> | number | null
    readiness?: IntFilter<"AccountBatch"> | number
    notes?: StringNullableFilter<"AccountBatch"> | string | null
    createdAt?: DateTimeFilter<"AccountBatch"> | Date | string
    updatedAt?: DateTimeFilter<"AccountBatch"> | Date | string
    partnerId?: StringNullableFilter<"AccountBatch"> | string | null
    createdById?: StringFilter<"AccountBatch"> | string
  }

  export type InvoiceMCCUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceMCCWhereUniqueInput
    update: XOR<InvoiceMCCUpdateWithoutCreatedByInput, InvoiceMCCUncheckedUpdateWithoutCreatedByInput>
    create: XOR<InvoiceMCCCreateWithoutCreatedByInput, InvoiceMCCUncheckedCreateWithoutCreatedByInput>
  }

  export type InvoiceMCCUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: InvoiceMCCWhereUniqueInput
    data: XOR<InvoiceMCCUpdateWithoutCreatedByInput, InvoiceMCCUncheckedUpdateWithoutCreatedByInput>
  }

  export type InvoiceMCCUpdateManyWithWhereWithoutCreatedByInput = {
    where: InvoiceMCCScalarWhereInput
    data: XOR<InvoiceMCCUpdateManyMutationInput, InvoiceMCCUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type InvoiceMCCScalarWhereInput = {
    AND?: InvoiceMCCScalarWhereInput | InvoiceMCCScalarWhereInput[]
    OR?: InvoiceMCCScalarWhereInput[]
    NOT?: InvoiceMCCScalarWhereInput | InvoiceMCCScalarWhereInput[]
    id?: StringFilter<"InvoiceMCC"> | string
    name?: StringFilter<"InvoiceMCC"> | string
    mccInvoiceId?: StringFilter<"InvoiceMCC"> | string
    status?: EnumInvoiceMCCStatusFilter<"InvoiceMCC"> | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFilter<"InvoiceMCC"> | $Enums.CreditStatus
    linkedAccountsCount?: IntFilter<"InvoiceMCC"> | number
    activeAccountsCount?: IntFilter<"InvoiceMCC"> | number
    notes?: StringNullableFilter<"InvoiceMCC"> | string | null
    createdAt?: DateTimeFilter<"InvoiceMCC"> | Date | string
    updatedAt?: DateTimeFilter<"InvoiceMCC"> | Date | string
    partnerId?: StringNullableFilter<"InvoiceMCC"> | string | null
    createdById?: StringFilter<"InvoiceMCC"> | string
  }

  export type AccountMIHistoryUpsertWithWhereUniqueWithoutLinkedByInput = {
    where: AccountMIHistoryWhereUniqueInput
    update: XOR<AccountMIHistoryUpdateWithoutLinkedByInput, AccountMIHistoryUncheckedUpdateWithoutLinkedByInput>
    create: XOR<AccountMIHistoryCreateWithoutLinkedByInput, AccountMIHistoryUncheckedCreateWithoutLinkedByInput>
  }

  export type AccountMIHistoryUpdateWithWhereUniqueWithoutLinkedByInput = {
    where: AccountMIHistoryWhereUniqueInput
    data: XOR<AccountMIHistoryUpdateWithoutLinkedByInput, AccountMIHistoryUncheckedUpdateWithoutLinkedByInput>
  }

  export type AccountMIHistoryUpdateManyWithWhereWithoutLinkedByInput = {
    where: AccountMIHistoryScalarWhereInput
    data: XOR<AccountMIHistoryUpdateManyMutationInput, AccountMIHistoryUncheckedUpdateManyWithoutLinkedByInput>
  }

  export type AccountMIHistoryScalarWhereInput = {
    AND?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
    OR?: AccountMIHistoryScalarWhereInput[]
    NOT?: AccountMIHistoryScalarWhereInput | AccountMIHistoryScalarWhereInput[]
    id?: StringFilter<"AccountMIHistory"> | string
    linkedAt?: DateTimeFilter<"AccountMIHistory"> | Date | string
    unlinkedAt?: DateTimeNullableFilter<"AccountMIHistory"> | Date | string | null
    reason?: EnumHistoryReasonFilter<"AccountMIHistory"> | $Enums.HistoryReason
    notes?: StringNullableFilter<"AccountMIHistory"> | string | null
    createdAt?: DateTimeFilter<"AccountMIHistory"> | Date | string
    accountId?: StringFilter<"AccountMIHistory"> | string
    invoiceMccId?: StringFilter<"AccountMIHistory"> | string
    linkedById?: StringFilter<"AccountMIHistory"> | string
    unlinkedById?: StringNullableFilter<"AccountMIHistory"> | string | null
  }

  export type AccountMIHistoryUpsertWithWhereUniqueWithoutUnlinkedByInput = {
    where: AccountMIHistoryWhereUniqueInput
    update: XOR<AccountMIHistoryUpdateWithoutUnlinkedByInput, AccountMIHistoryUncheckedUpdateWithoutUnlinkedByInput>
    create: XOR<AccountMIHistoryCreateWithoutUnlinkedByInput, AccountMIHistoryUncheckedCreateWithoutUnlinkedByInput>
  }

  export type AccountMIHistoryUpdateWithWhereUniqueWithoutUnlinkedByInput = {
    where: AccountMIHistoryWhereUniqueInput
    data: XOR<AccountMIHistoryUpdateWithoutUnlinkedByInput, AccountMIHistoryUncheckedUpdateWithoutUnlinkedByInput>
  }

  export type AccountMIHistoryUpdateManyWithWhereWithoutUnlinkedByInput = {
    where: AccountMIHistoryScalarWhereInput
    data: XOR<AccountMIHistoryUpdateManyMutationInput, AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByInput>
  }

  export type AccountMCHistoryUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: AccountMCHistoryWhereUniqueInput
    update: XOR<AccountMCHistoryUpdateWithoutAssignedByInput, AccountMCHistoryUncheckedUpdateWithoutAssignedByInput>
    create: XOR<AccountMCHistoryCreateWithoutAssignedByInput, AccountMCHistoryUncheckedCreateWithoutAssignedByInput>
  }

  export type AccountMCHistoryUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: AccountMCHistoryWhereUniqueInput
    data: XOR<AccountMCHistoryUpdateWithoutAssignedByInput, AccountMCHistoryUncheckedUpdateWithoutAssignedByInput>
  }

  export type AccountMCHistoryUpdateManyWithWhereWithoutAssignedByInput = {
    where: AccountMCHistoryScalarWhereInput
    data: XOR<AccountMCHistoryUpdateManyMutationInput, AccountMCHistoryUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type AccountMCHistoryScalarWhereInput = {
    AND?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
    OR?: AccountMCHistoryScalarWhereInput[]
    NOT?: AccountMCHistoryScalarWhereInput | AccountMCHistoryScalarWhereInput[]
    id?: StringFilter<"AccountMCHistory"> | string
    assignedAt?: DateTimeFilter<"AccountMCHistory"> | Date | string
    unassignedAt?: DateTimeNullableFilter<"AccountMCHistory"> | Date | string | null
    reason?: EnumHistoryReasonFilter<"AccountMCHistory"> | $Enums.HistoryReason
    notes?: StringNullableFilter<"AccountMCHistory"> | string | null
    createdAt?: DateTimeFilter<"AccountMCHistory"> | Date | string
    accountId?: StringFilter<"AccountMCHistory"> | string
    customerId?: StringFilter<"AccountMCHistory"> | string
    assignedById?: StringFilter<"AccountMCHistory"> | string
    unassignedById?: StringNullableFilter<"AccountMCHistory"> | string | null
  }

  export type AccountMCHistoryUpsertWithWhereUniqueWithoutUnassignedByInput = {
    where: AccountMCHistoryWhereUniqueInput
    update: XOR<AccountMCHistoryUpdateWithoutUnassignedByInput, AccountMCHistoryUncheckedUpdateWithoutUnassignedByInput>
    create: XOR<AccountMCHistoryCreateWithoutUnassignedByInput, AccountMCHistoryUncheckedCreateWithoutUnassignedByInput>
  }

  export type AccountMCHistoryUpdateWithWhereUniqueWithoutUnassignedByInput = {
    where: AccountMCHistoryWhereUniqueInput
    data: XOR<AccountMCHistoryUpdateWithoutUnassignedByInput, AccountMCHistoryUncheckedUpdateWithoutUnassignedByInput>
  }

  export type AccountMCHistoryUpdateManyWithWhereWithoutUnassignedByInput = {
    where: AccountMCHistoryScalarWhereInput
    data: XOR<AccountMCHistoryUpdateManyMutationInput, AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByInput>
  }

  export type SpendingSnapshotUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: SpendingSnapshotWhereUniqueInput
    update: XOR<SpendingSnapshotUpdateWithoutCreatedByInput, SpendingSnapshotUncheckedUpdateWithoutCreatedByInput>
    create: XOR<SpendingSnapshotCreateWithoutCreatedByInput, SpendingSnapshotUncheckedCreateWithoutCreatedByInput>
  }

  export type SpendingSnapshotUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: SpendingSnapshotWhereUniqueInput
    data: XOR<SpendingSnapshotUpdateWithoutCreatedByInput, SpendingSnapshotUncheckedUpdateWithoutCreatedByInput>
  }

  export type SpendingSnapshotUpdateManyWithWhereWithoutCreatedByInput = {
    where: SpendingSnapshotScalarWhereInput
    data: XOR<SpendingSnapshotUpdateManyMutationInput, SpendingSnapshotUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type SpendingSnapshotScalarWhereInput = {
    AND?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
    OR?: SpendingSnapshotScalarWhereInput[]
    NOT?: SpendingSnapshotScalarWhereInput | SpendingSnapshotScalarWhereInput[]
    id?: StringFilter<"SpendingSnapshot"> | string
    spendingDate?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    cumulativeAmount?: DecimalFilter<"SpendingSnapshot"> | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    snapshotType?: EnumSnapshotTypeFilter<"SpendingSnapshot"> | $Enums.SnapshotType
    createdAt?: DateTimeFilter<"SpendingSnapshot"> | Date | string
    accountId?: StringFilter<"SpendingSnapshot"> | string
    invoiceMccId?: StringNullableFilter<"SpendingSnapshot"> | string | null
    customerId?: StringNullableFilter<"SpendingSnapshot"> | string | null
    createdById?: StringFilter<"SpendingSnapshot"> | string
  }

  export type ActivityLogUpsertWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    update: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
    create: XOR<ActivityLogCreateWithoutUserInput, ActivityLogUncheckedCreateWithoutUserInput>
  }

  export type ActivityLogUpdateWithWhereUniqueWithoutUserInput = {
    where: ActivityLogWhereUniqueInput
    data: XOR<ActivityLogUpdateWithoutUserInput, ActivityLogUncheckedUpdateWithoutUserInput>
  }

  export type ActivityLogUpdateManyWithWhereWithoutUserInput = {
    where: ActivityLogScalarWhereInput
    data: XOR<ActivityLogUpdateManyMutationInput, ActivityLogUncheckedUpdateManyWithoutUserInput>
  }

  export type ActivityLogScalarWhereInput = {
    AND?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    OR?: ActivityLogScalarWhereInput[]
    NOT?: ActivityLogScalarWhereInput | ActivityLogScalarWhereInput[]
    id?: StringFilter<"ActivityLog"> | string
    action?: EnumActivityActionFilter<"ActivityLog"> | $Enums.ActivityAction
    entityType?: StringFilter<"ActivityLog"> | string
    entityId?: StringFilter<"ActivityLog"> | string
    oldValues?: JsonNullableFilter<"ActivityLog">
    newValues?: JsonNullableFilter<"ActivityLog">
    description?: StringNullableFilter<"ActivityLog"> | string | null
    ipAddress?: StringNullableFilter<"ActivityLog"> | string | null
    createdAt?: DateTimeFilter<"ActivityLog"> | Date | string
    userId?: StringFilter<"ActivityLog"> | string
  }

  export type AccountBatchCreateWithoutPartnerInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutBatchesCreatedInput
    accounts?: AccountCreateNestedManyWithoutBatchInput
  }

  export type AccountBatchUncheckedCreateWithoutPartnerInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    accounts?: AccountUncheckedCreateNestedManyWithoutBatchInput
  }

  export type AccountBatchCreateOrConnectWithoutPartnerInput = {
    where: AccountBatchWhereUniqueInput
    create: XOR<AccountBatchCreateWithoutPartnerInput, AccountBatchUncheckedCreateWithoutPartnerInput>
  }

  export type AccountBatchCreateManyPartnerInputEnvelope = {
    data: AccountBatchCreateManyPartnerInput | AccountBatchCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceMCCCreateWithoutPartnerInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdBy: UserCreateNestedOneWithoutInvoiceMCCsCreatedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCUncheckedCreateWithoutPartnerInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCCreateOrConnectWithoutPartnerInput = {
    where: InvoiceMCCWhereUniqueInput
    create: XOR<InvoiceMCCCreateWithoutPartnerInput, InvoiceMCCUncheckedCreateWithoutPartnerInput>
  }

  export type InvoiceMCCCreateManyPartnerInputEnvelope = {
    data: InvoiceMCCCreateManyPartnerInput | InvoiceMCCCreateManyPartnerInput[]
    skipDuplicates?: boolean
  }

  export type AccountBatchUpsertWithWhereUniqueWithoutPartnerInput = {
    where: AccountBatchWhereUniqueInput
    update: XOR<AccountBatchUpdateWithoutPartnerInput, AccountBatchUncheckedUpdateWithoutPartnerInput>
    create: XOR<AccountBatchCreateWithoutPartnerInput, AccountBatchUncheckedCreateWithoutPartnerInput>
  }

  export type AccountBatchUpdateWithWhereUniqueWithoutPartnerInput = {
    where: AccountBatchWhereUniqueInput
    data: XOR<AccountBatchUpdateWithoutPartnerInput, AccountBatchUncheckedUpdateWithoutPartnerInput>
  }

  export type AccountBatchUpdateManyWithWhereWithoutPartnerInput = {
    where: AccountBatchScalarWhereInput
    data: XOR<AccountBatchUpdateManyMutationInput, AccountBatchUncheckedUpdateManyWithoutPartnerInput>
  }

  export type InvoiceMCCUpsertWithWhereUniqueWithoutPartnerInput = {
    where: InvoiceMCCWhereUniqueInput
    update: XOR<InvoiceMCCUpdateWithoutPartnerInput, InvoiceMCCUncheckedUpdateWithoutPartnerInput>
    create: XOR<InvoiceMCCCreateWithoutPartnerInput, InvoiceMCCUncheckedCreateWithoutPartnerInput>
  }

  export type InvoiceMCCUpdateWithWhereUniqueWithoutPartnerInput = {
    where: InvoiceMCCWhereUniqueInput
    data: XOR<InvoiceMCCUpdateWithoutPartnerInput, InvoiceMCCUncheckedUpdateWithoutPartnerInput>
  }

  export type InvoiceMCCUpdateManyWithWhereWithoutPartnerInput = {
    where: InvoiceMCCScalarWhereInput
    data: XOR<InvoiceMCCUpdateManyMutationInput, InvoiceMCCUncheckedUpdateManyWithoutPartnerInput>
  }

  export type PartnerCreateWithoutBatchesInput = {
    id?: string
    name: string
    contactInfo?: string | null
    type: $Enums.PartnerType
    notes?: string | null
    createdAt?: Date | string
    invoiceMCCs?: InvoiceMCCCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutBatchesInput = {
    id?: string
    name: string
    contactInfo?: string | null
    type: $Enums.PartnerType
    notes?: string | null
    createdAt?: Date | string
    invoiceMCCs?: InvoiceMCCUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutBatchesInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutBatchesInput, PartnerUncheckedCreateWithoutBatchesInput>
  }

  export type UserCreateWithoutBatchesCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBatchesCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBatchesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBatchesCreatedInput, UserUncheckedCreateWithoutBatchesCreatedInput>
  }

  export type AccountCreateWithoutBatchInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMi?: InvoiceMCCCreateNestedOneWithoutAccountsInput
    currentMc?: CustomerCreateNestedOneWithoutAccountsInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutBatchInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMiId?: string | null
    currentMcId?: string | null
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutBatchInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBatchInput, AccountUncheckedCreateWithoutBatchInput>
  }

  export type AccountCreateManyBatchInputEnvelope = {
    data: AccountCreateManyBatchInput | AccountCreateManyBatchInput[]
    skipDuplicates?: boolean
  }

  export type PartnerUpsertWithoutBatchesInput = {
    update: XOR<PartnerUpdateWithoutBatchesInput, PartnerUncheckedUpdateWithoutBatchesInput>
    create: XOR<PartnerCreateWithoutBatchesInput, PartnerUncheckedCreateWithoutBatchesInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutBatchesInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutBatchesInput, PartnerUncheckedUpdateWithoutBatchesInput>
  }

  export type PartnerUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMCCs?: InvoiceMCCUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutBatchesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMCCs?: InvoiceMCCUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutBatchesCreatedInput = {
    update: XOR<UserUpdateWithoutBatchesCreatedInput, UserUncheckedUpdateWithoutBatchesCreatedInput>
    create: XOR<UserCreateWithoutBatchesCreatedInput, UserUncheckedCreateWithoutBatchesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBatchesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBatchesCreatedInput, UserUncheckedUpdateWithoutBatchesCreatedInput>
  }

  export type UserUpdateWithoutBatchesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBatchesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutBatchInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutBatchInput, AccountUncheckedUpdateWithoutBatchInput>
    create: XOR<AccountCreateWithoutBatchInput, AccountUncheckedCreateWithoutBatchInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutBatchInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutBatchInput, AccountUncheckedUpdateWithoutBatchInput>
  }

  export type AccountUpdateManyWithWhereWithoutBatchInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutBatchInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    googleAccountId?: StringFilter<"Account"> | string
    accountName?: StringFilter<"Account"> | string
    status?: EnumAccountStatusFilter<"Account"> | $Enums.AccountStatus
    currency?: StringFilter<"Account"> | string
    timezone?: StringNullableFilter<"Account"> | string | null
    mccAccountName?: StringNullableFilter<"Account"> | string | null
    mccAccountId?: StringNullableFilter<"Account"> | string | null
    totalSpending?: DecimalFilter<"Account"> | Decimal | DecimalJsLike | number | string
    lastSynced?: DateTimeNullableFilter<"Account"> | Date | string | null
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    batchId?: StringFilter<"Account"> | string
    currentMiId?: StringNullableFilter<"Account"> | string | null
    currentMcId?: StringNullableFilter<"Account"> | string | null
  }

  export type PartnerCreateWithoutInvoiceMCCsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    type: $Enums.PartnerType
    notes?: string | null
    createdAt?: Date | string
    batches?: AccountBatchCreateNestedManyWithoutPartnerInput
  }

  export type PartnerUncheckedCreateWithoutInvoiceMCCsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    type: $Enums.PartnerType
    notes?: string | null
    createdAt?: Date | string
    batches?: AccountBatchUncheckedCreateNestedManyWithoutPartnerInput
  }

  export type PartnerCreateOrConnectWithoutInvoiceMCCsInput = {
    where: PartnerWhereUniqueInput
    create: XOR<PartnerCreateWithoutInvoiceMCCsInput, PartnerUncheckedCreateWithoutInvoiceMCCsInput>
  }

  export type UserCreateWithoutInvoiceMCCsCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvoiceMCCsCreatedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvoiceMCCsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoiceMCCsCreatedInput, UserUncheckedCreateWithoutInvoiceMCCsCreatedInput>
  }

  export type AccountCreateWithoutCurrentMiInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: AccountBatchCreateNestedOneWithoutAccountsInput
    currentMc?: CustomerCreateNestedOneWithoutAccountsInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCurrentMiInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMcId?: string | null
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCurrentMiInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCurrentMiInput, AccountUncheckedCreateWithoutCurrentMiInput>
  }

  export type AccountCreateManyCurrentMiInputEnvelope = {
    data: AccountCreateManyCurrentMiInput | AccountCreateManyCurrentMiInput[]
    skipDuplicates?: boolean
  }

  export type AccountMIHistoryCreateWithoutInvoiceMccInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutMiHistoriesInput
    linkedBy: UserCreateNestedOneWithoutMiHistoriesLinkedInput
    unlinkedBy?: UserCreateNestedOneWithoutMiHistoriesUnlinkedInput
  }

  export type AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    linkedById: string
    unlinkedById?: string | null
  }

  export type AccountMIHistoryCreateOrConnectWithoutInvoiceMccInput = {
    where: AccountMIHistoryWhereUniqueInput
    create: XOR<AccountMIHistoryCreateWithoutInvoiceMccInput, AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput>
  }

  export type AccountMIHistoryCreateManyInvoiceMccInputEnvelope = {
    data: AccountMIHistoryCreateManyInvoiceMccInput | AccountMIHistoryCreateManyInvoiceMccInput[]
    skipDuplicates?: boolean
  }

  export type SpendingSnapshotCreateWithoutInvoiceMccInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutSnapshotsInput
    customer?: CustomerCreateNestedOneWithoutSnapshotsInput
    createdBy: UserCreateNestedOneWithoutSnapshotsInput
  }

  export type SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    accountId: string
    customerId?: string | null
    createdById: string
  }

  export type SpendingSnapshotCreateOrConnectWithoutInvoiceMccInput = {
    where: SpendingSnapshotWhereUniqueInput
    create: XOR<SpendingSnapshotCreateWithoutInvoiceMccInput, SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput>
  }

  export type SpendingSnapshotCreateManyInvoiceMccInputEnvelope = {
    data: SpendingSnapshotCreateManyInvoiceMccInput | SpendingSnapshotCreateManyInvoiceMccInput[]
    skipDuplicates?: boolean
  }

  export type SpendingRecordCreateWithoutInvoiceMccInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutSpendingRecordsInput
    customer?: CustomerCreateNestedOneWithoutSpendingRecordsInput
  }

  export type SpendingRecordUncheckedCreateWithoutInvoiceMccInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    accountId: string
    customerId?: string | null
  }

  export type SpendingRecordCreateOrConnectWithoutInvoiceMccInput = {
    where: SpendingRecordWhereUniqueInput
    create: XOR<SpendingRecordCreateWithoutInvoiceMccInput, SpendingRecordUncheckedCreateWithoutInvoiceMccInput>
  }

  export type SpendingRecordCreateManyInvoiceMccInputEnvelope = {
    data: SpendingRecordCreateManyInvoiceMccInput | SpendingRecordCreateManyInvoiceMccInput[]
    skipDuplicates?: boolean
  }

  export type PartnerUpsertWithoutInvoiceMCCsInput = {
    update: XOR<PartnerUpdateWithoutInvoiceMCCsInput, PartnerUncheckedUpdateWithoutInvoiceMCCsInput>
    create: XOR<PartnerCreateWithoutInvoiceMCCsInput, PartnerUncheckedCreateWithoutInvoiceMCCsInput>
    where?: PartnerWhereInput
  }

  export type PartnerUpdateToOneWithWhereWithoutInvoiceMCCsInput = {
    where?: PartnerWhereInput
    data: XOR<PartnerUpdateWithoutInvoiceMCCsInput, PartnerUncheckedUpdateWithoutInvoiceMCCsInput>
  }

  export type PartnerUpdateWithoutInvoiceMCCsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: AccountBatchUpdateManyWithoutPartnerNestedInput
  }

  export type PartnerUncheckedUpdateWithoutInvoiceMCCsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPartnerTypeFieldUpdateOperationsInput | $Enums.PartnerType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batches?: AccountBatchUncheckedUpdateManyWithoutPartnerNestedInput
  }

  export type UserUpsertWithoutInvoiceMCCsCreatedInput = {
    update: XOR<UserUpdateWithoutInvoiceMCCsCreatedInput, UserUncheckedUpdateWithoutInvoiceMCCsCreatedInput>
    create: XOR<UserCreateWithoutInvoiceMCCsCreatedInput, UserUncheckedCreateWithoutInvoiceMCCsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoiceMCCsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoiceMCCsCreatedInput, UserUncheckedUpdateWithoutInvoiceMCCsCreatedInput>
  }

  export type UserUpdateWithoutInvoiceMCCsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoiceMCCsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutCurrentMiInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutCurrentMiInput, AccountUncheckedUpdateWithoutCurrentMiInput>
    create: XOR<AccountCreateWithoutCurrentMiInput, AccountUncheckedCreateWithoutCurrentMiInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutCurrentMiInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutCurrentMiInput, AccountUncheckedUpdateWithoutCurrentMiInput>
  }

  export type AccountUpdateManyWithWhereWithoutCurrentMiInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutCurrentMiInput>
  }

  export type AccountMIHistoryUpsertWithWhereUniqueWithoutInvoiceMccInput = {
    where: AccountMIHistoryWhereUniqueInput
    update: XOR<AccountMIHistoryUpdateWithoutInvoiceMccInput, AccountMIHistoryUncheckedUpdateWithoutInvoiceMccInput>
    create: XOR<AccountMIHistoryCreateWithoutInvoiceMccInput, AccountMIHistoryUncheckedCreateWithoutInvoiceMccInput>
  }

  export type AccountMIHistoryUpdateWithWhereUniqueWithoutInvoiceMccInput = {
    where: AccountMIHistoryWhereUniqueInput
    data: XOR<AccountMIHistoryUpdateWithoutInvoiceMccInput, AccountMIHistoryUncheckedUpdateWithoutInvoiceMccInput>
  }

  export type AccountMIHistoryUpdateManyWithWhereWithoutInvoiceMccInput = {
    where: AccountMIHistoryScalarWhereInput
    data: XOR<AccountMIHistoryUpdateManyMutationInput, AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccInput>
  }

  export type SpendingSnapshotUpsertWithWhereUniqueWithoutInvoiceMccInput = {
    where: SpendingSnapshotWhereUniqueInput
    update: XOR<SpendingSnapshotUpdateWithoutInvoiceMccInput, SpendingSnapshotUncheckedUpdateWithoutInvoiceMccInput>
    create: XOR<SpendingSnapshotCreateWithoutInvoiceMccInput, SpendingSnapshotUncheckedCreateWithoutInvoiceMccInput>
  }

  export type SpendingSnapshotUpdateWithWhereUniqueWithoutInvoiceMccInput = {
    where: SpendingSnapshotWhereUniqueInput
    data: XOR<SpendingSnapshotUpdateWithoutInvoiceMccInput, SpendingSnapshotUncheckedUpdateWithoutInvoiceMccInput>
  }

  export type SpendingSnapshotUpdateManyWithWhereWithoutInvoiceMccInput = {
    where: SpendingSnapshotScalarWhereInput
    data: XOR<SpendingSnapshotUpdateManyMutationInput, SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccInput>
  }

  export type SpendingRecordUpsertWithWhereUniqueWithoutInvoiceMccInput = {
    where: SpendingRecordWhereUniqueInput
    update: XOR<SpendingRecordUpdateWithoutInvoiceMccInput, SpendingRecordUncheckedUpdateWithoutInvoiceMccInput>
    create: XOR<SpendingRecordCreateWithoutInvoiceMccInput, SpendingRecordUncheckedCreateWithoutInvoiceMccInput>
  }

  export type SpendingRecordUpdateWithWhereUniqueWithoutInvoiceMccInput = {
    where: SpendingRecordWhereUniqueInput
    data: XOR<SpendingRecordUpdateWithoutInvoiceMccInput, SpendingRecordUncheckedUpdateWithoutInvoiceMccInput>
  }

  export type SpendingRecordUpdateManyWithWhereWithoutInvoiceMccInput = {
    where: SpendingRecordScalarWhereInput
    data: XOR<SpendingRecordUpdateManyMutationInput, SpendingRecordUncheckedUpdateManyWithoutInvoiceMccInput>
  }

  export type SpendingRecordScalarWhereInput = {
    AND?: SpendingRecordScalarWhereInput | SpendingRecordScalarWhereInput[]
    OR?: SpendingRecordScalarWhereInput[]
    NOT?: SpendingRecordScalarWhereInput | SpendingRecordScalarWhereInput[]
    id?: StringFilter<"SpendingRecord"> | string
    spendingDate?: DateTimeFilter<"SpendingRecord"> | Date | string
    amount?: DecimalFilter<"SpendingRecord"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"SpendingRecord"> | string
    periodStart?: DateTimeFilter<"SpendingRecord"> | Date | string
    periodEnd?: DateTimeFilter<"SpendingRecord"> | Date | string
    createdAt?: DateTimeFilter<"SpendingRecord"> | Date | string
    accountId?: StringFilter<"SpendingRecord"> | string
    invoiceMccId?: StringNullableFilter<"SpendingRecord"> | string | null
    customerId?: StringNullableFilter<"SpendingRecord"> | string | null
  }

  export type UserCreateWithoutCustomersAssignedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCustomersAssignedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCustomersAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCustomersAssignedInput, UserUncheckedCreateWithoutCustomersAssignedInput>
  }

  export type AccountCreateWithoutCurrentMcInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: AccountBatchCreateNestedOneWithoutAccountsInput
    currentMi?: InvoiceMCCCreateNestedOneWithoutAccountsInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutCurrentMcInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMiId?: string | null
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutCurrentMcInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutCurrentMcInput, AccountUncheckedCreateWithoutCurrentMcInput>
  }

  export type AccountCreateManyCurrentMcInputEnvelope = {
    data: AccountCreateManyCurrentMcInput | AccountCreateManyCurrentMcInput[]
    skipDuplicates?: boolean
  }

  export type AccountMCHistoryCreateWithoutCustomerInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutMcHistoriesInput
    assignedBy: UserCreateNestedOneWithoutMcHistoriesAssignedInput
    unassignedBy?: UserCreateNestedOneWithoutMcHistoriesUnassignedInput
  }

  export type AccountMCHistoryUncheckedCreateWithoutCustomerInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    assignedById: string
    unassignedById?: string | null
  }

  export type AccountMCHistoryCreateOrConnectWithoutCustomerInput = {
    where: AccountMCHistoryWhereUniqueInput
    create: XOR<AccountMCHistoryCreateWithoutCustomerInput, AccountMCHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type AccountMCHistoryCreateManyCustomerInputEnvelope = {
    data: AccountMCHistoryCreateManyCustomerInput | AccountMCHistoryCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SpendingSnapshotCreateWithoutCustomerInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutSnapshotsInput
    invoiceMcc?: InvoiceMCCCreateNestedOneWithoutSnapshotsInput
    createdBy: UserCreateNestedOneWithoutSnapshotsInput
  }

  export type SpendingSnapshotUncheckedCreateWithoutCustomerInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
    createdById: string
  }

  export type SpendingSnapshotCreateOrConnectWithoutCustomerInput = {
    where: SpendingSnapshotWhereUniqueInput
    create: XOR<SpendingSnapshotCreateWithoutCustomerInput, SpendingSnapshotUncheckedCreateWithoutCustomerInput>
  }

  export type SpendingSnapshotCreateManyCustomerInputEnvelope = {
    data: SpendingSnapshotCreateManyCustomerInput | SpendingSnapshotCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type SpendingRecordCreateWithoutCustomerInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    account: AccountCreateNestedOneWithoutSpendingRecordsInput
    invoiceMcc?: InvoiceMCCCreateNestedOneWithoutSpendingRecordsInput
  }

  export type SpendingRecordUncheckedCreateWithoutCustomerInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
  }

  export type SpendingRecordCreateOrConnectWithoutCustomerInput = {
    where: SpendingRecordWhereUniqueInput
    create: XOR<SpendingRecordCreateWithoutCustomerInput, SpendingRecordUncheckedCreateWithoutCustomerInput>
  }

  export type SpendingRecordCreateManyCustomerInputEnvelope = {
    data: SpendingRecordCreateManyCustomerInput | SpendingRecordCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutCustomersAssignedInput = {
    update: XOR<UserUpdateWithoutCustomersAssignedInput, UserUncheckedUpdateWithoutCustomersAssignedInput>
    create: XOR<UserCreateWithoutCustomersAssignedInput, UserUncheckedCreateWithoutCustomersAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCustomersAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCustomersAssignedInput, UserUncheckedUpdateWithoutCustomersAssignedInput>
  }

  export type UserUpdateWithoutCustomersAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCustomersAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutCurrentMcInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutCurrentMcInput, AccountUncheckedUpdateWithoutCurrentMcInput>
    create: XOR<AccountCreateWithoutCurrentMcInput, AccountUncheckedCreateWithoutCurrentMcInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutCurrentMcInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutCurrentMcInput, AccountUncheckedUpdateWithoutCurrentMcInput>
  }

  export type AccountUpdateManyWithWhereWithoutCurrentMcInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutCurrentMcInput>
  }

  export type AccountMCHistoryUpsertWithWhereUniqueWithoutCustomerInput = {
    where: AccountMCHistoryWhereUniqueInput
    update: XOR<AccountMCHistoryUpdateWithoutCustomerInput, AccountMCHistoryUncheckedUpdateWithoutCustomerInput>
    create: XOR<AccountMCHistoryCreateWithoutCustomerInput, AccountMCHistoryUncheckedCreateWithoutCustomerInput>
  }

  export type AccountMCHistoryUpdateWithWhereUniqueWithoutCustomerInput = {
    where: AccountMCHistoryWhereUniqueInput
    data: XOR<AccountMCHistoryUpdateWithoutCustomerInput, AccountMCHistoryUncheckedUpdateWithoutCustomerInput>
  }

  export type AccountMCHistoryUpdateManyWithWhereWithoutCustomerInput = {
    where: AccountMCHistoryScalarWhereInput
    data: XOR<AccountMCHistoryUpdateManyMutationInput, AccountMCHistoryUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SpendingSnapshotUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SpendingSnapshotWhereUniqueInput
    update: XOR<SpendingSnapshotUpdateWithoutCustomerInput, SpendingSnapshotUncheckedUpdateWithoutCustomerInput>
    create: XOR<SpendingSnapshotCreateWithoutCustomerInput, SpendingSnapshotUncheckedCreateWithoutCustomerInput>
  }

  export type SpendingSnapshotUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SpendingSnapshotWhereUniqueInput
    data: XOR<SpendingSnapshotUpdateWithoutCustomerInput, SpendingSnapshotUncheckedUpdateWithoutCustomerInput>
  }

  export type SpendingSnapshotUpdateManyWithWhereWithoutCustomerInput = {
    where: SpendingSnapshotScalarWhereInput
    data: XOR<SpendingSnapshotUpdateManyMutationInput, SpendingSnapshotUncheckedUpdateManyWithoutCustomerInput>
  }

  export type SpendingRecordUpsertWithWhereUniqueWithoutCustomerInput = {
    where: SpendingRecordWhereUniqueInput
    update: XOR<SpendingRecordUpdateWithoutCustomerInput, SpendingRecordUncheckedUpdateWithoutCustomerInput>
    create: XOR<SpendingRecordCreateWithoutCustomerInput, SpendingRecordUncheckedCreateWithoutCustomerInput>
  }

  export type SpendingRecordUpdateWithWhereUniqueWithoutCustomerInput = {
    where: SpendingRecordWhereUniqueInput
    data: XOR<SpendingRecordUpdateWithoutCustomerInput, SpendingRecordUncheckedUpdateWithoutCustomerInput>
  }

  export type SpendingRecordUpdateManyWithWhereWithoutCustomerInput = {
    where: SpendingRecordScalarWhereInput
    data: XOR<SpendingRecordUpdateManyMutationInput, SpendingRecordUncheckedUpdateManyWithoutCustomerInput>
  }

  export type AccountBatchCreateWithoutAccountsInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutBatchesInput
    createdBy: UserCreateNestedOneWithoutBatchesCreatedInput
  }

  export type AccountBatchUncheckedCreateWithoutAccountsInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
  }

  export type AccountBatchCreateOrConnectWithoutAccountsInput = {
    where: AccountBatchWhereUniqueInput
    create: XOR<AccountBatchCreateWithoutAccountsInput, AccountBatchUncheckedCreateWithoutAccountsInput>
  }

  export type InvoiceMCCCreateWithoutAccountsInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutInvoiceMCCsInput
    createdBy: UserCreateNestedOneWithoutInvoiceMCCsCreatedInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCCreateOrConnectWithoutAccountsInput = {
    where: InvoiceMCCWhereUniqueInput
    create: XOR<InvoiceMCCCreateWithoutAccountsInput, InvoiceMCCUncheckedCreateWithoutAccountsInput>
  }

  export type CustomerCreateWithoutAccountsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaff?: UserCreateNestedOneWithoutCustomersAssignedInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutCustomerInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutAccountsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaffId?: string | null
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutCustomerInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutAccountsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutAccountsInput, CustomerUncheckedCreateWithoutAccountsInput>
  }

  export type AccountMIHistoryCreateWithoutAccountInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    invoiceMcc: InvoiceMCCCreateNestedOneWithoutMiHistoriesInput
    linkedBy: UserCreateNestedOneWithoutMiHistoriesLinkedInput
    unlinkedBy?: UserCreateNestedOneWithoutMiHistoriesUnlinkedInput
  }

  export type AccountMIHistoryUncheckedCreateWithoutAccountInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    invoiceMccId: string
    linkedById: string
    unlinkedById?: string | null
  }

  export type AccountMIHistoryCreateOrConnectWithoutAccountInput = {
    where: AccountMIHistoryWhereUniqueInput
    create: XOR<AccountMIHistoryCreateWithoutAccountInput, AccountMIHistoryUncheckedCreateWithoutAccountInput>
  }

  export type AccountMIHistoryCreateManyAccountInputEnvelope = {
    data: AccountMIHistoryCreateManyAccountInput | AccountMIHistoryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AccountMCHistoryCreateWithoutAccountInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    customer: CustomerCreateNestedOneWithoutMcHistoriesInput
    assignedBy: UserCreateNestedOneWithoutMcHistoriesAssignedInput
    unassignedBy?: UserCreateNestedOneWithoutMcHistoriesUnassignedInput
  }

  export type AccountMCHistoryUncheckedCreateWithoutAccountInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    customerId: string
    assignedById: string
    unassignedById?: string | null
  }

  export type AccountMCHistoryCreateOrConnectWithoutAccountInput = {
    where: AccountMCHistoryWhereUniqueInput
    create: XOR<AccountMCHistoryCreateWithoutAccountInput, AccountMCHistoryUncheckedCreateWithoutAccountInput>
  }

  export type AccountMCHistoryCreateManyAccountInputEnvelope = {
    data: AccountMCHistoryCreateManyAccountInput | AccountMCHistoryCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type SpendingSnapshotCreateWithoutAccountInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    invoiceMcc?: InvoiceMCCCreateNestedOneWithoutSnapshotsInput
    customer?: CustomerCreateNestedOneWithoutSnapshotsInput
    createdBy: UserCreateNestedOneWithoutSnapshotsInput
  }

  export type SpendingSnapshotUncheckedCreateWithoutAccountInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    invoiceMccId?: string | null
    customerId?: string | null
    createdById: string
  }

  export type SpendingSnapshotCreateOrConnectWithoutAccountInput = {
    where: SpendingSnapshotWhereUniqueInput
    create: XOR<SpendingSnapshotCreateWithoutAccountInput, SpendingSnapshotUncheckedCreateWithoutAccountInput>
  }

  export type SpendingSnapshotCreateManyAccountInputEnvelope = {
    data: SpendingSnapshotCreateManyAccountInput | SpendingSnapshotCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type SpendingRecordCreateWithoutAccountInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    invoiceMcc?: InvoiceMCCCreateNestedOneWithoutSpendingRecordsInput
    customer?: CustomerCreateNestedOneWithoutSpendingRecordsInput
  }

  export type SpendingRecordUncheckedCreateWithoutAccountInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    invoiceMccId?: string | null
    customerId?: string | null
  }

  export type SpendingRecordCreateOrConnectWithoutAccountInput = {
    where: SpendingRecordWhereUniqueInput
    create: XOR<SpendingRecordCreateWithoutAccountInput, SpendingRecordUncheckedCreateWithoutAccountInput>
  }

  export type SpendingRecordCreateManyAccountInputEnvelope = {
    data: SpendingRecordCreateManyAccountInput | SpendingRecordCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AccountBatchUpsertWithoutAccountsInput = {
    update: XOR<AccountBatchUpdateWithoutAccountsInput, AccountBatchUncheckedUpdateWithoutAccountsInput>
    create: XOR<AccountBatchCreateWithoutAccountsInput, AccountBatchUncheckedCreateWithoutAccountsInput>
    where?: AccountBatchWhereInput
  }

  export type AccountBatchUpdateToOneWithWhereWithoutAccountsInput = {
    where?: AccountBatchWhereInput
    data: XOR<AccountBatchUpdateWithoutAccountsInput, AccountBatchUncheckedUpdateWithoutAccountsInput>
  }

  export type AccountBatchUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutBatchesNestedInput
    createdBy?: UserUpdateOneRequiredWithoutBatchesCreatedNestedInput
  }

  export type AccountBatchUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceMCCUpsertWithoutAccountsInput = {
    update: XOR<InvoiceMCCUpdateWithoutAccountsInput, InvoiceMCCUncheckedUpdateWithoutAccountsInput>
    create: XOR<InvoiceMCCCreateWithoutAccountsInput, InvoiceMCCUncheckedCreateWithoutAccountsInput>
    where?: InvoiceMCCWhereInput
  }

  export type InvoiceMCCUpdateToOneWithWhereWithoutAccountsInput = {
    where?: InvoiceMCCWhereInput
    data: XOR<InvoiceMCCUpdateWithoutAccountsInput, InvoiceMCCUncheckedUpdateWithoutAccountsInput>
  }

  export type InvoiceMCCUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutInvoiceMCCsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoiceMCCsCreatedNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutInvoiceMccNestedInput
  }

  export type CustomerUpsertWithoutAccountsInput = {
    update: XOR<CustomerUpdateWithoutAccountsInput, CustomerUncheckedUpdateWithoutAccountsInput>
    create: XOR<CustomerCreateWithoutAccountsInput, CustomerUncheckedCreateWithoutAccountsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutAccountsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutAccountsInput, CustomerUncheckedUpdateWithoutAccountsInput>
  }

  export type CustomerUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaff?: UserUpdateOneWithoutCustomersAssignedNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutCustomerNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type AccountMIHistoryUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountMIHistoryWhereUniqueInput
    update: XOR<AccountMIHistoryUpdateWithoutAccountInput, AccountMIHistoryUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountMIHistoryCreateWithoutAccountInput, AccountMIHistoryUncheckedCreateWithoutAccountInput>
  }

  export type AccountMIHistoryUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountMIHistoryWhereUniqueInput
    data: XOR<AccountMIHistoryUpdateWithoutAccountInput, AccountMIHistoryUncheckedUpdateWithoutAccountInput>
  }

  export type AccountMIHistoryUpdateManyWithWhereWithoutAccountInput = {
    where: AccountMIHistoryScalarWhereInput
    data: XOR<AccountMIHistoryUpdateManyMutationInput, AccountMIHistoryUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountMCHistoryUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountMCHistoryWhereUniqueInput
    update: XOR<AccountMCHistoryUpdateWithoutAccountInput, AccountMCHistoryUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountMCHistoryCreateWithoutAccountInput, AccountMCHistoryUncheckedCreateWithoutAccountInput>
  }

  export type AccountMCHistoryUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountMCHistoryWhereUniqueInput
    data: XOR<AccountMCHistoryUpdateWithoutAccountInput, AccountMCHistoryUncheckedUpdateWithoutAccountInput>
  }

  export type AccountMCHistoryUpdateManyWithWhereWithoutAccountInput = {
    where: AccountMCHistoryScalarWhereInput
    data: XOR<AccountMCHistoryUpdateManyMutationInput, AccountMCHistoryUncheckedUpdateManyWithoutAccountInput>
  }

  export type SpendingSnapshotUpsertWithWhereUniqueWithoutAccountInput = {
    where: SpendingSnapshotWhereUniqueInput
    update: XOR<SpendingSnapshotUpdateWithoutAccountInput, SpendingSnapshotUncheckedUpdateWithoutAccountInput>
    create: XOR<SpendingSnapshotCreateWithoutAccountInput, SpendingSnapshotUncheckedCreateWithoutAccountInput>
  }

  export type SpendingSnapshotUpdateWithWhereUniqueWithoutAccountInput = {
    where: SpendingSnapshotWhereUniqueInput
    data: XOR<SpendingSnapshotUpdateWithoutAccountInput, SpendingSnapshotUncheckedUpdateWithoutAccountInput>
  }

  export type SpendingSnapshotUpdateManyWithWhereWithoutAccountInput = {
    where: SpendingSnapshotScalarWhereInput
    data: XOR<SpendingSnapshotUpdateManyMutationInput, SpendingSnapshotUncheckedUpdateManyWithoutAccountInput>
  }

  export type SpendingRecordUpsertWithWhereUniqueWithoutAccountInput = {
    where: SpendingRecordWhereUniqueInput
    update: XOR<SpendingRecordUpdateWithoutAccountInput, SpendingRecordUncheckedUpdateWithoutAccountInput>
    create: XOR<SpendingRecordCreateWithoutAccountInput, SpendingRecordUncheckedCreateWithoutAccountInput>
  }

  export type SpendingRecordUpdateWithWhereUniqueWithoutAccountInput = {
    where: SpendingRecordWhereUniqueInput
    data: XOR<SpendingRecordUpdateWithoutAccountInput, SpendingRecordUncheckedUpdateWithoutAccountInput>
  }

  export type SpendingRecordUpdateManyWithWhereWithoutAccountInput = {
    where: SpendingRecordScalarWhereInput
    data: XOR<SpendingRecordUpdateManyMutationInput, SpendingRecordUncheckedUpdateManyWithoutAccountInput>
  }

  export type AccountCreateWithoutMiHistoriesInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: AccountBatchCreateNestedOneWithoutAccountsInput
    currentMi?: InvoiceMCCCreateNestedOneWithoutAccountsInput
    currentMc?: CustomerCreateNestedOneWithoutAccountsInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutMiHistoriesInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMiId?: string | null
    currentMcId?: string | null
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutMiHistoriesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutMiHistoriesInput, AccountUncheckedCreateWithoutMiHistoriesInput>
  }

  export type InvoiceMCCCreateWithoutMiHistoriesInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutInvoiceMCCsInput
    createdBy: UserCreateNestedOneWithoutInvoiceMCCsCreatedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMiInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCUncheckedCreateWithoutMiHistoriesInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMiInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCCreateOrConnectWithoutMiHistoriesInput = {
    where: InvoiceMCCWhereUniqueInput
    create: XOR<InvoiceMCCCreateWithoutMiHistoriesInput, InvoiceMCCUncheckedCreateWithoutMiHistoriesInput>
  }

  export type UserCreateWithoutMiHistoriesLinkedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMiHistoriesLinkedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMiHistoriesLinkedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMiHistoriesLinkedInput, UserUncheckedCreateWithoutMiHistoriesLinkedInput>
  }

  export type UserCreateWithoutMiHistoriesUnlinkedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMiHistoriesUnlinkedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMiHistoriesUnlinkedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMiHistoriesUnlinkedInput, UserUncheckedCreateWithoutMiHistoriesUnlinkedInput>
  }

  export type AccountUpsertWithoutMiHistoriesInput = {
    update: XOR<AccountUpdateWithoutMiHistoriesInput, AccountUncheckedUpdateWithoutMiHistoriesInput>
    create: XOR<AccountCreateWithoutMiHistoriesInput, AccountUncheckedCreateWithoutMiHistoriesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutMiHistoriesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutMiHistoriesInput, AccountUncheckedUpdateWithoutMiHistoriesInput>
  }

  export type AccountUpdateWithoutMiHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AccountBatchUpdateOneRequiredWithoutAccountsNestedInput
    currentMi?: InvoiceMCCUpdateOneWithoutAccountsNestedInput
    currentMc?: CustomerUpdateOneWithoutAccountsNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutMiHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type InvoiceMCCUpsertWithoutMiHistoriesInput = {
    update: XOR<InvoiceMCCUpdateWithoutMiHistoriesInput, InvoiceMCCUncheckedUpdateWithoutMiHistoriesInput>
    create: XOR<InvoiceMCCCreateWithoutMiHistoriesInput, InvoiceMCCUncheckedCreateWithoutMiHistoriesInput>
    where?: InvoiceMCCWhereInput
  }

  export type InvoiceMCCUpdateToOneWithWhereWithoutMiHistoriesInput = {
    where?: InvoiceMCCWhereInput
    data: XOR<InvoiceMCCUpdateWithoutMiHistoriesInput, InvoiceMCCUncheckedUpdateWithoutMiHistoriesInput>
  }

  export type InvoiceMCCUpdateWithoutMiHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutInvoiceMCCsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoiceMCCsCreatedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMiNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateWithoutMiHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMiNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutInvoiceMccNestedInput
  }

  export type UserUpsertWithoutMiHistoriesLinkedInput = {
    update: XOR<UserUpdateWithoutMiHistoriesLinkedInput, UserUncheckedUpdateWithoutMiHistoriesLinkedInput>
    create: XOR<UserCreateWithoutMiHistoriesLinkedInput, UserUncheckedCreateWithoutMiHistoriesLinkedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMiHistoriesLinkedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMiHistoriesLinkedInput, UserUncheckedUpdateWithoutMiHistoriesLinkedInput>
  }

  export type UserUpdateWithoutMiHistoriesLinkedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMiHistoriesLinkedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMiHistoriesUnlinkedInput = {
    update: XOR<UserUpdateWithoutMiHistoriesUnlinkedInput, UserUncheckedUpdateWithoutMiHistoriesUnlinkedInput>
    create: XOR<UserCreateWithoutMiHistoriesUnlinkedInput, UserUncheckedCreateWithoutMiHistoriesUnlinkedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMiHistoriesUnlinkedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMiHistoriesUnlinkedInput, UserUncheckedUpdateWithoutMiHistoriesUnlinkedInput>
  }

  export type UserUpdateWithoutMiHistoriesUnlinkedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMiHistoriesUnlinkedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutMcHistoriesInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: AccountBatchCreateNestedOneWithoutAccountsInput
    currentMi?: InvoiceMCCCreateNestedOneWithoutAccountsInput
    currentMc?: CustomerCreateNestedOneWithoutAccountsInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutMcHistoriesInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMiId?: string | null
    currentMcId?: string | null
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutMcHistoriesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutMcHistoriesInput, AccountUncheckedCreateWithoutMcHistoriesInput>
  }

  export type CustomerCreateWithoutMcHistoriesInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaff?: UserCreateNestedOneWithoutCustomersAssignedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMcInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutMcHistoriesInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaffId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMcInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutMcHistoriesInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutMcHistoriesInput, CustomerUncheckedCreateWithoutMcHistoriesInput>
  }

  export type UserCreateWithoutMcHistoriesAssignedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMcHistoriesAssignedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMcHistoriesAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMcHistoriesAssignedInput, UserUncheckedCreateWithoutMcHistoriesAssignedInput>
  }

  export type UserCreateWithoutMcHistoriesUnassignedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMcHistoriesUnassignedInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMcHistoriesUnassignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMcHistoriesUnassignedInput, UserUncheckedCreateWithoutMcHistoriesUnassignedInput>
  }

  export type AccountUpsertWithoutMcHistoriesInput = {
    update: XOR<AccountUpdateWithoutMcHistoriesInput, AccountUncheckedUpdateWithoutMcHistoriesInput>
    create: XOR<AccountCreateWithoutMcHistoriesInput, AccountUncheckedCreateWithoutMcHistoriesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutMcHistoriesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutMcHistoriesInput, AccountUncheckedUpdateWithoutMcHistoriesInput>
  }

  export type AccountUpdateWithoutMcHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AccountBatchUpdateOneRequiredWithoutAccountsNestedInput
    currentMi?: InvoiceMCCUpdateOneWithoutAccountsNestedInput
    currentMc?: CustomerUpdateOneWithoutAccountsNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutMcHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type CustomerUpsertWithoutMcHistoriesInput = {
    update: XOR<CustomerUpdateWithoutMcHistoriesInput, CustomerUncheckedUpdateWithoutMcHistoriesInput>
    create: XOR<CustomerCreateWithoutMcHistoriesInput, CustomerUncheckedCreateWithoutMcHistoriesInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutMcHistoriesInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutMcHistoriesInput, CustomerUncheckedUpdateWithoutMcHistoriesInput>
  }

  export type CustomerUpdateWithoutMcHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaff?: UserUpdateOneWithoutCustomersAssignedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMcNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutMcHistoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMcNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutMcHistoriesAssignedInput = {
    update: XOR<UserUpdateWithoutMcHistoriesAssignedInput, UserUncheckedUpdateWithoutMcHistoriesAssignedInput>
    create: XOR<UserCreateWithoutMcHistoriesAssignedInput, UserUncheckedCreateWithoutMcHistoriesAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMcHistoriesAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMcHistoriesAssignedInput, UserUncheckedUpdateWithoutMcHistoriesAssignedInput>
  }

  export type UserUpdateWithoutMcHistoriesAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMcHistoriesAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutMcHistoriesUnassignedInput = {
    update: XOR<UserUpdateWithoutMcHistoriesUnassignedInput, UserUncheckedUpdateWithoutMcHistoriesUnassignedInput>
    create: XOR<UserCreateWithoutMcHistoriesUnassignedInput, UserUncheckedCreateWithoutMcHistoriesUnassignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMcHistoriesUnassignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMcHistoriesUnassignedInput, UserUncheckedUpdateWithoutMcHistoriesUnassignedInput>
  }

  export type UserUpdateWithoutMcHistoriesUnassignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMcHistoriesUnassignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutSnapshotsInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: AccountBatchCreateNestedOneWithoutAccountsInput
    currentMi?: InvoiceMCCCreateNestedOneWithoutAccountsInput
    currentMc?: CustomerCreateNestedOneWithoutAccountsInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMiId?: string | null
    currentMcId?: string | null
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutAccountInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutSnapshotsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSnapshotsInput, AccountUncheckedCreateWithoutSnapshotsInput>
  }

  export type InvoiceMCCCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutInvoiceMCCsInput
    createdBy: UserCreateNestedOneWithoutInvoiceMCCsCreatedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutInvoiceMccInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCCreateOrConnectWithoutSnapshotsInput = {
    where: InvoiceMCCWhereUniqueInput
    create: XOR<InvoiceMCCCreateWithoutSnapshotsInput, InvoiceMCCUncheckedCreateWithoutSnapshotsInput>
  }

  export type CustomerCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaff?: UserCreateNestedOneWithoutCustomersAssignedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMcInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaffId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMcInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutCustomerInput
    spendingRecords?: SpendingRecordUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSnapshotsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSnapshotsInput, CustomerUncheckedCreateWithoutSnapshotsInput>
  }

  export type UserCreateWithoutSnapshotsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    activityLogs?: ActivityLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSnapshotsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    activityLogs?: ActivityLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSnapshotsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSnapshotsInput, UserUncheckedCreateWithoutSnapshotsInput>
  }

  export type AccountUpsertWithoutSnapshotsInput = {
    update: XOR<AccountUpdateWithoutSnapshotsInput, AccountUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<AccountCreateWithoutSnapshotsInput, AccountUncheckedCreateWithoutSnapshotsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSnapshotsInput, AccountUncheckedUpdateWithoutSnapshotsInput>
  }

  export type AccountUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AccountBatchUpdateOneRequiredWithoutAccountsNestedInput
    currentMi?: InvoiceMCCUpdateOneWithoutAccountsNestedInput
    currentMc?: CustomerUpdateOneWithoutAccountsNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type InvoiceMCCUpsertWithoutSnapshotsInput = {
    update: XOR<InvoiceMCCUpdateWithoutSnapshotsInput, InvoiceMCCUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<InvoiceMCCCreateWithoutSnapshotsInput, InvoiceMCCUncheckedCreateWithoutSnapshotsInput>
    where?: InvoiceMCCWhereInput
  }

  export type InvoiceMCCUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: InvoiceMCCWhereInput
    data: XOR<InvoiceMCCUpdateWithoutSnapshotsInput, InvoiceMCCUncheckedUpdateWithoutSnapshotsInput>
  }

  export type InvoiceMCCUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutInvoiceMCCsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoiceMCCsCreatedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutInvoiceMccNestedInput
  }

  export type CustomerUpsertWithoutSnapshotsInput = {
    update: XOR<CustomerUpdateWithoutSnapshotsInput, CustomerUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<CustomerCreateWithoutSnapshotsInput, CustomerUncheckedCreateWithoutSnapshotsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSnapshotsInput, CustomerUncheckedUpdateWithoutSnapshotsInput>
  }

  export type CustomerUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaff?: UserUpdateOneWithoutCustomersAssignedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMcNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMcNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutSnapshotsInput = {
    update: XOR<UserUpdateWithoutSnapshotsInput, UserUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<UserCreateWithoutSnapshotsInput, UserUncheckedCreateWithoutSnapshotsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSnapshotsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSnapshotsInput, UserUncheckedUpdateWithoutSnapshotsInput>
  }

  export type UserUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    activityLogs?: ActivityLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    activityLogs?: ActivityLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutSpendingRecordsInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batch: AccountBatchCreateNestedOneWithoutAccountsInput
    currentMi?: InvoiceMCCCreateNestedOneWithoutAccountsInput
    currentMc?: CustomerCreateNestedOneWithoutAccountsInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutSpendingRecordsInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMiId?: string | null
    currentMcId?: string | null
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutAccountInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutAccountInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutSpendingRecordsInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSpendingRecordsInput, AccountUncheckedCreateWithoutSpendingRecordsInput>
  }

  export type InvoiceMCCCreateWithoutSpendingRecordsInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partner?: PartnerCreateNestedOneWithoutInvoiceMCCsInput
    createdBy: UserCreateNestedOneWithoutInvoiceMCCsCreatedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCUncheckedCreateWithoutSpendingRecordsInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
    createdById: string
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMiInput
    miHistories?: AccountMIHistoryUncheckedCreateNestedManyWithoutInvoiceMccInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutInvoiceMccInput
  }

  export type InvoiceMCCCreateOrConnectWithoutSpendingRecordsInput = {
    where: InvoiceMCCWhereUniqueInput
    create: XOR<InvoiceMCCCreateWithoutSpendingRecordsInput, InvoiceMCCUncheckedCreateWithoutSpendingRecordsInput>
  }

  export type CustomerCreateWithoutSpendingRecordsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaff?: UserCreateNestedOneWithoutCustomersAssignedInput
    accounts?: AccountCreateNestedManyWithoutCurrentMcInput
    mcHistories?: AccountMCHistoryCreateNestedManyWithoutCustomerInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutSpendingRecordsInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedStaffId?: string | null
    accounts?: AccountUncheckedCreateNestedManyWithoutCurrentMcInput
    mcHistories?: AccountMCHistoryUncheckedCreateNestedManyWithoutCustomerInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutSpendingRecordsInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutSpendingRecordsInput, CustomerUncheckedCreateWithoutSpendingRecordsInput>
  }

  export type AccountUpsertWithoutSpendingRecordsInput = {
    update: XOR<AccountUpdateWithoutSpendingRecordsInput, AccountUncheckedUpdateWithoutSpendingRecordsInput>
    create: XOR<AccountCreateWithoutSpendingRecordsInput, AccountUncheckedCreateWithoutSpendingRecordsInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSpendingRecordsInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSpendingRecordsInput, AccountUncheckedUpdateWithoutSpendingRecordsInput>
  }

  export type AccountUpdateWithoutSpendingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AccountBatchUpdateOneRequiredWithoutAccountsNestedInput
    currentMi?: InvoiceMCCUpdateOneWithoutAccountsNestedInput
    currentMc?: CustomerUpdateOneWithoutAccountsNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutSpendingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type InvoiceMCCUpsertWithoutSpendingRecordsInput = {
    update: XOR<InvoiceMCCUpdateWithoutSpendingRecordsInput, InvoiceMCCUncheckedUpdateWithoutSpendingRecordsInput>
    create: XOR<InvoiceMCCCreateWithoutSpendingRecordsInput, InvoiceMCCUncheckedCreateWithoutSpendingRecordsInput>
    where?: InvoiceMCCWhereInput
  }

  export type InvoiceMCCUpdateToOneWithWhereWithoutSpendingRecordsInput = {
    where?: InvoiceMCCWhereInput
    data: XOR<InvoiceMCCUpdateWithoutSpendingRecordsInput, InvoiceMCCUncheckedUpdateWithoutSpendingRecordsInput>
  }

  export type InvoiceMCCUpdateWithoutSpendingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutInvoiceMCCsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutInvoiceMCCsCreatedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateWithoutSpendingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccNestedInput
  }

  export type CustomerUpsertWithoutSpendingRecordsInput = {
    update: XOR<CustomerUpdateWithoutSpendingRecordsInput, CustomerUncheckedUpdateWithoutSpendingRecordsInput>
    create: XOR<CustomerCreateWithoutSpendingRecordsInput, CustomerUncheckedCreateWithoutSpendingRecordsInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutSpendingRecordsInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutSpendingRecordsInput, CustomerUncheckedUpdateWithoutSpendingRecordsInput>
  }

  export type CustomerUpdateWithoutSpendingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaff?: UserUpdateOneWithoutCustomersAssignedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMcNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutCustomerNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutSpendingRecordsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedStaffId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMcNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotCreateNestedManyWithoutCreatedByInput
  }

  export type UserUncheckedCreateWithoutActivityLogsInput = {
    id?: string
    email: string
    passwordHash: string
    fullName: string
    role?: $Enums.UserRole
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customersAssigned?: CustomerUncheckedCreateNestedManyWithoutAssignedStaffInput
    batchesCreated?: AccountBatchUncheckedCreateNestedManyWithoutCreatedByInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedCreateNestedManyWithoutCreatedByInput
    miHistoriesLinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutLinkedByInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedCreateNestedManyWithoutUnlinkedByInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutAssignedByInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedCreateNestedManyWithoutUnassignedByInput
    snapshots?: SpendingSnapshotUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserCreateOrConnectWithoutActivityLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
  }

  export type UserUpsertWithoutActivityLogsInput = {
    update: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
    create: XOR<UserCreateWithoutActivityLogsInput, UserUncheckedCreateWithoutActivityLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutActivityLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutActivityLogsInput, UserUncheckedUpdateWithoutActivityLogsInput>
  }

  export type UserUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCreatedByNestedInput
  }

  export type UserUncheckedUpdateWithoutActivityLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customersAssigned?: CustomerUncheckedUpdateManyWithoutAssignedStaffNestedInput
    batchesCreated?: AccountBatchUncheckedUpdateManyWithoutCreatedByNestedInput
    invoiceMCCsCreated?: InvoiceMCCUncheckedUpdateManyWithoutCreatedByNestedInput
    miHistoriesLinked?: AccountMIHistoryUncheckedUpdateManyWithoutLinkedByNestedInput
    miHistoriesUnlinked?: AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByNestedInput
    mcHistoriesAssigned?: AccountMCHistoryUncheckedUpdateManyWithoutAssignedByNestedInput
    mcHistoriesUnassigned?: AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type CustomerCreateManyAssignedStaffInput = {
    id?: string
    name: string
    contactInfo?: string | null
    status?: $Enums.CustomerStatus
    totalSpending?: Decimal | DecimalJsLike | number | string
    totalAccounts?: number
    activeAccounts?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountBatchCreateManyCreatedByInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
  }

  export type InvoiceMCCCreateManyCreatedByInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    partnerId?: string | null
  }

  export type AccountMIHistoryCreateManyLinkedByInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    invoiceMccId: string
    unlinkedById?: string | null
  }

  export type AccountMIHistoryCreateManyUnlinkedByInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    invoiceMccId: string
    linkedById: string
  }

  export type AccountMCHistoryCreateManyAssignedByInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    customerId: string
    unassignedById?: string | null
  }

  export type AccountMCHistoryCreateManyUnassignedByInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    customerId: string
    assignedById: string
  }

  export type SpendingSnapshotCreateManyCreatedByInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
    customerId?: string | null
  }

  export type ActivityLogCreateManyUserInput = {
    id?: string
    action: $Enums.ActivityAction
    entityType: string
    entityId: string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: string | null
    ipAddress?: string | null
    createdAt?: Date | string
  }

  export type CustomerUpdateWithoutAssignedStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutCurrentMcNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutCustomerNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutAssignedStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMcNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutCustomerNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutCustomerNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateManyWithoutAssignedStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contactInfo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCustomerStatusFieldUpdateOperationsInput | $Enums.CustomerStatus
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalAccounts?: IntFieldUpdateOperationsInput | number
    activeAccounts?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountBatchUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutBatchesNestedInput
    accounts?: AccountUpdateManyWithoutBatchNestedInput
  }

  export type AccountBatchUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type AccountBatchUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InvoiceMCCUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partner?: PartnerUpdateOneWithoutInvoiceMCCsNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    partnerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryUpdateWithoutLinkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutMiHistoriesNestedInput
    invoiceMcc?: InvoiceMCCUpdateOneRequiredWithoutMiHistoriesNestedInput
    unlinkedBy?: UserUpdateOneWithoutMiHistoriesUnlinkedNestedInput
  }

  export type AccountMIHistoryUncheckedUpdateWithoutLinkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: StringFieldUpdateOperationsInput | string
    unlinkedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryUncheckedUpdateManyWithoutLinkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: StringFieldUpdateOperationsInput | string
    unlinkedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryUpdateWithoutUnlinkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutMiHistoriesNestedInput
    invoiceMcc?: InvoiceMCCUpdateOneRequiredWithoutMiHistoriesNestedInput
    linkedBy?: UserUpdateOneRequiredWithoutMiHistoriesLinkedNestedInput
  }

  export type AccountMIHistoryUncheckedUpdateWithoutUnlinkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: StringFieldUpdateOperationsInput | string
    linkedById?: StringFieldUpdateOperationsInput | string
  }

  export type AccountMIHistoryUncheckedUpdateManyWithoutUnlinkedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: StringFieldUpdateOperationsInput | string
    linkedById?: StringFieldUpdateOperationsInput | string
  }

  export type AccountMCHistoryUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutMcHistoriesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutMcHistoriesNestedInput
    unassignedBy?: UserUpdateOneWithoutMcHistoriesUnassignedNestedInput
  }

  export type AccountMCHistoryUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    unassignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMCHistoryUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    unassignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMCHistoryUpdateWithoutUnassignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutMcHistoriesNestedInput
    customer?: CustomerUpdateOneRequiredWithoutMcHistoriesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutMcHistoriesAssignedNestedInput
  }

  export type AccountMCHistoryUncheckedUpdateWithoutUnassignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
  }

  export type AccountMCHistoryUncheckedUpdateManyWithoutUnassignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingSnapshotUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSnapshotsNestedInput
    invoiceMcc?: InvoiceMCCUpdateOneWithoutSnapshotsNestedInput
    customer?: CustomerUpdateOneWithoutSnapshotsNestedInput
  }

  export type SpendingSnapshotUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingSnapshotUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ActivityLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityActionFieldUpdateOperationsInput | $Enums.ActivityAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityActionFieldUpdateOperationsInput | $Enums.ActivityAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ActivityLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: EnumActivityActionFieldUpdateOperationsInput | $Enums.ActivityAction
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    oldValues?: NullableJsonNullValueInput | InputJsonValue
    newValues?: NullableJsonNullValueInput | InputJsonValue
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountBatchCreateManyPartnerInput = {
    id?: string
    mccAccountName?: string | null
    mccAccountId?: string | null
    isPrelinked?: boolean
    status?: $Enums.BatchStatus
    totalAccounts?: number
    liveAccounts?: number
    timezone?: string | null
    year?: number | null
    readiness?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type InvoiceMCCCreateManyPartnerInput = {
    id?: string
    name: string
    mccInvoiceId: string
    status?: $Enums.InvoiceMCCStatus
    creditStatus?: $Enums.CreditStatus
    linkedAccountsCount?: number
    activeAccountsCount?: number
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    createdById: string
  }

  export type AccountBatchUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutBatchesCreatedNestedInput
    accounts?: AccountUpdateManyWithoutBatchNestedInput
  }

  export type AccountBatchUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutBatchNestedInput
  }

  export type AccountBatchUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    isPrelinked?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumBatchStatusFieldUpdateOperationsInput | $Enums.BatchStatus
    totalAccounts?: IntFieldUpdateOperationsInput | number
    liveAccounts?: IntFieldUpdateOperationsInput | number
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableIntFieldUpdateOperationsInput | number | null
    readiness?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type InvoiceMCCUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdBy?: UserUpdateOneRequiredWithoutInvoiceMCCsCreatedNestedInput
    accounts?: AccountUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
    accounts?: AccountUncheckedUpdateManyWithoutCurrentMiNestedInput
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutInvoiceMccNestedInput
  }

  export type InvoiceMCCUncheckedUpdateManyWithoutPartnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    mccInvoiceId?: StringFieldUpdateOperationsInput | string
    status?: EnumInvoiceMCCStatusFieldUpdateOperationsInput | $Enums.InvoiceMCCStatus
    creditStatus?: EnumCreditStatusFieldUpdateOperationsInput | $Enums.CreditStatus
    linkedAccountsCount?: IntFieldUpdateOperationsInput | number
    activeAccountsCount?: IntFieldUpdateOperationsInput | number
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type AccountCreateManyBatchInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    currentMiId?: string | null
    currentMcId?: string | null
  }

  export type AccountUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMi?: InvoiceMCCUpdateOneWithoutAccountsNestedInput
    currentMc?: CustomerUpdateOneWithoutAccountsNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutBatchInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyCurrentMiInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMcId?: string | null
  }

  export type AccountMIHistoryCreateManyInvoiceMccInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    linkedById: string
    unlinkedById?: string | null
  }

  export type SpendingSnapshotCreateManyInvoiceMccInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    accountId: string
    customerId?: string | null
    createdById: string
  }

  export type SpendingRecordCreateManyInvoiceMccInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    accountId: string
    customerId?: string | null
  }

  export type AccountUpdateWithoutCurrentMiInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AccountBatchUpdateOneRequiredWithoutAccountsNestedInput
    currentMc?: CustomerUpdateOneWithoutAccountsNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCurrentMiInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutCurrentMiInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMcId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryUpdateWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutMiHistoriesNestedInput
    linkedBy?: UserUpdateOneRequiredWithoutMiHistoriesLinkedNestedInput
    unlinkedBy?: UserUpdateOneWithoutMiHistoriesUnlinkedNestedInput
  }

  export type AccountMIHistoryUncheckedUpdateWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    linkedById?: StringFieldUpdateOperationsInput | string
    unlinkedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryUncheckedUpdateManyWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    linkedById?: StringFieldUpdateOperationsInput | string
    unlinkedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingSnapshotUpdateWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSnapshotsNestedInput
    customer?: CustomerUpdateOneWithoutSnapshotsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type SpendingSnapshotUncheckedUpdateWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingSnapshotUncheckedUpdateManyWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingRecordUpdateWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSpendingRecordsNestedInput
    customer?: CustomerUpdateOneWithoutSpendingRecordsNestedInput
  }

  export type SpendingRecordUncheckedUpdateWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingRecordUncheckedUpdateManyWithoutInvoiceMccInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyCurrentMcInput = {
    id?: string
    googleAccountId: string
    accountName: string
    status?: $Enums.AccountStatus
    currency?: string
    timezone?: string | null
    mccAccountName?: string | null
    mccAccountId?: string | null
    totalSpending?: Decimal | DecimalJsLike | number | string
    lastSynced?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    batchId: string
    currentMiId?: string | null
  }

  export type AccountMCHistoryCreateManyCustomerInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    accountId: string
    assignedById: string
    unassignedById?: string | null
  }

  export type SpendingSnapshotCreateManyCustomerInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
    createdById: string
  }

  export type SpendingRecordCreateManyCustomerInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    accountId: string
    invoiceMccId?: string | null
  }

  export type AccountUpdateWithoutCurrentMcInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batch?: AccountBatchUpdateOneRequiredWithoutAccountsNestedInput
    currentMi?: InvoiceMCCUpdateOneWithoutAccountsNestedInput
    miHistories?: AccountMIHistoryUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutCurrentMcInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
    miHistories?: AccountMIHistoryUncheckedUpdateManyWithoutAccountNestedInput
    mcHistories?: AccountMCHistoryUncheckedUpdateManyWithoutAccountNestedInput
    snapshots?: SpendingSnapshotUncheckedUpdateManyWithoutAccountNestedInput
    spendingRecords?: SpendingRecordUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateManyWithoutCurrentMcInput = {
    id?: StringFieldUpdateOperationsInput | string
    googleAccountId?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    status?: EnumAccountStatusFieldUpdateOperationsInput | $Enums.AccountStatus
    currency?: StringFieldUpdateOperationsInput | string
    timezone?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountName?: NullableStringFieldUpdateOperationsInput | string | null
    mccAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    totalSpending?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    lastSynced?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    batchId?: StringFieldUpdateOperationsInput | string
    currentMiId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMCHistoryUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutMcHistoriesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutMcHistoriesAssignedNestedInput
    unassignedBy?: UserUpdateOneWithoutMcHistoriesUnassignedNestedInput
  }

  export type AccountMCHistoryUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    unassignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMCHistoryUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    unassignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingSnapshotUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSnapshotsNestedInput
    invoiceMcc?: InvoiceMCCUpdateOneWithoutSnapshotsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type SpendingSnapshotUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingSnapshotUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingRecordUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutSpendingRecordsNestedInput
    invoiceMcc?: InvoiceMCCUpdateOneWithoutSpendingRecordsNestedInput
  }

  export type SpendingRecordUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingRecordUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountId?: StringFieldUpdateOperationsInput | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryCreateManyAccountInput = {
    id?: string
    linkedAt: Date | string
    unlinkedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    invoiceMccId: string
    linkedById: string
    unlinkedById?: string | null
  }

  export type AccountMCHistoryCreateManyAccountInput = {
    id?: string
    assignedAt: Date | string
    unassignedAt?: Date | string | null
    reason: $Enums.HistoryReason
    notes?: string | null
    createdAt?: Date | string
    customerId: string
    assignedById: string
    unassignedById?: string | null
  }

  export type SpendingSnapshotCreateManyAccountInput = {
    id?: string
    spendingDate: Date | string
    cumulativeAmount: Decimal | DecimalJsLike | number | string
    snapshotAt: Date | string
    snapshotType: $Enums.SnapshotType
    createdAt?: Date | string
    invoiceMccId?: string | null
    customerId?: string | null
    createdById: string
  }

  export type SpendingRecordCreateManyAccountInput = {
    id?: string
    spendingDate: Date | string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    invoiceMccId?: string | null
    customerId?: string | null
  }

  export type AccountMIHistoryUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMcc?: InvoiceMCCUpdateOneRequiredWithoutMiHistoriesNestedInput
    linkedBy?: UserUpdateOneRequiredWithoutMiHistoriesLinkedNestedInput
    unlinkedBy?: UserUpdateOneWithoutMiHistoriesUnlinkedNestedInput
  }

  export type AccountMIHistoryUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMccId?: StringFieldUpdateOperationsInput | string
    linkedById?: StringFieldUpdateOperationsInput | string
    unlinkedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMIHistoryUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unlinkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMccId?: StringFieldUpdateOperationsInput | string
    linkedById?: StringFieldUpdateOperationsInput | string
    unlinkedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMCHistoryUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneRequiredWithoutMcHistoriesNestedInput
    assignedBy?: UserUpdateOneRequiredWithoutMcHistoriesAssignedNestedInput
    unassignedBy?: UserUpdateOneWithoutMcHistoriesUnassignedNestedInput
  }

  export type AccountMCHistoryUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    unassignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountMCHistoryUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    assignedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    unassignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: EnumHistoryReasonFieldUpdateOperationsInput | $Enums.HistoryReason
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customerId?: StringFieldUpdateOperationsInput | string
    assignedById?: StringFieldUpdateOperationsInput | string
    unassignedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingSnapshotUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMcc?: InvoiceMCCUpdateOneWithoutSnapshotsNestedInput
    customer?: CustomerUpdateOneWithoutSnapshotsNestedInput
    createdBy?: UserUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type SpendingSnapshotUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingSnapshotUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    cumulativeAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    snapshotAt?: DateTimeFieldUpdateOperationsInput | Date | string
    snapshotType?: EnumSnapshotTypeFieldUpdateOperationsInput | $Enums.SnapshotType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
  }

  export type SpendingRecordUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMcc?: InvoiceMCCUpdateOneWithoutSpendingRecordsNestedInput
    customer?: CustomerUpdateOneWithoutSpendingRecordsNestedInput
  }

  export type SpendingRecordUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SpendingRecordUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    spendingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invoiceMccId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerCountOutputTypeDefaultArgs instead
     */
    export type PartnerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartnerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountBatchCountOutputTypeDefaultArgs instead
     */
    export type AccountBatchCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountBatchCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceMCCCountOutputTypeDefaultArgs instead
     */
    export type InvoiceMCCCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceMCCCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerCountOutputTypeDefaultArgs instead
     */
    export type CustomerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountCountOutputTypeDefaultArgs instead
     */
    export type AccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PartnerDefaultArgs instead
     */
    export type PartnerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PartnerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountBatchDefaultArgs instead
     */
    export type AccountBatchArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountBatchDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InvoiceMCCDefaultArgs instead
     */
    export type InvoiceMCCArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InvoiceMCCDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CustomerDefaultArgs instead
     */
    export type CustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CustomerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountDefaultArgs instead
     */
    export type AccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountMIHistoryDefaultArgs instead
     */
    export type AccountMIHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountMIHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccountMCHistoryDefaultArgs instead
     */
    export type AccountMCHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccountMCHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpendingSnapshotDefaultArgs instead
     */
    export type SpendingSnapshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpendingSnapshotDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SpendingRecordDefaultArgs instead
     */
    export type SpendingRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SpendingRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ActivityLogDefaultArgs instead
     */
    export type ActivityLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ActivityLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}